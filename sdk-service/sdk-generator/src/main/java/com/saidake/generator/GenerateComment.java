package com.saidake.generator;
import com.saidake.common.core.util.file.FileUtil;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
public class GenerateComment {
    private static final String TARGET_FILE_PATH="D:\\Desktop\\DevProject\\saidake-manage-project\\sdk-service\\sdk-generator\\src\\main\\java\\com\\saidake\\generator\\MainTest.java";
    private static final String FUNCTION_NAME="test";
    private static final String SUMMARY_TITLE="Function summary (generated by saidake-manage-project):";

    // 本质为对函数所在行的改造
    public static void main(String[] args) throws IOException {
        //A. 公共数据
        Pattern commentStart = Pattern.compile("^\\s*?/\\*\\*\\s*?$");
        Pattern commentEnd = Pattern.compile("^\\s*?\\*/\\s*?$");  /**  */
//        Pattern functionStartPattern = Pattern.compile(String.format("^[^\"]+%s\\s*\\([^\"]*?\\)\\s*\\{\\s*", FUNCTION_NAME));
        Pattern functionStartPattern = Pattern.compile(String.format("^[^\"]+(public|private|protected)\\s*(static)?\\s*[A-z]+\\s*%s\\s*\\(", FUNCTION_NAME));
//        Pattern normalFunctionPattern = Pattern.compile("^[^\"]+[1-9A-z]+\\s*\\([^\"]*?\\)\\s*\\{\\s*");
        Pattern normalFunctionPattern = Pattern.compile("^[^\"]+(public|private|protected)\\s*(static)?\\s*[A-z]+\\s*[A-z]+\\s*\\(");
        Pattern commentNumberPattern = Pattern.compile("^\\s*//[A-Z]\\.\\s.*?");  //支持1-4
        List commentStorage=new ArrayList<CommentEntry>();
        final Boolean[] hasEndComment = new Boolean[]{false};
        final Boolean[] functionAlreadyStart = new Boolean[]{false};  // 函数开始
        final Boolean[] isFirstFunctionStart = new Boolean[]{false};  // 函数开始
        final Integer[] leftCount = new Integer[]{0};          //  { 的个数
        final Integer[] rightCount = new Integer[]{0};         //  } 的个数
        final String[] functionLine = new String[1];           // 函数所在行的字符串
        final String[] tempFunctionLine = new String[1];        // 临时函数行，拼接获取参数使用
        //A. 添加注释
        final int[] lineIndex = {0};                                     //  当前读取的行数
        final String[] checkCommentLine = new String[1];                 // 检测到的 注释行
        final Boolean[] checkCommentLineFlag = new Boolean[]{false};     // 是否开始检测 注释行
        final Boolean[] hasSummaryTitle = new Boolean[]{false};          // 是否已经有 function summary了
        FileUtil.readAndWriteFile(TARGET_FILE_PATH, TARGET_FILE_PATH, currentLine -> {
            lineIndex[0]++;
            //B. 移除当前行的字符串，统计 { 的个数
            String checkCountLine = currentLine.replaceAll("\".*?\"", "");
            //B. 公共数据
            Matcher commentStartMatcher = commentStart.matcher(currentLine);
            Matcher commentEndMatcher = commentEnd.matcher(currentLine);
            Matcher functionStartMatcher = functionStartPattern.matcher(currentLine);
            Matcher normalFunctionMatcher = normalFunctionPattern.matcher(currentLine);
            boolean isSearchFunction = functionStartMatcher.find();
            //================================================================================== 通用检测逻辑
            //B. 函数已经开始了
            if(isFirstFunctionStart[0]){
                functionAlreadyStart[0]=true;
                isFirstFunctionStart[0]=false;
            }
            //B. 注释开始了，检测是否有注释结尾
            if(commentEndMatcher.find()&&checkCommentLineFlag[0]){
                log.info("comment ended: {}",currentLine);
                hasEndComment[0] = true; // 出现注释结尾符
            }
            //B. 注释开始时，检测注释是否已经存在function summary
            if(currentLine.endsWith(SUMMARY_TITLE)&&checkCommentLineFlag[0]){
                log.info("already has function summary");
                hasSummaryTitle[0]=true;
            }
            //B. 不是函数的首行，并且函数的首行没有{，拼接函数字符串
            if(tempFunctionLine[0]!=null&&!isFirstFunctionStart[0]){
                tempFunctionLine[0]=tempFunctionLine[0]+" "+currentLine;
                if(currentLine.contains("{")){
                    isFirstFunctionStart[0]=true;
                }
            }
            //================================================================================== 收集信息逻辑
            //B. 当注释开始时，开始收集信息
            if (commentStartMatcher.find()) {
                checkCommentLine[0]=currentLine;
                checkCommentLineFlag[0]=true;
                log.info("mark comment");
                return FileUtil.SDK_MARK_TAG;
            }
            //B. 检测首次出现的函数行，并且不是要找的函数
            if(checkCommentLineFlag[0]&&normalFunctionMatcher.find()&&!isSearchFunction){
                hasEndComment[0]=false;
                hasSummaryTitle[0]=false;
                checkCommentLineFlag[0]=false;
                log.info("return mark, and it is not the function to look for: {}",currentLine);
                return FileUtil.SDK_RETURN_MARK_TAG+checkCommentLine[0]+System.lineSeparator();
            }
            //B. 当函数开始时
            if(isSearchFunction){
                log.info("function start: {}",currentLine);
                functionLine[0] =currentLine;
                tempFunctionLine[0]=currentLine;
                if(currentLine.contains("{")){
                    isFirstFunctionStart[0]=true;
                }
                //C. 没有注释时
                if(!hasEndComment[0]){
                    //D. 当函数首次开始，并且没有注释时，返回SDK_MARK_TAG，标记当前函数行
                    log.info("mark function and no comment");
                    return FileUtil.SDK_MARK_TAG;
                }
            }
            //================================================================================== 核心逻辑
            //B. 当函数已经开始，并且不是开始的"{"行，开始搜集信息
//            log.info("currentLine: {}, functionAlreadyStart[0]: {}, isFirstFunctionStart: {}",currentLine,functionAlreadyStart[0],isFirstFunctionStart);
            if(functionAlreadyStart[0]){
                // 计算是否到达函数底部
                int currentLeftCount = checkCountLine.length()-checkCountLine.replaceAll("\\{","").length();
                int currentRightCount = checkCountLine.length()-checkCountLine.replaceAll("}","").length();
                leftCount[0]+=leftCount[0]+currentLeftCount;
                rightCount[0]+=rightCount[0]+currentRightCount;
//                log.info("leftCount: {}, rightCount: {}, currentLine: {}",leftCount[0],rightCount[0],currentLine);
                // 检测序列号 A-Z
                Matcher commentNumberMatcher = commentNumberPattern.matcher(checkCountLine);
                if(commentNumberMatcher.find()){
                    int currentCommentNumber= (int) commentNumberMatcher.group(0).replaceAll("[^A-Z]", "").charAt(0)-64;  // 从1开始
                    String currentCommentContent = checkCountLine.replaceAll("^\\s*//[A-Z]\\.\\s.*?", "").trim();
                    commentStorage.add(new CommentEntry(currentCommentNumber,currentCommentContent));
                }
                //B. 当函数已经结束时，返回最终字符串
                if(rightCount[0]-leftCount[0]==1){
                    functionAlreadyStart[0]=false;
//                    log.info("function already done, commentStorage: {}",commentStorage);
                    String emptyString = functionLine[0].replaceAll("[^\\s].*?$", "");
                    String emptyStarString = functionLine[0].replaceAll("[^\\s].*?$", "")+" * ";
                    String paramString = tempFunctionLine[0].replaceAll(".*?\\(", "").replaceAll("\\).*?$", "");

                    //C. 没有注释时
                    if(!hasEndComment[0]){
                        StringBuilder stringBuilder = new StringBuilder();
                        String[] paramList = paramString.split(",");
                        List<String> paramNameList = Arrays.stream(paramList).map(item -> item.trim().replaceAll("^.*?\\s", "").trim()).collect(Collectors.toList());
                        String returnString = functionLine[0].replaceAll("\\(.*?", "").trim();
                        //D. 添加注释
                        appendToStringBuilder(stringBuilder, emptyString + "/**");
                        //D. 添加额外详细注释
                        appendToStringBuilder(stringBuilder, emptyStarString + SUMMARY_TITLE);  // ["ccc", ["a",["b","k"]], ["z","c"] ]         1 1         ["b","k"]    //3
                        handleAppendComment(stringBuilder,commentStorage,emptyStarString);
                        appendToStringBuilder(stringBuilder, emptyStarString);
                        //D. 其他参数
                        paramNameList.forEach(item -> appendToStringBuilder(stringBuilder, emptyStarString + "@param\t" + item));
                        if (!"void".equals(returnString)) {
                            appendToStringBuilder(stringBuilder, emptyStarString + "@return\t");
                        }
                        appendToStringBuilder(stringBuilder, emptyString + " */");
                        appendToStringBuilder(stringBuilder, functionLine[0]);
                        log.info("return mark, no comment: {}",currentLine);
                        return FileUtil.SDK_RETURN_MARK_TAG+stringBuilder;
                    }else if(!hasSummaryTitle[0]){
                        //C. 有注释，并且没有function summary
                        StringBuilder stringBuilder = new StringBuilder(checkCommentLine[0]);
                        stringBuilder.append(System.lineSeparator());
                        appendToStringBuilder(stringBuilder, emptyStarString + SUMMARY_TITLE);  // ["ccc", ["a",["b","k"]], ["z","c"] ]         1 1         ["b","k"]    //3
                        handleAppendComment(stringBuilder,commentStorage,emptyStarString);
                        appendToStringBuilder(stringBuilder, emptyStarString);
                        log.info("return mark, already has comment and no function summary: {}",currentLine);
                        return FileUtil.SDK_RETURN_MARK_TAG+stringBuilder;
                    }else{
                    //C. 有注释，并且有function summary
                        log.info("return mark, already has comment and function summary: {}",currentLine);
                        return FileUtil.SDK_RETURN_MARK_TAG+checkCommentLine[0]+System.lineSeparator();
                    }
                }
            }
            return currentLine + System.lineSeparator();
            //B. END
        });
        //A. END
    }

    @Data
    @AllArgsConstructor
    private static class CommentEntry{
        private Integer level;
        private String content;
    }
    private static void handleAppendComment(StringBuilder stringBuilder,List<CommentEntry> commentStorage,String commentStartEmpty){
        commentStorage.forEach(item-> appendToStringBuilder(stringBuilder, commentStartEmpty+ StringUtils.repeat("    ",item.getLevel())+item.getContent()));
    }

    private static void appendToStringBuilder(StringBuilder stringBuilder, String str) {
        stringBuilder.append(str);
        stringBuilder.append(System.lineSeparator());
    }
}
