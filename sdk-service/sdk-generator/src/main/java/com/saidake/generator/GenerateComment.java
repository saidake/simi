package com.saidake.generator;
import com.saidake.common.core.util.file.FileUtil;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class GenerateComment {
    private static final String TARGET_FILE_PATH="D:\\Desktop\\DevProject\\saidake-manage-project\\sdk-service\\sdk-generator\\src\\main\\java\\com\\saidake\\generator\\MainTest.java";
    private static final String FUNCTION_NAME="test";
    private static final String FUNCTION_PREFIX=" * ";
    private static final String SUMMARY_TITLE="Function summary (generated by saidake-manage-project):";

    // 本质为对函数所在行的改造
    public static void main(String[] args) {
        String projectRootPath = System.getProperty("user.dir");
        String blackboard = FileUtil.joinPath(projectRootPath, "sdk-service/sdk-generator/src/main/java/com/saidake/generator/blackboard.txt");
        try(BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(TARGET_FILE_PATH)));
            BufferedWriter bufferedWriter=new BufferedWriter(new FileWriter(new File(blackboard)))
        ){
            //A. 公共数据
            Pattern functionStartPattern = Pattern.compile(String.format("^[^\"]+(public|private|protected)\\s*(static)?\\s*[A-z]+\\s*%s\\s*\\(", FUNCTION_NAME));
            Pattern commentNumberPattern = Pattern.compile("^\\s*//[A-Z]\\.\\s.*?");  //支持1-4
            List<CommentEntry> commentStorage=new ArrayList<>();
            boolean isFunctionFirstLine=false;
            boolean isFunctionFirstLineEnded=false;
            boolean isAlreadyEnteredFunction=false;
            int leftCount = 0;          //  { 的个数
            int rightCount = 0;         //  } 的个数
            for ( String currentLine = bufferedReader.readLine();currentLine!=null;currentLine = bufferedReader.readLine()) {
                Matcher functionStartMatcher = functionStartPattern.matcher(currentLine);
                // 之前函数开始部分已经结束了
                if(isFunctionFirstLineEnded){
                    isAlreadyEnteredFunction=true;
                }
                // 找到目标函数了（首行通过，但是没有{，继续检测）
                if(functionStartMatcher.find()||isFunctionFirstLine){
                    isFunctionFirstLine=true;
                    if(currentLine.contains("{"))isFunctionFirstLineEnded=true;
                }
                // 已经进入函数内部
                if(isAlreadyEnteredFunction){
                    String checkCountLine = currentLine.replaceAll("\".*?\"", "");
                    Matcher commentNumberMatcher = commentNumberPattern.matcher(checkCountLine);
                    if(commentNumberMatcher.find()){
                        int currentCommentNumber= (int) commentNumberMatcher.group(0).replaceAll("[^A-Z]", "").charAt(0)-64;  // 从1开始
                        String currentCommentContent = checkCountLine.replaceAll("^\\s*//[A-Z]\\.\\s.*?", "").trim();
                        commentStorage.add(new CommentEntry(currentCommentNumber,currentCommentContent));
                    }
                    int currentLeftCount = checkCountLine.length()-checkCountLine.replaceAll("\\{","").length();
                    int currentRightCount = checkCountLine.length()-checkCountLine.replaceAll("}","").length();
                    leftCount+=leftCount+currentLeftCount;
                    rightCount+=rightCount+currentRightCount;
                    // 到达函数底部
                    if(rightCount-leftCount==1){
                        log.info("entered function end: {}",currentLine);
                        bufferedWriter.write(FUNCTION_PREFIX+SUMMARY_TITLE+System.lineSeparator());
                        for (CommentEntry item : commentStorage) {
                            bufferedWriter.write(FUNCTION_PREFIX+StringUtils.repeat("    ", item.getLevel()) + item.getContent()+System.lineSeparator());
                        }
                        return;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    @Data
    @AllArgsConstructor
    private static class CommentEntry{
        private Integer level;
        private String content;
    }

}
