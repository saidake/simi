
Java = Concept
Java Environment
面试：Java。面试体验还不错，面试难度挺大的，应该是通过了。
视频面
2.14， 17：40， 25min；
1.项目中用到的 MySQL 索引调优过程，JVM 调优过程；从无锁引的全表扫描，到建立普通索引的索引扫描，再到联合索引的索引范围扫描，避免了回表的次数；JVM 调优为了降低 Minor GC 和 Major GC 的次数，分析是因为动态晋升年龄过小导致老年代频繁被打满，通过调大新生代内存，减少 Minor GC 次数，增大了老年代的晋升年龄，进而减少了 Major GC 的次数；
2. AQS 队列的原理答了 AQS 队列的基本原理，介绍 ReentrentLock 的实现过程；
3. 介绍一下 CAS 讲了 CAS 中的三个重要参数，介绍了 ABA 问题以及它的解决方案；
4. ThreadLocal 的作用拷贝共享变量的副本，避免发生线程安全的问题，讲了内存泄漏，强软弱虚四种引用方式，底层 ThreadLocalMap 的哈希冲突解决方案；
5. HashMap ， TreeMap 的区别
6. SpringBoot 启动的过程 （不会）
7. Spring 中对象注入可能存在的问题 Autowired 注入 默认以 Type 注入，接口如果有多个实现类的话需要用 name ，默认是根据变量名为类名去找要注入的具体类，也可以使用 Qualifier 注解指定具体要注入的类名
8. MySQL 中的最左匹配问题
JDK（Java Development Kit）
1.	What is JDK?
JDK stands for Java Development Kit. It's a software development environment that's used to create Java applications and applets.
2.	What does the JDK include?
1)	Java Virtual Machine (JVM)
2)	Class libraries

1)	Java Runtime Environment (JRE)

1)	Compiler (javac)
2)	Interpreter (java)
3)	Archiver (jar)
4)	Documentation generator (javadoc)

JRE（Java Runtime Environment）
1.	What is JRE?
Ordinary users do not need to install JDK to run Java programs, do not need a compiler, and only need to install JRE.
2.	What does the JRE include?
1)	Java Virtual Machine (JVM)
2)	Class libraries

JVM（Java Virtual Machine）
1.	What's JVM?
The Java Virtual Machine is an abstract computing machine.

Like a real computing machine, it has an instruction set and manipulates various memory areas at run time.
Essentially, it is a program. After it starts, it can execute instructions in the bytecode file.
2.	When is the virtual machine instantiated?
When a program starts running, the virtual machine begins to be instantiated.
When multiple programs start, there will be multiple virtual machine instances, If the program exits or closes, the virtual machine instance will disappear.
3.	Is virtual machine data shared?
Data cannot be shared between multiple virtual machine instances.

1.	What components does the JVM consist of?
1)	Class Loader
2)	Runtime Data Area
3)	Execution Engine


2.	Compilation process
1)	Java source file -> javac compiler   -> bytecode file
2)	Bytecode file    -> JVM interpreter -> Machine code (for specific machines)
3.	Dynamic compilation (refers to compiling at runtime)
1)	Ahead-of-time compilation (AOT）       It refers to compiling before running, also known as static compilation.
2)	Adaptive dynamic compilation			      A type of dynamic compilation, but it usually executes later than JIT compilation,
allowing the program to run in a certain form first, collecting some information, and then performing dynamic compilation.
3)	Just-in-time compilation (JIT)                JIT compilation refers to the compilation of a piece of code when it is about to be executed for the first time, hence it is called instant compilation.
JIT compilation is a special case of dynamic compilation.
Compiles the given bytecode instruction sequence to machine code at runtime before executing it natively.
4.	What’s the difference between interpreter and JIT compiler? (google)
An interpreter executes source code directly, while a Just-in-Time (JIT) compiler compiles the most frequently used code while the program is running.

1.	Portability
The interpreters for each platform are different, but the virtual machines implemented are the same, which is why Java can cross platforms.
2.	JVM type
1)	Free and open source implementations
•	HotSpot JVM (interpreter + JIT compiler)
HotSpot is a Java virtual machine (JVM) for desktop and server computers.
It was originally developed by Sun Microsystems and is now maintained and distributed by Oracle Corporation.
It is a virtual machine included in Oracle JDK and Open JDK, and is currently the most widely used Java virtual machine.
(Oracle acquired Sun Microsystems in 2010, so Sun JDK is now Oracle JDK.）
•	JamVM (interpreter)
2)	Proprietary implementations
•	JRockit VM  (interpreter + JIT compiler)
JRockit is a Java virtual machine (JVM) that allows Java applications to run on Windows and Linux operating systems. It's especially well-suited for running Oracle WebLogic Server.
JRockit focuses on server-side applications, which can be less focused on program startup speed.
JRockit does not include an interpreter implementation internally, and all code is compiled and executed by the JIT compiler.

JVM Structure
Reference:
The JVM Run-Time Data Areas
https://www.baeldung.com/java-jvm-run-time-data-areas
https://blog.jamesdbloom.com/JVMInternals.html



Core Components
The PC Register (thread private)
1.	What is PC Register? (google ai)
The PC Register is a runtime data area used by the JVM to hold the address of the current instruction being executed by a thread.
Each thread has its own PC register, and the PC register is updated with the next instruction after it is executed.
2.	When is the PC Register created?
A PC Register is created every time a new thread is created.
3.	What is contained in the PC register?
At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread.

If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed.
If the method currently being executed by the thread is native, the value of the Java Virtual Machine's pc register is undefined.

4.	PC register Exception
The Java Virtual Machine's pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.
Method Area (thread shared)
1.	What's Method Area?
The Method Area is a shared data area in the JVM that stores class and interface structure data.
2.	When is the Method Area created?
It is created when the JVM starts, and it is destroyed only when the JVM exits.
3.	What is contained in the Method Area?
It stores the class and interface structure data loaded by the Class Loader,
（such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and interface initialization and in instance initialization ).

Note: Please refer to the ClassFile Structure.

Here are some examples of class and interface structure data that is stored in the Method Area:
•	The fully qualified name of the java.lang.Object class
•	The fully qualified name of the java.lang.String class
•	The modifiers for the java.lang.Object class
•	The fields declared by the java.lang.Object class
•	The methods declared by the java.lang.Object class
•	The constructors declared by the java.lang.Object class
•	The run-time constant pool for the java.lang.Object class

4.	How is the Method Area implemented?
Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it.
This specification does not mandate the location of the method area or the policies used to manage compiled code.
5.	What's the difference between metaspace and method area in jvm?
Method Area is also known as the Permanent Generation. Starting from JDK 8, the Permanent Generation is replaced by the Metaspace, which is located in native memory.

1.	Is the size of the Method Area fixed?
The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary.
The memory for the method area does not need to be contiguous.

A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area,
as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.
2.	Method Area Exception
•	If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.

Run-Time Constant Pool
1.	What's the Run-Time constant Pool?
A run-time constant pool is a per-class or per-interface run-time representation of the constant_pool table in a class file.
Each run-time constant pool is allocated from the Java Virtual Machine's Method Area (§2.5.4).
Note: Please refer to the ClassFile Structure.

The Java Virtual Machine maintains a per-type constant pool (§2.5.5), a run-time data structure that serves many of the purposes of the symbol table of a conventional programming language implementation.
The constant_pool table (§4.4) in the binary representation of a class or interface is used to construct the run-time constant pool upon class or interface creation (§5.3).
All references in the run-time constant pool are initially symbolic.

The symbolic references in the run-time constant pool are derived from structures in the binary representation of the class or interface as follows:
•	A symbolic reference to a class or interface is derived from a CONSTANT_Class_info structure (§4.4.1) in the binary representation of a class or interface.
Such a reference gives the name of the class or interface in the form returned by the Class.getName method, that is:
o	For a nonarray class or an interface, the name is the binary name (§4.2.1) of the class or interface.
o	For an array class of n dimensions, the name begins with n occurrences of the ASCII "[" character followed by a representation of the element type:
	If the element type is a primitive type, it is represented by the corresponding field descriptor (§4.3.2).
	Otherwise, if the element type is a reference type, it is represented by the ASCII "L" character followed by the binary name (§4.2.1) of the element type followed by the ASCII ";" character.
Whenever this chapter refers to the name of a class or interface, it should be understood to be in the form returned by the Class.getName method.
•	A symbolic reference to a field of a class or an interface is derived from a CONSTANT_Fieldref_info structure (§4.4.2) in the binary representation of a class or interface.
Such a reference gives the name and descriptor of the field, as well as a symbolic reference to the class or interface in which the field is to be found.
•	A symbolic reference to a method of a class is derived from a CONSTANT_Methodref_info structure (§4.4.2) in the binary representation of a class or interface.
Such a reference gives the name and descriptor of the method, as well as a symbolic reference to the class in which the method is to be found.
•	A symbolic reference to a method of an interface is derived from a CONSTANT_InterfaceMethodref_info structure (§4.4.2) in the binary representation of a class or interface.
Such a reference gives the name and descriptor of the interface method, as well as a symbolic reference to the interface in which the method is to be found.
•	A symbolic reference to a method handle is derived from a CONSTANT_MethodHandle_info structure (§4.4.8) in the binary representation of a class or interface.
•	A symbolic reference to a method type is derived from a CONSTANT_MethodType_info structure (§4.4.9) in the binary representation of a class or interface.
•	A symbolic reference to a call site specifier is derived from a CONSTANT_InvokeDynamic_info structure (§4.4.10) in the binary representation of a class or interface.
Such a reference gives:
o	a symbolic reference to a method handle, which will serve as a bootstrap method for an invokedynamic instruction (§invokedynamic);
o	a sequence of symbolic references (to classes, method types, and method handles), string literals, and run-time constant values which will serve as static arguments to a bootstrap method;
o	a method name and method descriptor.
In addition, certain run-time values which are not symbolic references are derived from items found in the constant_pool table:
•	A string literal is a reference to an instance of class String, and is derived from a CONSTANT_String_info structure (§4.4.3) in the binary representation of a class or interface.
The CONSTANT_String_info structure gives the sequence of Unicode code points constituting the string literal.
The Java programming language requires that identical string literals (that is, literals that contain the same sequence of code points) must refer to the same instance of class String (JLS §3.10.5). In addition, if the method String.intern is called on any string, the result is a reference to the same class instance that would be returned if that string appeared as a literal. Thus, the following expression must have the value true:
("a" + "b" + "c").intern() == "abc"

To derive a string literal, the Java Virtual Machine examines the sequence of code points given by the CONSTANT_String_info structure.
o	If the method String.intern has previously been called on an instance of class String containing a sequence of Unicode code points identical to that given by the CONSTANT_String_info structure, then the result of string literal derivation is a reference to that same instance of class String.
o	Otherwise, a new instance of class String is created containing the sequence of Unicode code points given by the CONSTANT_String_info structure; a reference to that class instance is the result of string literal derivation. Finally, the intern method of the new String instance is invoked.
•	Run-time constant values are derived from CONSTANT_Integer_info, CONSTANT_Float_info, CONSTANT_Long_info,
or CONSTANT_Double_info structures (§4.4.4, §4.4.5) in the binary representation of a class or interface.

Note that CONSTANT_Float_info structures represent values in IEEE 754 single format and CONSTANT_Double_info structures represent values in IEEE 754 double format (§4.4.4, §4.4.5). The run-time constant values derived from these structures must thus be values that can be represented using IEEE 754 single and double formats, respectively.

The remaining structures in the constant_pool table of the binary representation of a class or interface - the CONSTANT_NameAndType_info and CONSTANT_Utf8_info structures (§4.4.6, §4.4.7) - are only used indirectly when deriving symbolic references to classes, interfaces, methods, fields, method types, and method handles, and when deriving string literals and call site specifiers.

2.	When is the Run-Time Constant Pool constructed?
The run-time constant pool for a class or interface is constructed when the class or interface is created (§5.3) by the Java Virtual Machine.
3.	What is contained in the Run-Time Constant Pool?
It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time.
(symbolic references to the class and interface names, field names, and method names)
the runtime constant pool in Java contains symbolic references, not actual references.

Note: Please refer to the Constant Pool.

1.	The following exceptional condition is associated with the construction of the run-time constant pool for a class or interface:
•	When creating a class or interface, if the construction of the run-time constant pool requires more memory than can be made available in the method area of the Java Virtual Machine,
the Java Virtual Machine throws an OutOfMemoryError.
See §5 (Loading, Linking, and Initializing) for information about the construction of the run-time constant pool.

Heap (thread shared)
1.	What is Java Heap?
The Heap is a runtime data area where all Java objects (all class instances and arrays) are stored ( Arrays and object references are stored in the Java Stack).
Thus, whenever we create a new class instance or array, the JVM will find some available memory in the Heap and assign it to the object.
2.	When is the Heap created?
The Heap’s creation occurs at the JVM start-up, and its destruction happens at the exit.
3.	What is contained in Java Heap?
All Java objects (all class instances and arrays)
4.	Is the Java Heap algorithm fixed?
Heap storage for objects is reclaimed by an automatic storage management system (known as a garbage collector);
objects are never explicitly deallocated. The Java Virtual Machine assumes no particular type of automatic storage management system,
and the storage management technique may be chosen according to the implementor's system requirements.
5.	String Pool
1)	What is String Pool?
The Java String Pool is a storage area in the Java heap that stores string literals.
Shared String objects are maintained in the string pool, and these strings will not be recycled by the garbage collector.
It's also known as the String Intern Pool or String Constant Pool.
String Pool is possible because String is immutable in Java and it is an implementation of String interning concept.
2)	What's the process of creating string?
When we use double quotes to create a String, it first looks for String with the same value in the String pool,
if found it just returns the reference, otherwise it creates a new String in the pool and then returns the reference.

String str = new String("Cat");

In the above statement, either 1 or 2 string will be created.
If there is already a string literal "Cat" in the pool, then only one string "str" will be created in the pool.
If there is no string literal "Cat" in the pool, then it will be first created in the pool and then in the heap space, so a total of 2 string objects will be created.

1.	Is the size of Java Heap fixed?
The heap may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger heap becomes unnecessary.
The memory for the heap does not need to be contiguous.

A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the heap, as well as,
if the heap can be dynamically expanded or contracted, control over the maximum and minimum heap size.
2.	Java Heap Exception
    If a computation requires more heap than can be made available by the automatic storage management system, the Java Virtual Machine throws an OutOfMemoryError.
Escape Analysis
1.	What's the Escape Analysis?
Escape Analysis is a method for determining the dynamic scope of objects -- where in the program an object can be accessed.
Escape Analysis determines all the places where an object can be stored and whether the lifetime of the object can be proven to be restricted only to the current method and/or thread.
2.	How is the Escape Analysis performed?
If the object does not escape, then the JVM could, for example, do something similar to an “automatic stack allocation” of the object.
In this case, the object would not be allocated on the heap and it would never need to be managed by the garbage collector.
As soon as the method containing the stack-allocated object returned, the memory that the object used would immediately be freed.
3.	How many types of Object Escape are there?
Within the HotSpot VM source code, you can see how the EA analysis system classifies the usage of each object:
typedef enum {
   NoEscape = 1,         // An object does not escape method or thread and it is not passed to call. It could be replaced with scalar.
   ArgEscape = 2,         // An object does not escape method or thread but it is passed as argument to call or referenced by argument and it does not escape during call.
   GlobalEscape = 3     // An object escapes the method or thread.
}
4.	How many types of optimization are there in escape analysis?
1)	The first option suggests that the object can be replaced by a scalar substitute.
This elimination is called scalar replacement. This means that the object is broken up into its component fields,
which are turned into the equivalent of extra local variables in the method that allocates the object.

Once this has been done, another HotSpot VM JIT technique can kick in, which enables these object fields (and the actual local variables) to be stored in CPU registers (or on the stack if necessary).
2)	Method inlining is one of the first optimizations and is known as a gateway optimization,
because it opens the door to other techniques by first bringing related code closer together.

public class Rect {
   private int w;
   private int h;
   public Rect(int w, int h) {
      this.w = w;
      this.h = h;
   }
   public int area() {
      return w * h;
   }
   public boolean sameArea(Rect other) {
      return this.area() == other.area();
   }
   public static void main(final String[] args) {
      java.util.Random rand = new java.util.Random();
      int sameArea = 0;
      for (int i = 0; i < 100_000_000; i++) {
         Rect r1 = new Rect(rand.nextInt(5), rand.nextInt(5));
         Rect r2 = new Rect(rand.nextInt(5), rand.nextInt(5));
         if (r1.sameArea(r2)) { sameArea++; }
      }
      System.out.println("Same area: " + sameArea);
   }
}

public boolean sameArea(Rect);
   Code:
      0: aload_0
      1: invokevirtual #4    // Method area:()I
      4: aload_1
      5: invokevirtual #4    // Method area:()I
      8: if_icmpne     15
     11: iconst_1
     12: goto          16
     15: iconst_0
     16: ireturn

public int area();
   Code:
      0: aload_0       #2    // Field w:I

      1: getfield
      4: aload_0
      5: getfield      #3    // Field h:I

      8: imul
      9: ireturn

Now that the call to sameArea() and the calls to area have been inlined,
the method scopes no longer exist,
and the variables are present only in the scope of main().
This means that EA will no longer treat either r1 or r2 as an ArgEscape:
both are now classified as a NoEscape after the methods have been fully inlined.

Thread Local Allocation Buffer
1.	What's the Thread Local Allocation Buffer in jvm?
TLAB stands for Thread Local Allocation Buffer and it is a region inside Eden, which is exclusively assigned to a thread.
In other words, only a single thread can allocate new objects in this area. Each thread has own TLAB.

https://www.researchgate.net/publication/221137885_Supporting_per-processor_local-allocation_buffers_using_lightweight_user-level_preemption_notification


Java Virtual Machine Stack (thread  private)
1.	What's Java Virtual Machine Stack?
The JVM Stack is a runtime data area that stores method invocation information.
2.	When is the Java Virtual Machine Stack created?
Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread.
3.	What is contained in the Java Virtual Machine Stack?
A Java Virtual Machine stack stores frames (§2.6). A Java Virtual Machine stack is analogous to the stack of a conventional language such as C:
Each method call triggers the creation of a new frame on the stack to store the method’s local variables and the return address. Those frames can be stored in the Heap.

Because the Java Virtual Machine stack is never manipulated directly except to push and pop frames, frames may be heap allocated.
The memory for a Java Virtual Machine stack does not need to be contiguous.

4.	Is the size of Java Virtual Machine Stack fixed?
This specification permits Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and contract as required by the computation.
If the Java Virtual Machine stacks are of a fixed size, the size of each Java Virtual Machine stack may be chosen independently when that stack is created.

A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of Java Virtual Machine stacks, as well as,
in the case of dynamically expanding or contracting Java Virtual Machine stacks, control over the maximum and minimum sizes.
5.	The following exceptional conditions are associated with Java Virtual Machine stacks:
•	If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a StackOverflowError.
•	If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion,
or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.
Frames
1.	What's a Stack Frame?
A frame is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.
2.	When is a Stack Frame created?
A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception).
Frames are allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame.
3.	What's contained in a Stack Frame?
Each frame has its own array of local variables (§2.6.1), its own operand stack (§2.6.2), and a reference to the run-time constant pool (§2.5.5) of the class of the current method.

A frame may be extended with additional implementation-specific information, such as debugging information.
4.	What determines the size of a Stack Frame?
The sizes of the local variable array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame (§4.7.3).
Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.
5.	How does the Java Stack operate the Stack Frame?
Only one frame, the frame for the executing method, is active at any point in a given thread of control.
This frame is referred to as the current frame, and its method is known as the current method. The class in which the current method is defined is the current class.
Operations on local variables and the operand stack are typically with reference to the current frame.

A frame ceases to be current if its method invokes another method or if its method completes.
When a method is invoked, a new frame is created and becomes current when control transfers to the new method.
On method return, the current frame passes back the result of its method invocation, if any, to the previous frame.
The current frame is then discarded as the previous frame becomes the current one.
Note that a frame created by a thread is local to that thread and cannot be referenced by any other thread.
Local Variables
1.	How to determine the length of Local Variables in Stack Frame?
Each frame (§2.6) contains an array of variables known as its local variables.
The length of the local variable array of a frame is determined at compile-time and supplied in the binary representation of a class or interface along with the code for the method associated with the frame (§4.7.3).
so the length of the local variable array does not change during program execution.
2.	What types of values do Local Variables have?
A single local variable can hold a value of type boolean, byte, char, short, int, float, reference, or returnAddress (return to the place where the method was called before).
A pair of local variables can hold a value of type long or double.
3.	How are Local Variables addressed?
Local variables are addressed by indexing. The index of the first local variable is zero.
An integer is considered to be an index into the local variable array if and only if that integer is between zero and one less than the size of the local variable array.
4.	How are values of type long and type double represented?
A value of type long or type double occupies two consecutive local variables. Such a value may only be addressed using the lesser index.
For example, a value of type double stored in the local variable array at index n actually occupies the local variables with indices n and n+1;
however, the local variable at index n+1 cannot be loaded from.
It can be stored into. However, doing so invalidates the contents of local variable n.
The Java Virtual Machine does not require n to be even. In intuitive terms, values of types long and double need not be 64-bit aligned in the local variables array.
Implementors are free to decide the appropriate way to represent such values using the two local variables reserved for the value.

5.	What's the Local Variable 0 on method invocation?
The Java Virtual Machine uses local variables to pass parameters on method invocation.
On class method invocation, any parameters are passed in consecutive local variables starting from local variable 0.
On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (this in the Java programming language).
Any parameters are subsequently passed in consecutive local variables starting from local variable 1.
Operand Stacks
1.	What's Operand Stacks?
Each frame (§2.6) contains a last-in-first-out (LIFO) stack known as its operand stack.
The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame (§4.7.3).
Where it is clear by context, we will sometimes refer to the operand stack of the current frame as simply the operand stack.

All calculation processes in the program are completed with the Operand Stack.
2.	What's contained in Operand Stacks?
The operand stack is empty when the frame that contains it is created.
The Java Virtual Machine supplies instructions to load constants or values from local variables or fields onto the operand stack.
Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack.
The operand stack is also used to prepare parameters to be passed to methods and to receive method results.

For example, the iadd instruction (§iadd) adds two int values together. It requires that the int values to be added be the top two values of the operand stack, pushed there by previous instructions.
Both of the int values are popped from the operand stack.
They are added, and their sum is pushed back onto the operand stack.
Subcomputations may be nested on the operand stack, resulting in values that can be used by the encompassing computation.

3.	What are the restriction on the Operand Stack?
Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type long or type double.
Values from the operand stack must be operated upon in ways appropriate to their types.

It is not possible, for example, to push two int values and subsequently treat them as a long or to push two float values and subsequently add them with an iadd instruction.
A small number of Java Virtual Machine instructions (the dup instructions (§dup) and swap (§swap)) operate on run-time data areas as raw values without regard to their specific types;
these instructions are defined in such a way that they cannot be used to modify or break up individual values. These restrictions on operand stack manipulation are enforced through class file verification (§4.10).

4.	What's the depth of the Operand Stack?
At any point in time, an operand stack has an associated depth, where a value of type long or double contributes two units to the depth and a value of any other type contributes one unit.

Native Method Stacks (thread private)
1.	What is Native Method Stacks?
The native method stack is a runtime data area used by the JVM to execute native methods,

Native methods are methods written in other programming languages, such as C or C++,
The NMS is separate from the Java Stack which is used to execute Java methods.
The separation is nessary to prevent native methods from interfering with Java code.

The Native Method Stack is very similar to the JVM Stack but is only dedicated to native methods.
2.	What is the workflow for calling native methods?
When a thread calls a native method, the thread switches from the Java stack to the NMS, The JVM pushes a frame onto the NMS.
The frame contains the arguments to the method, as well as the local variables and return address,

The JVM then executes the native method. (and if a native method calls back a Java method, the thread leaves the NMS and enters the Java stack again.)

When the method returns, the JVM pops the frame off the NMS.
3.	Is Native Method Stacks necessary?
Java Virtual Machine implementations that cannot load native methods and that do not themselves rely on conventional stacks need not supply native method stacks.
If supplied, native method stacks are typically allocated per thread when each thread is created.

1.	Is the size of Native Method Stacks fixed?
This specification permits native method stacks either to be of a fixed size or to dynamically expand and contract as required by the computation.
If the native method stacks are of a fixed size, the size of each native method stack may be chosen independently when that stack is created.
A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the native method stacks,
as well as, in the case of varying-size native method stacks, control over the maximum and minimum method stack sizes.
2.	Associated Exception
a.	If the computation in a thread requires a larger native method stack than is permitted, the Java Virtual Machine throws a StackOverflowError.
b.	If native method stacks can be dynamically expanded and native method stack expansion is attempted but insufficient memory can be made available,
or if insufficient memory can be made available to create the initial native method stack for a new thread, the Java Virtual Machine throws an OutOfMemoryError.
Functional Components
The ClassFile Structure
1.	A class file consists of a single ClassFile structure:
ClassFile {
    u4             			magic;
    u2             			minor_version;
    u2             			major_version;
    u2             			constant_pool_count;
    cp_info     			constant_pool[constant_pool_count-1];
    u2             			access_flags;
    u2             			this_class;
    u2             			super_class;
    u2            			interfaces_count;
    u2             			interfaces[interfaces_count];
    u2             			fields_count;
    field_info    	 	fields[fields_count];
    u2             		 	methods_count;
    method_info    	methods[methods_count];
    u2             		  	attributes_count;
    attribute_info   	attributes[attributes_count];
}
2.	A class file consists of a stream of 8-bit bytes. 16-bit and 32-bit quantities are constructed by reading in two and four consecutive 8-bit bytes, respectively.
Multibyte data items are always stored in big-endian order, where the high bytes come first.
This chapter defines the data types u1, u2, and u4 to represent an unsigned one-, two-, or four-byte quantity, respectively. (The u2 type in a Java class file consist of an unsigned 16-bit interger in big-endian byte order)
3.	The items in the ClassFile structure are as follows:
1)	magic
The magic item supplies the magic number identifying the class file format; it has the value 0xCAFEBABE.
2)	minor_version, major_version
The values of the minor_version and major_version items are the minor and major version numbers of this class file.
Together, a major and a minor version number determine the version of the class file format.
If a class file has major version number M and minor version number m, we denote the version of its class file format as M.m.
3)	constant_pool_count
The value of the constant_pool_count item is equal to the number of entries in the constant_pool table plus one.
A constant_pool index is considered valid if it is greater than zero and less than constant_pool_count,
with the exception for constants of type long and double noted in §4.4.5.
4)	constant_pool[]
The constant_pool is a table of structures (§4.4) representing various string constants, class and interface names, field names,
and other constants that are referred to within the ClassFile structure and its substructures.
The format of each constant_pool table entry is indicated by its first "tag" byte.
The constant_pool table is indexed from 1 to constant_pool_count - 1.
5)	access_flags
The value of the access_flags item is a mask of flags used to denote access permissions to and properties of this class or interface. The interpretation of each flag, when set, is specified in Table 4.1-B.
6)	this_class
The value of the this_class item must be a valid index into the constant_pool table.
The constant_pool entry at that index must be a CONSTANT_Class_info structure (§4.4.1) representing the class or interface defined by this class file.
7)	super_class
For a class, the value of the super_class item either must be zero or must be a valid index into the constant_pool table.
If the value of the super_class item is nonzero, the constant_pool entry at that index must be a CONSTANT_Class_info structure representing the direct superclass of the class defined by this class file.
Neither the direct superclass nor any of its superclasses may have the ACC_FINAL flag set in the access_flags item of its ClassFile structure.
If the value of the super_class item is zero, then this class file must represent the class Object, the only class or interface without a direct superclass.
For an interface, the value of the super_class item must always be a valid index into the constant_pool table.
The constant_pool entry at that index must be a CONSTANT_Class_info structure representing the class Object.
8)	interfaces_count
The value of the interfaces_count item gives the number of direct superinterfaces of this class or interface type.
9)	interfaces[]
Each value in the interfaces array must be a valid index into the constant_pool table.
The constant_pool entry at each value of interfaces[i], where 0 ≤ i < interfaces_count,
must be a CONSTANT_Class_info structure representing an interface that is a direct superinterface of this class or interface type,
in the left-to-right order given in the source for the type.
10)	fields_count
The value of the fields_count item gives the number of field_info structures in the fields table. The field_info structures represent all fields, both class variables and instance variables, declared by this class or interface type.
11)	fields[]
Each value in the fields table must be a field_info structure (§4.5) giving a complete description of a field in this class or interface. The fields table includes only those fields that are declared by this class or interface. It does not include items representing fields that are inherited from superclasses or superinterfaces.
12)	methods_count
The value of the methods_count item gives the number of method_info structures in the methods table.
13)	methods[]
Each value in the methods table must be a method_info structure (§4.6) giving a complete description of a method in this class or interface. If neither of the ACC_NATIVE and ACC_ABSTRACT flags are set in the access_flags item of a method_info structure, the Java Virtual Machine instructions implementing the method are also supplied.
The method_info structures represent all methods declared by this class or interface type, including instance methods, class methods, instance initialization methods (§2.9.1), and any class or interface initialization method (§2.9.2). The methods table does not include items representing methods that are inherited from superclasses or superinterfaces.
14)	attributes_count
The value of the attributes_count item gives the number of attributes in the attributes table of this class.
15)	attributes[]
Each value of the attributes table must be an attribute_info structure (§4.7).
The attributes defined by this specification as appearing in the attributes table of a ClassFile structure are listed in Table 4.7-C.
The rules concerning attributes defined to appear in the attributes table of a ClassFile structure are given in §4.7.
The rules concerning non-predefined attributes in the attributes table of a ClassFile structure are given in §4.7.1.

The Constant Pool
1.	What is Java constant pool used for?
The Java constant pool is a collection of constants that are used by JVM to run the code of a class.
It’s a runtime data structure that is part of the class file format.

Java Virtual Machine instructions do not rely on the run-time layout of classes, interfaces, class instances, or arrays. Instead, instructions refer to symbolic information in the constant_pool table.
2.	What are the characteristics of entries in Java constant pool?
All constant_pool table entries have the following general format:
cp_info {
    u1 tag;
    u1 info[];
}
Each entry in the constant_pool table must begin with a 1-byte tag indicating the kind of constant denoted by the entry.
Each tag byte must be followed by two or more bytes giving information about the specific constant. The format of the additional information depends on the tag byte,
that is, the content of the info array varies with the value of tag.
3.	What are the tag types of entries in Java constant pool?
•	In a class file whose version number is v, each entry in the constant_pool table must have a tag that was first defined in version v or earlier of the class file format (§4.1).
That is, each entry must denote a kind of constant that is approved for use in the class file.
Table 4.4-B lists each tag with the first version of the class file format in which it was defined.
Also shown is the version of the Java SE Platform which introduced that version of the class file format.
Constant pool tags (by tag)
Constant Kind	Tag	class file format	Java SE
CONSTANT_Utf8	1	45.3	1.0.2
CONSTANT_Integer	3	45.3	1.0.2
CONSTANT_Float	4	45.3	1.0.2
CONSTANT_Long	5	45.3	1.0.2
CONSTANT_Double	6	45.3	1.0.2
CONSTANT_Class	7	45.3	1.0.2
CONSTANT_String	8	45.3	1.0.2
CONSTANT_Fieldref	9	45.3	1.0.2
CONSTANT_Methodref	10	45.3	1.0.2
CONSTANT_InterfaceMethodref	11	45.3	1.0.2
CONSTANT_NameAndType	12	45.3	1.0.2
CONSTANT_MethodHandle	15	51.0	7
CONSTANT_MethodType	16	51.0	7
CONSTANT_Dynamic	17	55.0	11
CONSTANT_InvokeDynamic	18	51.0	7
CONSTANT_Module	19	53.0	9
CONSTANT_Package	20	53.0	9

•	Some entries in the constant_pool table are loadable because they represent entities that can be pushed onto the stack at run time to enable further computation.
In a class file whose version number is v, an entry in the constant_pool table is loadable if it has a tag that was first deemed to be loadable in version v or earlier of the class file format.
Table 4.4-C lists each tag with the first version of the class file format in which it was deemed to be loadable.
Also shown is the version of the Java SE Platform which introduced that version of the class file format.

In every case except CONSTANT_Class, a tag was first deemed to be loadable in the same version of the class file format that first defined the tag.
Loadable constant pool tags
Constant Kind	Tag	class file format	Java SE
CONSTANT_Integer	3	45.3	1.0.2
CONSTANT_Float	4	45.3	1.0.2
CONSTANT_Long	5	45.3	1.0.2
CONSTANT_Double	6	45.3	1.0.2
CONSTANT_Class	7	49.0	5.0
CONSTANT_String	8	45.3	1.0.2
CONSTANT_MethodHandle	15	51.0	7
CONSTANT_MethodType	16	51.0	7
CONSTANT_Dynamic	17	55.0	11
4.	What are the types of entries in Java constant pool?
•	The CONSTANT_Class_info structure is used to represent a class or an interface:
CONSTANT_Class_info {
    u1 tag;
    u2 name_index;
}
The items of the CONSTANT_Class_info structure are as follows:
tag
The tag item has the value CONSTANT_Class (7).
name_index
The value of the name_index item must be a valid index into the constant_pool table.
The constant_pool entry at that index must be a CONSTANT_Utf8_info structure (§4.4.7) representing a valid binary class or interface name encoded in internal form (§4.2.1).
Because arrays are objects, the opcodes anewarray and multianewarray - but not the opcode new - can reference array "classes" via CONSTANT_Class_info structures in the constant_pool table.
For such array classes, the name of the class is the descriptor of the array type (§4.3.2).
For example, the class name representing the two-dimensional array type int[][] is [[I, while the class name representing the type Thread[] is [Ljava/lang/Thread;.
An array type descriptor is valid only if it represents 255 or fewer dimensions.
•	The CONSTANT_String_info structure is used to represent constant objects of the type String:
CONSTANT_String_info {
    u1 tag;
    u2 string_index;
}
The items of the CONSTANT_String_info structure are as follows:
tag
The tag item has the value CONSTANT_String (8).
string_index
The value of the string_index item must be a valid index into the constant_pool table.
The constant_pool entry at that index must be a CONSTANT_Utf8_info structure (§4.4.7) representing the sequence of Unicode code points to which the String object is to be initialized.


DirectBuffer
1.	What's direct buffer in java? (google ai)
A direct buffer refers to a buffer's underlying data allocated on a memory area where OS functions can directly access it.
A non-direct buffer refers to a buffer whose underlying data is a byte array that is allocated in the Java heap area.

it reduces the amount of work to be done during I/O since a native buffer is ready as-is to be passed to the kernel, while using non-native buffers requires an additional pass.

2.	What should java direct buffer use object?
https://wiki.sei.cmu.edu/confluence/display/java/OBJ53-J.+Do+not+use+direct+buffers+for+short-lived%2C+infrequently+used+objects
This compliant solution uses an indirect buffer to allocate the short-lived, infrequently used object.
The heavily used buffer appropriately continues to use a nonheap, non-garbage-collected direct buffer.

Do not use direct buffers for short-lived, infrequently used objects
ByteBuffer rarelyUsedBuffer = ByteBuffer.allocate(8192);
// Use rarelyUsedBuffer once
ByteBuffer heavilyUsedBuffer = ByteBuffer.allocateDirect(8192);
// Use heavilyUsedBuffer many times
The Internal Form of Names
Binary Class and Interface Names
Class and interface names that appear in class file structures are always represented in a fully qualified form known as binary names (JLS §13.1).
Such names are always represented as CONSTANT_Utf8_info structures (§4.4.7) and thus may be drawn, where not further constrained,
from the entire Unicode codespace. Class and interface names are referenced from those CONSTANT_NameAndType_info structures (§4.4.6) which have such names as part of their descriptor (§4.3), and from all CONSTANT_Class_info structures (§4.4.1).

For historical reasons, the syntax of binary names that appear in class file structures differs from the syntax of binary names documented in JLS §13.1.
In this internal form, the ASCII periods (.) that normally separate the identifiers which make up the binary name are replaced by ASCII forward slashes (/).
The identifiers themselves must be unqualified names (§4.2.2).

For example, the normal binary name of class Thread is java.lang.Thread. In the internal form used in descriptors in the class file format,
a reference to the name of class Thread is implemented using a CONSTANT_Utf8_info structure representing the string java/lang/Thread.
Descriptors and Signatures
A descriptor is a string representing the type of a field or method.
Descriptors are represented in the class file format using modified UTF-8 strings (§4.4.7) and thus may be drawn, where not further constrained, from the entire Unicode codespace.
A signature is a string representing the generic type of a field or method, or generic type information for a class declaration.
Field Descriptors
A field descriptor represents the type of a class, instance, or local variable. It is a series of characters generated by the grammar:

FieldDescriptor:
    FieldType

FieldType:
    BaseType
    ObjectType
    ArrayType

BaseType:
    B
    C
    D
    F
    I
    J
    S
    Z

ObjectType:
    L ClassName ;

ArrayType:
    [ ComponentType

ComponentType:
    FieldType

The characters of BaseType, the L and ; of ObjectType, and the [ of ArrayType are all ASCII characters.
The ClassName represents a binary class or interface name encoded in internal form (§4.2.1).
The interpretation of field descriptors as types is as shown in Table 4.2.
A field descriptor representing an array type is valid only if it represents a type with 255 or fewer dimensions.
Table 4.2. Interpretation of FieldType characters
BaseType Character	Type	Interpretation
B	byte	signed byte
C	char	Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16
D	double	double-precision floating-point value
F	float	single-precision floating-point value
I	int	integer
J	long	long integer
L ClassName ;	reference	an instance of class ClassName
S	short	signed short
Z	boolean	true or false
[	reference	one array dimension

The field descriptor of an instance variable of type int is simply I.
The field descriptor of an instance variable of type Object is Ljava/lang/Object;. Note that the internal form of the binary name for class Object is used.
The field descriptor of an instance variable that is a multidimensional double array, double d[][][], is [[[D.

Method Descriptors
A method descriptor represents the parameters that the method takes and the value that it returns:
MethodDescriptor:
    ( ParameterDescriptor* ) ReturnDescriptor
A parameter descriptor represents a parameter passed to a method:
ParameterDescriptor:
    FieldType

A return descriptor represents the type of the value returned from a method. It is a series of characters generated by the grammar:
ReturnDescriptor:
    FieldType
    VoidDescriptor

VoidDescriptor:
    V
The character V indicates that the method returns no value (its return type is void).

A method descriptor is valid only if it represents method parameters with a total length of 255 or less,
where that length includes the contribution for this in the case of instance or interface method invocations.
The total length is calculated by summing the contributions of the individual parameters,
where a parameter of type long or double contributes two units to the length and a parameter of any other type contributes one unit.

The method descriptor for the method:
Object m(int i, double d, Thread t) {..}
is (IDLjava/lang/Thread;)Ljava/lang/Object;. Note that the internal forms of the binary names of Thread and Object are used.

The method descriptor for m is the same whether m is a class method or an instance method.
Although an instance method is passed this, a reference to the current class instance, in addition to its intended parameters,
that fact is not reflected in the method descriptor.
The reference to this is passed implicitly by the method invocation instructions of the Java Virtual Machine that invoke instance methods (§2.6.1).
A reference to this is not passed to a class method.

Garbage Collection
Concept
1.	What is Garbage Collection in Java?
Garbage Collection is the process of reclaiming the runtime unused memory by destroying the unused objects.
Java Garbage Collection is the process by which Java programs perform automatic memory management.

You can say that at any point in time, the heap memory consists of two types of objects:
•	Live   - these objects are being used and referenced from somewhere else
•	Dead - these objects are no longer used or referenced from anywhere
The garbage collector finds these unused objects and deletes them to free up memory.

2.	How to dereference an object in Java?
The main objective of Garbage Collection is to free heap memory by destroying the objects that don’t contain a reference.
When there are no references to an object, it is assumed to be dead and no longer needed. So the memory occupied by the object can be reclaimed.

There are various ways in which the references to an object can be released to make it a candidate for Garbage Collection. Some of them are:
•	By making a reference null
Student student = new Student();
student = null;
•	By assigning a reference to another
Student studentOne = new Student();
Student studentTwo = new Student();
studentOne = studentTwo; // now the first object referred by studentOne is available for garbage collection

•	By using an anonymous object
register(new Student());

3.	How does Garbage Collection work in Java?
Java garbage collection is an automatic process. The programmer does not need to explicitly mark objects to be deleted.

The garbage collection implementation lives in the JVM. Each JVM can implement its own version of garbage collection.
However, it should meet the standard JVM specification of working with the objects present in the heap memory,
marking or identifying the unreachable objects, and destroying them with compaction.

Garbage Collection Roots
Garbage collectors work on the concept of Garbage Collection Roots (GC Roots) to identify live and dead objects.
Examples of such Garbage Collection roots are:
•	Classes loaded by system class loader (not custom class loaders)
•	Live threads
•	Local variables and parameters of the currently executing methods
•	Local variables and parameters of JNI methods
•	Global JNI reference
•	Objects used as a monitor for synchronization
•	Objects held from garbage collection by JVM for its purposes
The garbage collector traverses the whole object graph in memory, starting from those Garbage Collection Roots and following references from the roots to other objects.
How to Identify Garbage
1.	Reference Counting
Reference Counting is a simple but slow scheme.
In this scheme, each object contains a reference counter.
Every time a reference is attached to that object, its reference counter is increased. Every time a reference goes out or is set to null, its counter is decreased.
Once the reference counter of an object becomes zero, that storage will be released.

But one shortcoming is that if objects circularly refer to each other they can have nonzero reference counts. Below is an example:
public class ReferenceCountingGC {
    public Object instance;
    public static void main(String...strings) {
        ReferenceCountingGC a = new ReferenceCountingGC(); // 1st instance
        ReferenceCountingGC b = new ReferenceCountingGC(); // 2nd instance
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
    }
}
It creates two instances. The first instance has two references, one is from a and the other is from b.instance.
The second instance also has two references. After two variables are set to null, the two instances still have one reference from their members.
In this case, their reference counter will never be zero.

Another drawback is that reference counting scheme requires extra space for each object to store its reference counter and extra process resource to deal with counter.
2.	Reachability Analysis
The basic idea of Reachability Analysis is to trace which objects are reachable by a chain of references from “root” objects.
The “root” is called GC Roots and the path from root to the certain object is called reference chain.
If one object cannot be reachable from any GC Roots, it will be considered as garbage and the storage will be released.

As shown in the image below, the objects in blue rectangle should be kept alive and the objects in gray rectable can be recycled:


1)	Unavailable and unreachable:  	Recycling objects
2)	Unavailable and reachable： 		There may be a memory leak in this situation
(the reference was cleared during object definition, but the object still has a reference elsewhere)
3)	available and reachable：   		normal use

Finalization and Termination Condition
1.	finalizer
The finalize method provided by the root Object class.Simply put, this is called before the garbage collection for a particular object.

The main purpose of a finalizer is to release resources used by objects before they’re removed from the memory.
If the finalize() method were completely empty, the JVM would treat the object as if it didn’t have a finalizer.
2.	Termination
In reality, the time at which the garbage collector calls finalizers is dependent on the JVM’s implementation and the system’s conditions, which are out of our control.

To make garbage collection happen on the spot, we’ll take advantage of the System.gc method. In real-world systems, we should never invoke that explicitly, for a number of reasons:
It’s costly
It doesn’t trigger the garbage collection immediately – it’s just a hint for the JVM to start GC
JVM knows better when GC needs to be called
If we need to force GC, we can use jconsole for that.
3.	drawbacks
Despite the benefits they bring in, finalizers come with many drawbacks.

Let’s have a look at several problems we’ll be facing when using finalizers to perform critical actions.
1)	The first noticeable issue is the lack of promptness.
We cannot know when a finalizer runs since garbage collection may occur anytime.
By itself, this isn’t a problem because the finalizer still executes, sooner or later.
However, system resources aren’t unlimited. Thus, we may run out of resources before a clean-up happens, which may result in a system crash.
2)	Finalizers also have an impact on the program’s portability.
Since the garbage collection algorithm is JVM implementation-dependent, a program may run very well on one system while behaving differently on another.
The performance cost is another significant issue that comes with finalizers.
Specifically, JVM must perform many more operations when constructing and destroying objects containing a non-empty finalizer.

3)	The last problem we’ll be talking about is the lack of exception handling during finalization.
If a finalizer throws an exception, the finalization process stops, leaving the object in a corrupted state without any notification.
4)	finalizers are very expensive.
When creating an object, also called a referent, that has a finalizer,  the JVM creates an accompanying reference object of type java.lang.ref.Finalizer.

•	After the referent is ready for garbage collection, the JVM marks the reference object Finalizer as ready for processing and puts it into a reference queue.
We can access this queue via the static field queue in the java.lang.ref.Finalizer class.
•	Meanwhile, a special daemon thread called Finalizer keeps running and looks for objects in the reference queue.
When it finds one, it removes the reference object Finalizer from the queue and calls the finalizer on the referent.
•	Perform Reachability Analysis
During the next garbage collection cycle, the referent will be discarded – when it’s no longer referenced from a reference object Finalizer.

If a thread keeps producing objects at a high speed, which is what happened in our example, the Finalizer thread cannot keep up.
Eventually, the memory won’t be able to store all the objects, and we end up with an OutOfMemoryError.

Example:
public class CrashedFinalizable {
    public static void main(String[] args) throws ReflectiveOperationException {
        for (int i = 0; ; i++) {
            new CrashedFinalizable();
if ((i % 1_000_000) == 0) {
    Class<?> finalizerClass = Class.forName("java.lang.ref.Finalizer");
    Field queueStaticField = finalizerClass.getDeclaredField("queue");
    queueStaticField.setAccessible(true);
    ReferenceQueue<Object> referenceQueue = (ReferenceQueue) queueStaticField.get(null);

    Field queueLengthField = ReferenceQueue.class.getDeclaredField("queueLength");
    queueLengthField.setAccessible(true);
    long queueLength = (long) queueLengthField.get(referenceQueue);
    System.out.format("There are %d references in the queue%n", queueLength);
}
        }
    }

    @Override
    protected void finalize() {
        System.out.print("");
    }
}
Results:
...
There are 21914844 references in the queue
There are 22858923 references in the queue
There are 24202629 references in the queue
There are 24621725 references in the queue
There are 25410983 references in the queue
There are 26231621 references in the queue
There are 26975913 references in the queue
Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded
    at java.lang.ref.Finalizer.register(Finalizer.java:91)
    at java.lang.Object.<init>(Object.java:37)
    at com.baeldung.finalize.CrashedFinalizable.<init>(CrashedFinalizable.java:6)
    at com.baeldung.finalize.CrashedFinalizable.main(CrashedFinalizable.java:9)

Process finished with exit code 1



Choosing a garbage collector
1.	Performance factors
1)	Throughput
The percentage of total time spent in useful application activity versus memory allocation and garbage collection.
For example, if your throughput is 95%, that means the application code is running 95% of the time and garbage collection is running 5% of the time.
You want higher throughput for any high-load business application.
2)	Latency
Application responsiveness, which is affected by garbage collection pauses.
In any application interacting with a human or some active process (such as a valve in a factory), you want the lowest possible latency.
3)	Footprint
The working set of a process, measured in pages and cache lines.
2.	Choose a garbage collector



Generational Garbage Collection
1.	What's Generational Garbage Collection.

Java Garbage Collectors implement a generational garbage collection strategy that categorizes objects by age.

Having to mark and compact all the objects in a JVM is inefficient.
As more and more objects are allocated, the list of objects grows, leading to longer garbage collection times.

Empirical analysis of applications has shown that most objects in Java are short lived.


In the above example, the Y axis shows the number of bytes allocated and the X axis shows the number of bytes allocated over time.
As you can see, fewer and fewer objects remain allocated over time.
In fact most objects have a very short life as shown by the higher values on the left side of the graph.
This is why Java categorizes objects into generations and performs garbage collection accordingly.
2.	How is generational garbage collection implemented?
The heap memory area in the JVM is divided into three sections:

1)	Young Generation
Newly created objects start in the Young Generation. The Young Generation is further subdivided into:
•	Eden space 														   all new objects start here, and initial memory is allocated to them
•	Survivor Spaces (FromSpace and ToSpace) 		objects are moved here from Eden after surviving one garbage collection cycle.
When objects are garbage collected from the Young Generation, it is a minor garbage collection event.
When Eden space is filled with objects, a Minor GC is performed. All the dead objects are deleted, and all the live objects are moved to one of the Survivor Spaces.
Minor GC also checks the objects in a Survivor Space, and moves them to the other Survivor Space.
Take the following sequence as an example:
•	Eden has all objects (live and dead)
•	Minor GC occurs - all dead objects are removed from Eden. All live objects are moved to S1 (FromSpace). Eden and S2 are now empty.
•	New objects are created and added to Eden. Some objects in Eden and S1 become dead.
•	Minor GC occurs - all dead objects are removed from Eden and S1. All live objects are moved to S2 (ToSpace). Eden and S1 are now empty.
So, at any time, one of the survivor spaces is always empty.
When the surviving objects reach a certain threshold of moving around the survivor spaces, they are moved to the Old Generation.
You can use the -Xmn flag to set the size of the Young Generation.
2)	Old Generation
Objects that are long-lived are eventually moved from the Young Generation to the Old Generation.
This is also known as Tenured Generation, and contains objects that have remained in the Survivor Spaces for a long time.
There is a threshold defined for the tenure of an object which decides how many garbage collection cycles it can survive before it is moved to the Old Generation.
When objects are garbage collected from the Old Generation, it is a major garbage collection event.

Since Java uses generational garbage collection, the more garbage collection events an object survives, the further it gets promoted in the heap.
It starts in the young generation and eventually ends up in the tenured generation if it survives long enough.

You can use the -Xms and -Xmx flags to set the size of the initial and maximum size of the Heap memory.
3)	Permanent Generation
Metadata such as classes and methods are stored in the Permanent Generation.
It is populated by the JVM at runtime based on classes in use by the application.
Classes that are no longer in use may be garbage collected from the Permanent Generation.

You can use the -XX:PermGen and -XX:MaxPermGen flags to set the initial and maximum size of the Permanent Generation.
4)	MetaSpace
Starting with Java 8, the MetaSpace memory space replaces the PermGen space.
The implementation differs from the PermGen and this space of the heap is now automatically resized.

This avoids the problem of applications running out of memory due to the limited size of the PermGen space of the heap.
The Metaspace memory can be garbage collected and the classes that are no longer used can be automatically cleaned when the Metaspace reaches its maximum size.

Mark and Sweep
1.	What's mark and sweep algorithm?
It is initial and very basic algorithm which runs in two stages:
Marking live objects 					 	 find out all objects that are still alive.
Removing unreachable objects 		 get rid of everything else – the supposedly dead and unused objects.

To start with, GC defines some specific objects as Garbage Collection Roots.
Now GC traverses the whole object graph in your memory, starting from those roots and following references from the roots to other objects.
Every object the GC visits is marked as alive.

The application threads need to be stopped for the marking to happen as it cannot really traverse the graph if it keeps changing.
It is called Stop The World pause.
2.	Second stage
Second stage is for getting rid of unused objects to freeup memory. This can be done in variety of ways e.g.
1)	Normal deletion
Normal deletion removes unreferenced objects to free space and leave referenced objects and pointers.
The memory allocator (kind of hashtable) holds references to blocks of free space where new object can be allocated.
It is often referred as mark-sweep algorithm.

2)	Deletion with compacting
Only removing unused objects is not efficient because blocks of free memory is scattered across storage area and cause OutOfMemoryError,
if created object big enough and does not find large enough memory block.

To solve this issue, after deleting unreferenced objects, compacting is done on the remaining referenced objects.
Here compacting refers the process of moving referenced object together. This makes new memory allocation much easier and faster.

It is often referred as mark-sweep-compact algorithm.


3)	Deletion with copying
It is very similar to mark and compacing approach as they relocate all live objects as well.
The important difference is that the target of relocation is a different memory region.
It is often reffred as mark-copy algorithm.



Garbage Collector
Reference:
Java Garbage Collection Algorithms [till Java 9]
	https://howtodoinjava.com/java/garbage-collection/all-garbage-collection-algorithms/
Garbage Collection in Java – What is GC and How it Works in the JVM
https://www.freecodecamp.org/news/garbage-collection-in-java-what-is-gc-and-how-it-works-in-the-jvm

Serial GC
1.	What's the Serial GC
This is the simplest implementation of GC and is designed for small applications running on single-threaded environments.


2.	What garbage collection algorithm is used for Serial GC?
the serial garbage collector uses generational garbage collection algorithm.
This algorithm uses mark-copy algorithm for the Young Generation and mark-sweep-compact algorithm for the Old Generation.

It works on a single thread. When executing, it freezes all other threads until garbage collection operations have concluded.
3.	Serial GC Performance
When it runs, it leads to a "stop the world" event where the entire application is paused.
4.	Jvm options
-XX:+UseSerialGC		Use Serial Garbage Collector

Parallel GC (JDK8 and prior)
1.	What's the Serial GC
Parallel Garbage Collector is suitable on multi-core machines in cases where your primary goal is to increase throughput by efficient usage of existing system resources.
Using this approach, GC cycle times can be considerably reduced.

Till Java 8, we have seen Parallel GC as default garbage collector. Java 9 onwards, G1 is the default garbage collector on 32- and 64-bit server configurations. – JEP [248]

Multiple threads are used for minor garbage collection in the Young Generation.
A single thread is used for major garbage collection in the Old Generation.

2.	What garbage collection algorithm is used for Parallel GC?
The Parallel GC is a parallel version of the Serial GC , which uses the same generational garbage collection algorithm as Serial GC.
This algorithm uses mark-copy algorithm for the Young Generation and mark-sweep-compact algorithm for the Old Generation.

It works on a single thread. When executing, it freezes all other threads until garbage collection operations have concluded.

3.	Parallel GC Performance
Running the Parallel GC also leads to a "stop the world event" and the application freezes.
Since it is more suitable in a multi-threaded environment, it can be used when a lot of work needs to be done and long pauses are acceptable, for example running a batch job.
4.	Jvm options
-XX:+UseParallelGC     	 		 Use Parallel Garbage Collector
-XX:+UseParallelOldGC		 Use Parallel Old Garbage Collector，It is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation.
CMS (Concurrent Mark Sweep) GC
1.	What's the CMS GC?
The CMS GC is a garbage collector in the Oracle HotSpot Java virtual machine available since version 1.4.1.
It was deprecated on version 9 and removed on version 14, so from Java 15 it is no longer available.  (wiki)

This is also known as the concurrent low pause collector. Multiple threads are used for minor garbage collection using the same algorithm as Parallel.
Major garbage collection is multi-threaded, like Parallel Old GC, but CMS runs concurrently alongside application processes to minimize “stop the world” events.
Because of this, the CMS collector uses more CPU than other GCs.

If you can allocate more CPU for better performance, then the CMS garbage collector is a better choice than the parallel collector. No compaction is performed in CMS GC.


2.	What garbage collection algorithm is used for CMS GC?
The CMS GC attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads.
It uses the parallel stop-the-world mark-copy algorithm in the Young Generation and the mostly concurrent mark-sweep algorithm in the Old Generation.
3.	Jvm options
-XX:+UseConcMarkSweepGC 								use CMS GC
-XX:+UseCMSInitiating\OccupancyOnly				Indicates that you want to solely use occupancy as a criterion for starting a CMS collection operation.
-XX:CMSInitiating\OccupancyFraction=70			Sets the percentage CMS generation occupancy to start a CMS collection cycle.
-XX:CMSTriggerRatio=70										This is the percentage of MinHeapFreeRatio in CMS generation that is allocated prior to a CMS cycle starts.
-XX:CMSTriggerPermRatio=90								Sets the percentage of MinHeapFreeRatio in the CMS permanent generation that is allocated before starting a CMS collection cycle.
-XX:CMSWaitDuration=2000								Use the parameter to specify how long the CMS is allowed to wait for young collection.
-XX:+UseParNewGC												Elects to use the parallel algorithm for young space collection.
-XX:+CMSConcurrentMTEnabled						Enables the use of multiple threads for concurrent phases.
-XX:ConcGCThreads=2										Sets the number of parallel threads used for the concurrent phases.
-XX:ParallelGCThreads=2										Sets the number of parallel threads you want used for stop-the-world phases.
-XX:+CMSIncrementalMode								Enable the incremental CMS (iCMS) mode.
-XX:+CMSClassUnloadingEnabled						If this is not enabled, CMS will not clean permanent space.
-XX:+ExplicitGCInvokes\Concurrent					This allows System.gc() to trigger concurrent collection instead of a full garbage collection cycle.
Garbage First GC (JDK9+)
1.	What's the CMS GC?
The G1 garbage collector was available in Java 7 and is designed to be the long term replacement for the CMS collector.
Till Java 8, we have seen Parallel GC as default garbage collector. Java 9 onwards, G1 is the default garbage collector on 32- and 64-bit server configurations. – JEP [248]  (google)
The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector.


This approach involves segmenting the memory heap into multiple small regions (typically 2048).
Each region is marked as either young generation (further devided into eden regions or survivor regions) or old generation.
This allows the GC to avoid collecting the entire heap at once, and instead approach the problem incrementally. It means that only a subset of the regions is considered at a time.

2.	What algorithm is used for G1 GC?
G1GC (Garbage First) was intended as a replacement for CMS and was designed for multi-threaded applications that have a large heap size available (more than 4GB).
It is parallel and concurrent like CMS, but it works quite differently under the hood compared to the older garbage collectors.

Although G1 is also generational, it does not have separate regions for young and old generations.
Instead, each generation is a set of regions, which allows resizing of the young generation in a flexible way.
It partitions the heap into a set of equal size regions  (1MB to 32MB – depending on the size of the heap) and uses multiple threads to scan them.
A region might be either an old region or a young region at any time during the program run.

After the mark phase is completed, G1 knows which regions contain the most garbage objects.
If the user is interested in minimal pause times, G1 can choose to evacuate only a few regions.
If the user is not worried about pause times or has stated a fairly large pause-time goal, G1 might choose to include more regions.

Since G1GC identifies the regions with the most garbage and performs garbage collection on that region first, it is called Garbage First.

Apart from the Eden, Survivor, and Old memory regions, there are two more types of regions present in the G1GC:
•	Humongous		used for large size objects (larger than 50% of heap size)
•	Available 			the unused or non-allocated space

3.	Jvm options
-XX:+UseG1GC								Use the G1 Garbage Collector
-XX:G1HeapRegionSize=16m			Size of the heap region. The value will be a power of two and can range from 1MB to 32MB.
The goal is to have around 2048 regions based on the minimum Java heap size.
-XX:MaxGCPauseMillis=200				Sets a target value for desired maximum pause time. The default value is 200 milliseconds. The specified value does not adapt to your heap size.
-XX:G1ReservePercent=5					This determines the minimum reserve in the heap.
-XX:G1ConfidencePercent=75			This is the confidence coefficient pause prediction heuristics.
-XX:GCPauseIntervalMillis=200		This is the pause interval time slice per MMU in milliseconds.

Epsilon Garbage Collector
1.	What's the Epsilon Garbage Collector?
Epsilon is a do-nothing (no-op) garbage collector that was released as part of JDK 11.
It handles memory allocation but does not implement any actual memory reclamation mechanism. Once the available Java heap is exhausted, the JVM shuts down.

It can be used for ultra-latency-sensitive applications, where developers know the application memory footprint exactly, or even have (almost) completely garbage-free applications.
Usage of the Epsilon GC in any other scenario is otherwise discouraged.
2.	Jvm options
-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC		Use the Epsilon Garbage Collector
Shenandoah
1.	What's the Shenandoah Garbage Collector?
Shenandoah is a new GC that was released as part of JDK 12.
Shenandoah’s key advantage over G1 is that it does more of its garbage collection cycle work concurrently with the application threads.

G1 can evacuate its heap regions only when the application is paused, while Shenandoah can relocate objects concurrently with the application.
Shenandoah can compact live objects, clean garbage, and release RAM back to the OS almost immediately after detecting free memory.
Since all of this happens concurrently while the application is running, Shenandoah is more CPU intensive.
3.	Jvm options
-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC   Use the Shenandoah Garbage Collector
ZGC (since JDK15)
1.	What's the ZGC Garbage  Collector?
ZGC is another GC that was released as part of JDK 11 and has been improved in JDK 12.
It is intended for applications which require low latency (less than 10 ms pauses) and/or use a very large heap (multi-terabytes).
The primary goals of ZGC are low latency, scalability, and ease of use.
To achieve this, ZGC allows a Java application to continue running while it performs all garbage collection operations.
By default, ZGC uncommits unused memory and returns it to the operating system.
Thus, ZGC brings a significant improvement over other traditional GCs by providing extremely low pause times (typically within 2ms).

Note: Both Shenandoah and ZGC are planned to be made production features and moved out of the experimental stage in JDK 15.

3.	Jvm options
-XX:+UnlockExperimentalVMOptions -XX:+UseZGC		Use the Epsilon Garbage Collector

Java IO/NIO
Reference:
https://www.linkedin.com/pulse/java-sockets-io-blocking-non-blocking-asynchronous-aliaksandr-liakh

The POSIX definitions (Portable Operating System Interface)
1.	How many systems implement the POSIX?
Unix, Linux, Mac OS X, BSD, Solaris, AIX, etc.
2.	What is sockets?
Sockets are endpoints to perform two-way communication by TCP and UDP protocols.
Java sockets APIs are adapters for the corresponding functionality of the operating systems.
Sockets communication in POSIX-compliant operating systems (Unix, Linux, Mac OS X, BSD, Solaris, AIX, etc.) is performed by Berkeley sockets.
Sockets communication in Windows is performed by Winsock that is also based on Berkeley sockets with additional functionality to comply with the Windows programming model.
3.	What is file descriptor in IO operations?
A file descriptor is a unique identifier or referelnce that the operating system assigns to a file when it is opened.
It allows programs to interact with files, sockets, or other input/output (l/O) resources.
The file descriptor is used by the operating system to keep track of the file and perform operations on it.
Common IO models for the POSIX-compliant operating systems?
1.	blocking I/O model
In the blocking I/O model, the application makes a blocking system call until data is received at the kernel and is copied from kernel space into user space (user thread).
Pros:
•	The simplest I/O model to implement
Cons:
•	The application is blocked

2.	non-blocking I/O model
In the non-blocking I/O model the application makes a system call that immediately returns one of two responses:
•	if the I/O operation can be completed immediately, the data are returned
•	if the I/O operation can’t be completed immediately, an error code is returned indicating that the I/O operation would block or the device is temporarily unavailable
To complete the I/O operation, the application should busy-wait (make repeating system calls) until completion.

Pros:
•	The application isn’t blocked
Cons:
•	The application should busy-wait until completion, that would cause many user-kernel context switches.
•	This model can introduce I/O latency because there can be a gap between the data availability in the kernel and the data reading by the application.


3.	I/O multiplexing model
In the I/O multiplexing model (also known as the non-blocking I/O model with blocking notifications),
the application makes a blocking select system call to start to monitor activity on many descriptors.
For each descriptor, it’s possible to request notification of its readiness for certain I/O operations (connection, reading or writing, error occurrence, etc.).
When the select system call returns that at least one descriptor is ready, the application makes a non-blocking call and copies the data from kernel space into user space.

Pros:
•	It’s possible to perform I/O operations on multiple descriptors in one thread
Cons:
•	The application is still blocked on the select system call
•	Not all operating systems support this model efficiently


4.	signal-driven I/O model
In the signal-driven I/O model the application makes a non-blocking call and registers a signal handler.
When a descriptor is ready for an I/O operation, a signal is generated for the application.
Then the signal handler copies the data from kernel space into user space.

Pros:
•	The application isn’t blocked
•	Signals can provide good performance
Cons:
•	Not all operating systems support signals



5.	asynchronous I/O model
In the asynchronous I/O model (also known as the overlapped I/O model) the application makes the non-blocking call and starts a background operation in the kernel.
When the operation is completed (data are received at the kernel and are copied from kernel space into user space), a completion callback is generated to finish the I/O operation.

A difference between the asynchronous I/O model and the signal-driven I/O model is that with signal-driven I/O, the kernel tells the application when an I/O operation can be initiated,
but with the asynchronous I/O model, the kernel tells the application when an I/O operation is completed.



Pros:
•	The application isn’t blocked
•	This model can provide the best performance
Cons:
•	The most complicated I/O model to implement
•	Not all operating systems support this model efficiently
Java IO API
1.	What is Java IO API?
Java IO API is based on streams (InputStream, OutputStream) that represent blocking, one-directional data flow.
Java NIO API
1.	What is Java NIO API? (google)
Java NIO stands for New Input/Output. It is a Java API that provides features for intensive l/O operations.
NIO was introduced in Java 1.4, and it is designed to provide access to the low-level l/O operations of modern operating systems.

Java NIO consists of several subpackages, each addressing specific functionalities:
java.nio					Provides core classes like Buffer and related utility classes.
java.nio.channels		Contains classes for working with various channels (file channels, network sockets etc.)
java.nio.charset		Deals with character set encoding and decoding.
2.	What is java NIO API based on?
Java NIO API is based on the Channel, Buffer, Selector classes, that are adapters to low-level I/O operations of operating systems.
•	Channel
The Channel class represents a connection to an entity (hardware device, file, socket, software component, etc) that is capable of performing I/O operations (reading or writing).
In comparison with uni-directional streams, channels are bi-directional.
•	Buffer
The Buffer class is a fixed-size data container with additional methods to read and write data.
All Channel data are handled through Buffer but never directly:
all data that are sent to a Channel are written into a Buffer,
all data that are received from a Channel are read into a Buffer.
In comparison with streams, that are byte-oriented, channels are block-oriented. Byte-oriented I/O is simpler but for some I/O entities can be rather slow.
Block-oriented I/O can be much faster but is more complicated.
•	Selector
The Selector class allows subscribing to events from many registered SelectableChannel objects in a single call.
When events arrive, a Selector object dispatches them to the corresponding event handlers.
Java NIO2 API
1.	What is Java NIO2 API? (google)
Java NIO2 is a new API introduced in Java 7 for file and directory operations. It provides a number of improvements over the older Java l/O API.
2.	What is Java NIO2 API based on?
Java NIO2 API is based on asynchronous channels (AsynchronousServerSocketChannel, AsynchronousSocketChannel, etc) that support asynchronous I/O operations
(connecting, reading or writing, errors handling).

The asynchronous channels provide two mechanisms to control asynchronous I/O operations.
•	The first mechanism is by returning a java.util.concurrent.Future object, which models a pending operation and can be used to query the state and obtain the result.
•	The second mechanism is by passing to the operation a java.nio.channels.CompletionHandler object,
which defines handler methods that are executed after the operation has completed or failed. The provided API for both mechanisms are equivalent.

Asynchronous channels provide a standard way of performing asynchronous operations platform-independently.
However, the amount that Java sockets API can exploit native asynchronous capabilities of an operating system, will depend on the support for that platform.
Socket echo server
1.	Blocking IO echo server
In the following example, the blocking I/O model is implemented in an echo server with Java IO API.

The ServerSocket.accept method blocks until a connection is accepted.
The InputStream.read method blocks until input data are available, or a client is disconnected.
The OutputStream.write method blocks until all output data are written.

public class IoEchoServer {

   public static void main(String[] args) throws IOException {
       ServerSocket serverSocket = new ServerSocket(7000);

       while (active) {
           Socket socket = serverSocket.accept(); // blocking

           InputStream is = socket.getInputStream();
           OutputStream os = socket.getOutputStream();

           int read;
           byte[] bytes = new byte[1024];
           while ((read = is.read(bytes)) != -1) { // blocking
               os.write(bytes, 0, read); // blocking
           }

           socket.close();
       }

       serverSocket.close();
   }
}
2.	Blocking NIO echo server
In the following example, the blocking I/O model is implemented in an echo server with Java NIO API.

The ServerSocketChannel and SocketChannel objects are configured in the blocking mode by default.
The ServerSocketChannel.accept method blocks and returns a SocketChannel object when a connection is accepted.
The ServerSocket.read method blocks until input data are available, or a client is disconnected.
The ServerSocket.write method blocks until all output data are written.

public class NioBlockingEchoServer {

   public static void main(String[] args) throws IOException {
       ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
       serverSocketChannel.bind(new InetSocketAddress("localhost", 7000));

       while (active) {
           SocketChannel socketChannel = serverSocketChannel.accept(); // blocking

           ByteBuffer buffer = ByteBuffer.allocate(1024);
           while (true) {
               buffer.clear();
               int read = socketChannel.read(buffer); // blocking
               if (read < 0) {
                   break;
               }

               buffer.flip();
               socketChannel.write(buffer); // blocking
           }

           socketChannel.close();
       }

       serverSocketChannel.close();
   }
}
3.	Non-blocking NIO echo server
In the following example, the non-blocking I/O model is implemented in an echo server with Java NIO API.

The ServerSocketChannel and SocketChannel objects are explicitly configured in the non-blocking mode.
The ServerSocketChannel.accept method doesn't block and returns null if no connection is accepted yet or a SocketChannel object otherwise.
The ServerSocket.read doesn't block and returns 0 if no data are available or a positive number of bytes read otherwise.
The ServerSocket.write method doesn't block if there is free space in the socket's output buffer.

public class NioNonBlockingEchoServer {

   public static void main(String[] args) throws IOException {
       ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
       serverSocketChannel.configureBlocking(false);
       serverSocketChannel.bind(new InetSocketAddress(7000));

       while (active) {
           SocketChannel socketChannel = serverSocketChannel.accept(); // non-blocking
           if (socketChannel != null) {
               socketChannel.configureBlocking(false);

               ByteBuffer buffer = ByteBuffer.allocate(1024);
               while (true) {
                   buffer.clear();
                   int read = socketChannel.read(buffer); // non-blocking
                   if (read < 0) {
                       break;
                   }

                   buffer.flip();
                   socketChannel.write(buffer); // can be non-blocking
               }

               socketChannel.close();
           }
       }

       serverSocketChannel.close();
   }
}
4.	Multiplexing NIO echo server
In the following example, the multiplexing I/O model is implemented in an echo server Java NIO API.

During the initialization, multiple ServerSocketChannel objects, that are configured in the non-blocking mode,
are registered on the same Selector object with the SelectionKey.OP_ACCEPT argument to specify that an event of connection acceptance is interesting.

In the main loop, the Selector.select method blocks until at least one of the registered events occurs.
Then the Selector.selectedKeys method returns a set of the SelectionKey objects for which events have occurred.
Iterating through the SelectionKey objects, it’s possible to determine what I/O event (connect, accept, read, write) has happened
and which sockets objects (ServerSocketChannel, SocketChannel) have been associated with that event.

Indication of a selection key that a channel is ready for some operation is a hint, not a guarantee.

public class NioMultiplexingEchoServer {

   public static void main(String[] args) throws IOException {
       final int ports = 8;
       ServerSocketChannel[] serverSocketChannels = new ServerSocketChannel[ports];

       Selector selector = Selector.open();

       for (int p = 0; p < ports; p++) {
           ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
           serverSocketChannels[p] = serverSocketChannel;
           serverSocketChannel.configureBlocking(false);
           serverSocketChannel.bind(new InetSocketAddress("localhost", 7000 + p));

           serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
       }

       while (active) {
           selector.select(); // blocking

           Iterator<SelectionKey> keysIterator = selector.selectedKeys().iterator();
           while (keysIterator.hasNext()) {
               SelectionKey key = keysIterator.next();

               if (key.isAcceptable()) {
                   accept(selector, key);
               }

               if (key.isReadable()) {
                   keysIterator.remove();
                   read(selector, key);
               }
               if (key.isWritable()) {
                   keysIterator.remove();
                   write(key);
               }
           }
       }

       for (ServerSocketChannel serverSocketChannel : serverSocketChannels) {
           serverSocketChannel.close();
       }
   }
}

When a SelectionKey object indicates that a connection acceptance event has happened,
it’s made the ServerSocketChannel.accept call (which can be a non-blocking) to accept the connection.
After that, a new SocketChannel object is configured in the non-blocking mode and is registered on the same Selector object with the SelectionKey.OP_READ argument
to specify that now an event of reading is interesting.

   private static void accept(Selector selector, SelectionKey key) throws IOException {
       ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
       SocketChannel socketChannel = serverSocketChannel.accept(); // can be non-blocking
       if (socketChannel != null) {
           socketChannel.configureBlocking(false);
           socketChannel.register(selector, SelectionKey.OP_READ);
       }
   }

When a SelectionKey object indicates that a reading event has happened,
it’s made a the SocketChannel.read call (which can be a non-blocking) to read data from the SocketChannel object into a new ByteByffer object.
After that, the SocketChannel object is registered on the same Selector object with the SelectionKey.OP_WRITE argument to specify that now an event of write is interesting.
Additionally, this ByteBuffer object is used during the registration as an attachment.

   private static void read(Selector selector, SelectionKey key) throws IOException {
       SocketChannel socketChannel = (SocketChannel) key.channel();

       ByteBuffer buffer = ByteBuffer.allocate(1024);
       socketChannel.read(buffer); // can be non-blocking

       buffer.flip();
       socketChannel.register(selector, SelectionKey.OP_WRITE, buffer);
   }

When a SelectionKeys object indicates that a writing event has happened,
it’s made the SocketChannel.write call (which can be a non-blocking) to write data to the SocketChannel object from the ByteByffer object,
extracted from the SelectionKey.attachment method.
After that, the SocketChannel.cloase call closes the connection.

   private static void write(SelectionKey key) throws IOException {
       SocketChannel socketChannel = (SocketChannel) key.channel();

       ByteBuffer buffer = (ByteBuffer) key.attachment();

       socketChannel.write(buffer); // can be non-blocking
       socketChannel.close();
   }

After every reading or writing the SelectionKey object is removed from the set of the SelectionKey objects to prevent its reuse.
But the SelectionKey object for connection acceptance is not removed to have the ability to make the next similar operation.
5.	Asynchronous NIO2 echo server
In the following example, the asynchronous I/O model is implemented in an echo server with Java NIO2 API.
The AsynchronousServerSocketChannel, AsynchronousSocketChannel classes here are used with the completion handlers mechanism.

The AsynchronousServerSocketChannel.accept method initiates an asynchronous connection acceptance operation.

public class Nio2CompletionHandlerEchoServer {

   public static void main(String[] args) throws IOException {
       AsynchronousServerSocketChannel serverSocketChannel = AsynchronousServerSocketChannel.open();
       serverSocketChannel.bind(new InetSocketAddress(7000));

       AcceptCompletionHandler acceptCompletionHandler = new AcceptCompletionHandler(serverSocketChannel);
       serverSocketChannel.accept(null, acceptCompletionHandler);

       System.in.read();
   }
}

When a connection is accepted (or the operation fails), the AcceptCompletionHandler class is called,
which by the AsynchronousSocketChannel.read(ByteBuffer destination, A attachment, CompletionHandler<Integer,? super A> handler) method
initiates an asynchronous read operation from the AsynchronousSocketChannel object to a new ByteBuffer object.

class AcceptCompletionHandler implements CompletionHandler<AsynchronousSocketChannel, Void> {

   private final AsynchronousServerSocketChannel serverSocketChannel;

   AcceptCompletionHandler(AsynchronousServerSocketChannel serverSocketChannel) {
       this.serverSocketChannel = serverSocketChannel;
   }

   @Override
   public void completed(AsynchronousSocketChannel socketChannel, Void attachment) {
       serverSocketChannel.accept(null, this); // non-blocking

       ByteBuffer buffer = ByteBuffer.allocate(1024);
       ReadCompletionHandler readCompletionHandler = new ReadCompletionHandler(socketChannel, buffer);
       socketChannel.read(buffer, null, readCompletionHandler); // non-blocking
   }

   @Override
   public void failed(Throwable t, Void attachment) {
       // exception handling
   }
}
When the read operation completes (or fails), the ReadCompletionHandler class is called,
which by the AsynchronousSocketChannel.write(ByteBuffer source, A attachment, CompletionHandler<Integer,? super A> handler) method
initiates an asynchronous write operation to the AsynchronousSocketChannel object from the ByteBuffer object.

class ReadCompletionHandler implements CompletionHandler<Integer, Void> {

   private final AsynchronousSocketChannel socketChannel;
   private final ByteBuffer buffer;

   ReadCompletionHandler(AsynchronousSocketChannel socketChannel, ByteBuffer buffer) {
       this.socketChannel = socketChannel;
       this.buffer = buffer;
   }

   @Override
   public void completed(Integer bytesRead, Void attachment) {
       WriteCompletionHandler writeCompletionHandler = new WriteCompletionHandler(socketChannel);
       buffer.flip();
       socketChannel.write(buffer, null, writeCompletionHandler); // non-blocking
   }

   @Override
   public void failed(Throwable t, Void attachment) {
       // exception handling
   }
}
When the write operation completes (or fails), the WriteCompletionHandler class is called, which by the AsynchronousSocketChannel.close method closes the connection.
class WriteCompletionHandler implements CompletionHandler<Integer, Void> {

   private final AsynchronousSocketChannel socketChannel;

   WriteCompletionHandler(AsynchronousSocketChannel socketChannel) {
       this.socketChannel = socketChannel;
   }

   @Override
   public void completed(Integer bytesWritten, Void attachment) {
       try {
           socketChannel.close();
       } catch (IOException e) {
           // exception handling
       }
   }

   @Override
   public void failed(Throwable t, Void attachment) {
       // exception handling
   }
}
In this example, asynchronous I/O operations are performed without attachment,
because all the necessary objects (AsynchronousSocketChannel, ByteBuffer) are passed as constructor arguments for the appropriate completion handlers.


Java Thread
Reference:
https://www.baeldung.com/java-thread-lifecycle
Life Cycle of a Thread in Java
The java.lang.Thread class contains a static State enum – which defines its potential states. During any given point of time, the thread can only be in one of these states:
1.	NEW						a newly created thread that has not yet started the execution
2.	RUNNABLE 			either running or ready for execution but it’s waiting for resource allocation
3.	BLOCKED 				waiting to acquire a monitor lock to enter or re-enter a synchronized block/method
4.	WAITING					waiting for some other thread to perform a particular action without any time limit
5.	TIMED_WAITING 	waiting for some other thread to perform a specific action for a specified period
6.	TERMINATED 			has completed its execution
Thread Execution
1.	Extends Thread class
public class MyThread extends Thread {
@Override public void run() {
System.out.println("I am a thread!");
}
}

MyThread thread = new MyThread();
thread.start();

2.	Implements Runnable interface
public class MyRunnable implements Runnable {
@Override public void run() {
System.out.println("I am a thread!");
}
}

MyRunnable runnable = new MyRunnable();
Thread thread = new Thread(runnable);
thread.start();

3.	Implements Callable interface
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;
public class CallableExample implements Callable<String> {
@Override
public String call() throws Exception {
// This code will be executed in a separate thread.
return "Hello from a new thread!";
}
public static void main(String[] args) throws Exception {
// Create a Callable object.
Callable<String> callable = new CallableExample();

// Create a FutureTask object.
FutureTask<String> futureTask = new FutureTask<>(callable);

// Create a Thread object and pass the FutureTask object to the constructor.
Thread thread = new Thread(futureTask);
// Start the thread.
thread.start();
// Get the result from the FutureTask object.
String result = futureTask.get();
// Print the result.
System.out.println(result);
}
}
4.	The Executors class provides a number of methods for creating and managing threads.
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


public class Main {
public static void main(String[] args) {
ExecutorService executorService = Executors.newFixedThreadPool(10);

Runnable task = () -> {
System.out.println("Hello from the thread pool!");
};

executorService.submit(task);
executorService.shutdown();
}
}
5.	The ThreadPoolExecutor class provides a way to create a pool of threads that can be used to execute tasks.
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

public class Main {
public static void main(String[] args) {
// Create a thread pool with 10 core threads and a maximum of 20 threads
ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(10);

// Create a new task to be executed by the thread pool
Runnable task = () -> {
System.out.println("Hello from the thread pool!");
};

// Submit the task to the thread pool
executor.submit(task);

// Shut down the thread pool
executor.shutdown();
}
}

6.	The ScheduledExecutorService class provides a way to schedule tasks to be executed at a specific time or interval.
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
scheduledExecutorService.schedule(new Runnable() {
public void run() {
System.out.println("Hello, world!");
}
}, 5, TimeUnit.SECONDS);


Thread resource limitation
1.	If it is an unknown number of executions, use a fix-size thread pool(to avoid thread resource consumption) and limit execution time(avoid timeout issues).
2.	If it is a known number of executions, use default thread pool.
Process scheduling algorithm (google)
1.	What are process scheduling algorithm?
1)	Round robin
This algorithm gives equal priority to every process, and preempts every process after a specified time quantum.
Round robin improves response time and uses shared resources efficiently.
2)	Priority scheduling
This algorithm assigns some priorities to each process, with the process with the higher priority being assigned with the CPU first.
3)	Multilevel queue scheduling
This algorithm divides the ready queue into multiple levels or tiers, each with a different priority.
Processes are then assigned to the appropriate level based on their characteristics, such as their priority, memory requirements, and CPU usage.
4)	First come, first serve
This algorithm processes the requests made in the order of the time they arrived.
5)	Preemptive scheduling
This algorithm means that the kernel allocates execution time to each process and interrupts the execution of the currently-running process when its time's up.
6)	Longest Remaining
Time First This is an alternative scheduling technique to the longest job first.
7)	Pre emptive approach
This algorithm gives each process a fixed time to execute, called a quantum.
Once a process gets executed for the given time period, it is preempted and other process comes into execution for a given time period.
8)	Shortest job first (SJF)
This algorithm selects the waiting process with the smallest execution time to be executed next.
9)	Rate monotonic scheduling (RMS)
This is one of the most commonly used fixed priority scheduling algorithms in Real Time Systems.
2.	What is process scheduling algorithms used for?
Process scheduling algorithms are used by the CPU to select one process from many processes for execution,
maximizing CPU utilization by increasing throughput.
Java Locks
Reference:
https://medium.com/@abhirup.acharya009/managing-concurrent-access-optimistic-locking-vs-pessimistic-locking-0f6a64294db7
https://medium.com/nerd-for-tech/optimistic-vs-pessimistic-locking-strategies-b5d7f4925910
Common Lock Classification
Optimistic locking and Pessimistic locking
1.	What is optimistic locking? (google ai)
Optimistic locking is a concurrency control mechanism that assumes that multiple transactions will not attempt to modify the same data at the same time.

That is to say, it is believed that there are more read operations and fewer write operations, so the read or write data will not be locked.
However, when updating, it will be determined whether someone else has updated this data duiring this period.
2.	What are the optmistic locks in java? (google ai)
To implement optimistic locking in Java, you can use the @Version annotation on a field in your entity class.

1.	What is the pessimistic locking? (google ai)
Pessimistic locking is a concurrency control mechanism that prevents data conflicts by locking resources before they are accessed or modified.
That is to say, It is believed that there are more write operations and fewer read operations, so both read and write data will be locked.
2.	What are the pessimistic locks in java? (google ai)
Pessimistic locking can be implemented in Java using the synchronized keyword.
Shared Lock and Exclusive Lock
1.	What is shared lock?
A Shared Lock allows multiple threads to read a data item simultaneously, but prevents any thread from writing to it.
This is useful when multiple threads need to access the same data item for reading purposes, but only one thread needs to be able to write to it at a time.
Shared locks are also known as read locks.
2.	How many shared locks in java?
Here are some examples of shared locks in Java:
•	ReentrantLock:
A ReentrantLock can be used to implement a shared lock.
To do this, you would call the lock() method to acquire the lock and the unlock() method to release the lock.
•	ReadWriteLock:
A ReadWriteLock can be used to implement a shared lock.
To do this, you would call the readLock() method to acquire a shared lock and the writeLock() method to acquire a write lock.
•	StampedLock:
A StampedLock can be used to implement a shared lock.
To do this, you would call the tryOptimisticRead() method to acquire a shared lock and the unlockRead() method to release the lock.
3.	What is exclusive lock?
An exclusive lock allows only one thread to read or write a data item at a time.
This is useful when a thread needs to modify a data item and ensure that no other thread is reading or writing to it at the same time.
Exclusive locks are also known as write locks.
4.	How many exclusive locks in java?
In Java, there are multiple ways to implement exclusive locks. Here are some of them:
•	synchronized keyword:
The synchronized keyword can be used to lock an object or a class.
When a thread acquires a lock on an object, no other thread can access that object until the first thread releases the lock.
•	ReentrantLock:
The ReentrantLock class is a more powerful way to implement exclusive locks.
It allows a thread to acquire a lock multiple times and release it multiple times.
•	StampedLock:
The StampedLock class was introduced in Java 8.
It provides a more flexible way to control access to a shared resource by allowing multiple threads to read the resource concurrently.
•	Semaphores:
Semaphores are a type of lock that can be used to control access to a shared resource.
They allow a limited number of threads to access the resource at the same time.
5.	What is the difference between shared lock and exclusive lock in java?
Feature	Number of threads that can read the data item 		Number of threads that can write the data item 		Use case

Shared Lock	Multiple	Zero	When multiple threads need to read the same data item, but only one thread needs to be able to write to it at a time.
Exclusive Lock	One	One	When a thread needs to modify a data item and ensure that no other thread is reading or writing to it at the same time.

Fair lock and unfair lock
1.	What is a fair lock?
In Java, a fair lock is a lock that guarantees that threads acquire the lock in the order in which they requested it.
This means that no thread can "jump the queue" and acquire the lock before another thread that has been waiting longer.
Fair locks are typically used in situations where it is important to ensure that all threads have a fair chance of acquiring the lock.
For example, a fair lock might be used to protect a shared resource that is accessed by multiple threads.
2.	How many fair locks in java?
There are two fair locks in Java:
•	ReentrantLock
This is the most commonly used fair lock in Java. It is implemented using the AbstractQueuedSynchronizer (AQS) class.
ReentrantLock allows multiple locking operations by the same thread and supports nested locking, which means a thread can lock the same resource multiple times.
•	StampedLock
This lock was introduced in Java 8.
It provides a more flexible way to control access to a shared resource by allowing multiple threads to read the resource concurrently.
StampedLock also supports optimistic locking, which allows a thread to acquire a lock without blocking if the resource is not currently locked.
ReentrantLock is a fair lock by default, which means that threads waiting to acquire the lock will be granted the lock in the order in which they requested it.
StampedLock is not a fair lock by default, but it can be configured to be fair by passing the fair parameter to the constructor.
3.	What is an unfair lock?
An unfair lock, on the other hand, does not guarantee fairness.
This means that a thread may be able to acquire the lock before another thread that has been waiting longer.
Unfair locks are typically used in situations where performance is more important than fairness.
For example, an unfair lock might be used to protect a shared resource that is only accessed by a few threads.
4.	Is synchronized keyword a unfair lock in java?
Yes, the synchronized keyword in Java is an unfair lock.
This means that when multiple threads are waiting to acquire a lock on a synchronized block,
the thread that gets the lock is not guaranteed to be the thread that has been waiting the longest.
5.	What is the difference between fair locks and unfair locks?
Feature	Guarantees order of lock acquisition	Typically used for
Fair lock	Yes	Situations where fairness is important
Unfair lock
	No	Situations where performance is more important

Mutex lock
1.	What is mutex lock in java?
A mutex, short for mutual exclusion, is a lock that is used to ensure that only one thread can access a shared resource at a time.
In Java, mutexes are implemented using the java.util.concurrent.locks.Lock interface.
2.	Is synchronized keyword a mutex lock in java?
Yes, the synchronized keyword in Java is a mutex lock. A mutex lock is a type of lock that allows only one thread to access a shared resource at a time.
The synchronized keyword ensures that only one thread can execute a synchronized block of code at a time.
This prevents race conditions and ensures that the shared resource is accessed in a consistent manner.
Renentrant lock
1.	What is Renentrant Lock?
A Renentrant Lock is a mutual exclusion mechanism that allows threads to reenter into a lock on a resource (multiple times) without a deadlock situation.
A thread entering into the lock increases the hold count by one every time. Similarly, the hold count decreases when unlock is requested.
2.	How many Renentrant Locks in java?
ReentrantLock and synchronized,
ReentrantLock allows a thread to acquire the same lock multiple times without blocking itself. This is known as reentrancy.
ReentrantLock also supports fairness, which means that threads that have been waiting for the lock the longest will be the first to acquire it.

synchronized block are reentrant in nature
i.e if a thread has lock on the monitor object and if another synchronized block requires to have the lock on the same monitor object,
then thread can enter that code block.
synchronized also does not support fairness.
3.	Is ReentrantLock a mutual exclusion?
Yes, a ReentrantLock is a mutual exclusion (mutex).
Deadlock
1.	What is deadlock?
A deadlock in Java is a situation where two or more threads are blocked forever, waiting for each other.
There are four conditions that must be met for a deadlock to occur:
•	Mutual exclusion:		Each resource must be held by at most one thread at a time.
•	Hold and wait: 			A thread must be holding at least one resource while waiting for another resource.
•	No preemption: 		A resource cannot be forcibly taken away from a thread.
•	Circular wait: 			There must be a chain of two or more threads, each of which is waiting for a resource held by the next thread in the chain.
If all four of these conditions are met, then a deadlock can occur.
2.	How to avoid deadlock?
•	Using timeouts:
If a thread is waiting for a resource for too long, it should give up and try again later.
•	Using lock hierarchies:
If you have multiple resources that need to be locked, lock them in a specific order to avoid deadlocks.
Using deadlock detection and avoidance algorithms:
There are a number of algorithms that can be used to detect and avoid deadlocks.
3.	What are the deadlock detection and avoidance algorithms?
•	Wait-For Graph: 						A graphical representation of the system's processes and resources.
•	Banker's Algorithm: 					A resource allocation algorithm that ensures the system is always in a safe state.
•	Resource Allocation Graph: 		A graphical representation of processes and resources.
•	Safety Algorithm: 						Uses the same approach as the Banker's algorithm, but doesn't have a maximum required resource matrix.
4.	Does deadlock only happen in mutual exclusion in java?
No, deadlock does not only happen in mutual exclusion in Java.
Deadlock can occur in any situation where multiple threads are competing for resources and each thread is waiting for a resource that is held by another thread.
Spinlock
1.	What is spinlock in java? (google ai)
A spinlock is a synchronization mechanism used in multithreaded programming to protect shared resources from being accessed by multiple threads at the same time.
Spinlocks are typically implemented using a busy-waiting loop,
where a thread that attempts to acquire a lock that is already held by another thread will repeatedly check the lock status until it becomes available.
2.	What are the advantages and disadvantages of spinlock?
Advantages:
•	Spinlocks are very efficient when contention is low.
•	Spinlocks are easy to implement.
•	Spinlocks do not require any context switching.
Disadvantages:
•	Spinlocks can lead to performance problems if the lock is held for a long period of time.
•	Spinlocks can be unfair, as a thread that is spinning on a lock may be starved by other threads.
•	Spinlocks can be difficult to debug.
3.	Why doesn't spinlock have context switching?
When a thread tries to acquire a spinlock, it will keep trying until it is successful.
This means that the thread will not be put to sleep, and the operating system will not have to switch to another thread.
4.	How to implement spinlock in java?
In Java, spinlocks can be implemented using the AtomicBoolean class.
public class Spinlock {
private AtomicBoolean locked = new AtomicBoolean(false);
public void lock() {
while (locked.getAndSet(true)) {
// Busy-wait
}
}
public void unlock() {
locked.set(false);
}
}
Adaptive Spinning and Lock Elimination
1.	What is Adaptive Spinning in java? (google ai)
In Java, adaptive spinning is an optimization technique that can be used to improve the performance of lock-based synchronization.

When a thread attempts to acquire a lock that is already held by another thread, it can either spin or block.
Spinning means that the thread will continue to try to acquire the lock until it is successful.
Blocking means that the thread will suspend execution until the lock is released.

Adaptive spinning works by initially having the thread spin for a short period of time before blocking.
If the thread is successful in acquiring the lock during the spin period, then it avoids the overhead of blocking and context switching.
If the thread is not successful in acquiring the lock during the spin period, then it blocks.
2.	What is the Lock Elimination in java?
Lock elimination is another optimization technique that can be used to improve the performance of lock-based synchronization.

Lock elimination works by eliminating the need for a lock altogether in certain cases.
For example, if a thread is the only thread that can access a particular piece of data, then there is no need for a lock to protect that data.

Lock elimination can be implemented using a number of different techniques.
One common technique is to use a technique called thread-local storage.

Thread-local storage allows each thread to have its own private copy of a variable.
If a thread is the only thread that can access a particular piece of data, then the data can be stored in thread-local storage.
This eliminates the need for a lock to protect the data.

3.	How to use Adaptive Spinning and Lock Elimination in java?
Adaptive spinning is enabled by default in the HotSpot JVM.
The amount of time that a thread spins before blocking can be controlled using the -XX:AdaptiveSpinDuration JVM option.
Lock elimination is not enabled by default in the HotSpot JVM.
Lock elimination can be enabled using the -XX:+EliminateLocks JVM option.
CAS
1.	What is CAS in java?
Compare and swap (CAS) is a concurrency control mechanism that allows a thread to atomically compare the value of a memory location with a given value ,
and if the values match, modify the contents to a new given value.
(the "atomically" means that the entire operation cannot be interrupted and must be completed before any other thread can interfere)
CAS is used to implement synchronization primitives like semaphores and mutexes, as well as more sophisticated lock-free and wait-free algorithms.

When modifying shared data, save the original old value to the cache.
First modify the value of the cache variable.
When the memory value is about to be written, compare whether the cached old value and the memory value are equal to determine whether other threads have modified it.


2.	How does java use CAS?
In Java, the compareAndSet() method of the AtomicInteger class implements CAS for primitive int variables.
The compareAndSet() method takes three parameters: the memory location to be updated, the expected value, and the new value.
If the value of the memory location matches the expected value, the compareAndSet() method updates the memory location to the new value and returns true.
Otherwise, the compareAndSet() method does not update the memory location and returns false.
AtomicInteger counter = new AtomicInteger(0);

// Increment the counter atomically.
boolean success = counter.compareAndSet(0, 1);

// If the compareAndSet() method was successful, the counter will now be 1.
// Otherwise, the counter will still be 0.

3.	What is ABA problem of CAS?
The ABA problem in computer science is a false positive execution of a CAS-based speculation on a shared location.

The ABA problem occurs when multiple threads (or processes) accessing shared data interleave.
The first thread assumes that nothing has happened in the interim,
But between the two reads there could be another thread changing the value A to B and then changing the value B to A.
(after reading the old value and before attempting to execute the CAS instruction).
Even if the first thread obtains A, it is no longer the previous A.
This can fool the first thread into thinking nothing has changed.
4.	Why is it called the "ABA problem"?
ABA is not an acronym and is a shortcut for stating that a value at a shared location can change from A to B and then back to A.


Java Lock Classification
Bias lock
1.	What is biased locking?
Biased locking in Java is specifically used to optimise the synchronized keyword.
It's based on the idea that objects are often not shared between threads, so it can avoid the slower atomic instructions that are necessary for synchronization.

Biased locking works when a method is not very concurrent, and only one thread usually acquires a lock.

The JVM raises a flag in the monitor object that some thread has acquired the lock, making it lightweight for the same thread to reacquire and release the lock.
However, the lock must be revoked when another thread tries to acquire the bias lock, which is a costly operation.

With biased locking, the first time a thread synchronizes on an object, it does a bit more work to acquire synchronized ('bias' it to the thread).
Subsequent synchronizations proceed via a simple read test with no need to drain to cache.
This makes subsequent monitor-related operations performed by that thread relatively much faster on multiprocess machines.

Biased locking is on by default in Java 6, and is disabled by default in Java 15 and slated for removal.
In Java 17, bias locking was deprecated and removed. This was due to a number of factors, including the fact that bias locking could lead to performance regressions in some cases.

Lightweight locks and heavyweight locks
1.	What is a Lightweight Lock?
Lightweight locks are implemented using a technique called biased locking.
When a thread acquires a lightweight lock, the JVM sets a flag in the object header to indicate that the lock is owned by that thread.
If the same thread tries to acquire the lock again, the JVM can simply check the flag and grant the lock without having to perform any further synchronization.

However, if a different thread tries to acquire the lock, the JVM will have to perform a more expensive synchronization operation.
This is because the JVM needs to ensure that the other thread does not modify the object while the first thread is holding the lock.
2.	What is a Hightweight Lock?
Heavyweight locks are implemented using a monitor.
A monitor is a data structure that contains a queue of threads that are waiting to acquire the lock.
When a thread acquires a heavyweight lock, it is added to the end of the queue.
When the thread that owns the lock releases it, the JVM wakes up the first thread in the queue and grants it the lock.

3.	What is the difference between Lightweight Locks and Heightweight locks?
Lightweight locks and heavyweight locks are two different types of locks that can be used in Java to synchronize threads.

Heavyweight locks are less efficient than lightweight locks because they require the JVM to perform more synchronization operations.
However, heavyweight locks can be used in any situation,
while lightweight locks can only be used in situations where the same thread is likely to acquire the lock multiple times.
Here is a table summarizing the key differences between lightweight locks and heavyweight locks:

Feature	Lightweight lock	Heavyweight lock
Efficiency	More efficient	Less efficient
Applicability	Can only be used in certain situations	Can be used in any situation
Implementation	Uses biased locking	Uses a monitor


Segment Lock
1.	What is a Segment Lock?
A segment lock in Java is a locking mechanism that is used to control access to a segment of data in a concurrent hash map.
A concurrent hash map is a data structure that allows multiple threads to access and modify the same data at the same time.
Segment locks are used to prevent conflicts between threads when they are trying to access the same segment of data.

2.	How is the Segment Lock implemented?
To implement a segment lock, the concurrent hash map is divided into a number of segments.
Each segment is associated with a lock.
When a thread wants to access a segment of data, it must first acquire the lock for that segment.
Once the thread has acquired the lock, it can access the data in the segment without interference from other threads.
When the thread is finished accessing the data, it must release the lock.

Here is an example of how to use a segment lock in Java:
import java.util.concurrent.ConcurrentHashMap;
public class Example {
public static void main(String[] args) {
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// Acquire the lock for the segment that contains the key "key1".
map.lock("key1");

// Get the value associated with the key "key1".
Integer value = map.get("key1");

// Update the value associated with the key "key1".
value++;
map.put("key1", value);

// Release the lock for the segment that contains the key "key1".
map.unlock("key1");
}
}
Lock Optimization
1.	How many lock optimization methods are there in java?
•	Reduce the lock granularity.
This means using smaller locks that only protect the specific data that needs to be protected.
For example, instead of locking an entire object, you could lock only the field that needs to be updated.
•	Coarsen locks in loops.
This means moving the lock outside of a loop, so that it is only acquired once.
For example, instead of locking the list inside of a loop, you could lock the list before the loop and unlock it after the loop.
•	Reduce the lock holding time.
This means releasing the lock as soon as possible.
For example, instead of holding the lock while you are reading data, you could release the lock after you have read the data.
•	Use JDK-optimized concurrency classes.
The Java Development Kit (JDK) provides a number of concurrency classes that are optimized for performance.
For example, the ReentrantLock class is a re-entrant lock that can be used to protect shared data.
Class Loader
Constant pool:
Reference:
https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.1
Classloader
Reference:
All about Java class loaders
https://www.infoworld.com/article/3700054/all-about-java-class-loaders.html
Class Loaders in Java
https://www.baeldung.com/java-classloaders
Java Virtual Machine Specification
https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html
Concept
1.	What is class loader in java?
In Java, a class loader is a mechanism that loads classes into the Java Virtual Machine (JVM).
It is responsible for finding, loading, and linking classes. The class loader is a part of the Java Runtime Environment (JRE) and is responsible for loading Java classes dynamically during runtime.
2.	When does a class loader load classes?
•	When a class is referenced in a new expression (create an object).

•	When a class is referenced in a static variable.
(Except for the constants in the constant pool, because they have been put into the constant pool during the compilation process,
using these constants does not directly refer to the current class.)
•	When a class is referenced in a static method call.

•	When a class is referenced in the instanceof operator.
•	When a class is referenced in the cast operator.

•	When a class is referenced by reflection.
(Obtaining a Class object through the class name does not trigger class initialization. )
(When Class.forName method manually specifies the parameter "initialize" as false, initialization will not be executed. )
(ClassLoader.loadClass deafults to the second parameter false, and linking and initialization will not be executed.)
•	When the main class is executed.
3.	How is JVM started?
The Java Virtual Machine starts up by creating an initial class, which is specified in an implementation-dependent manner, using the bootstrap class loader.
The Java Virtual Machine then links the initial class, initializes it, and invokes the public class method void main(String[]).
The invocation of this method drives all further execution.
Execution of the Java Virtual Machine instructions constituting the main method may cause linking (and consequently creation) of additional classes and interfaces, as well as invocation of additional methods.

4.	How to use custom classloader to load classes from a directory or jar file?
•	Load classes from a specific directory:
public class MyClassLoader extends ClassLoader {
private String directory;
public MyClassLoader(String directory) {
this.directory = directory;
}
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
byte[] bytes = loadClassData(name);
return defineClass(name, bytes, 0, bytes.length);
}
private byte[] loadClassData(String name) throws ClassNotFoundException {
File file = new File(directory, name + ".class");
if (!file.exists()) {
throw new ClassNotFoundException("Class not found: " + name);
}
try {
FileInputStream fis = new FileInputStream(file);
byte[] bytes = new byte[(int) file.length()];
fis.read(bytes);
fis.close();
return bytes;
} catch (IOException e) {
throw new ClassNotFoundException("Error loading class: " + name, e);
}
}
}
MyClassLoader classLoader = new MyClassLoader("/path/to/classes");
Class<?> myClass = classLoader.loadClass("MyClass");
•	Load classes from a jar file:
public class MyClassLoader extends ClassLoader {
private URL jarFileURL;
public MyClassLoader(URL jarFileURL) {
this.jarFileURL = jarFileURL;
}
@Override
protected Class<?> findClass(String name) throws ClassNotFoundException {
try {
JarURLConnection jarURLConnection = (JarURLConnection) jarFileURL.openConnection();
JarFile jarFile = jarURLConnection.getJarFile();
ZipEntry zipEntry = jarFile.getEntry(name + ".class");
if (zipEntry == null) {
throw new ClassNotFoundException(name);
}
InputStream inputStream = jarFile.getInputStream(zipEntry);
byte[] bytes = new byte[(int) zipEntry.getSize()];
inputStream.read(bytes);
inputStream.close();
Class<?> clazz = defineClass(name, bytes, 0, bytes.length);
return clazz;
} catch (IOException e) {
throw new ClassNotFoundException(name, e);
}
}
}
MyClassLoader myClassLoader = new MyClassLoader(new URL("file:///path/to/jar/file.jar"));
Class<?> clazz = myClassLoader.loadClass("com.example.MyClass");
Classloader Types
1.	Bootstrap ClassLoader:
Also known as the primordial class loader, this is the class loader where the search starts.
The bootstrap class loader is responsible for loading core Java classes such as java.lang.Object and java.lang.String.
It is implemented in native code and classes are located in the $JAVA_HOME/lib directory.


There were some important changes to class loaders between Java 8 and Java 9.
For example, in Java 8, the bootstrap class loader was located in the Java Runtime Environment's rt.jar file. In Java 9 and subsequently, the rt.jar file was removed.

Moreover, Java 9 introduced the Java module system, which changed how classes are loaded.
In the module system, each module defines its own class loader, and the bootstrap class loader is responsible for loading the module system itself and the initial set of modules.
When the JVM starts up, the bootstrap class loader loads the java.base module, which contains the core Java classes and any other modules that are required to launch the JVM.
The java.base module also exports packages to other modules, such as java.lang, which contains core classes like Object and String. These packages are then loaded by the bootstrap class loader.

Get and print bootstrap classloader:
public class BootstrapClassLoaderExample {
public static void main(String[] args) {
// Get the class loader for the String class, loaded by the Bootstrap Class Loader
ClassLoader loader = String.class.getClassLoader();
// Print the class loader's name
System.out.println("Class loader for String class: " + loader);
}
}
Output:
Class loader for String class: null
This is because the bootstrap class loader is the primordial class loader and does not have a name.
2.	Extension ClassLoader
It was used in earlier versions of Java to load classes from the extension directory, which was typically located in the JRE/lib/ext directory.
In Java 8, the extension classloader is known as the platform class loader.

In Java 9 and later versions, the extension class loader was removed from the JVM.
Instead of the extension class loader, Java 9 and later versions use the java.lang.ModuleLayer class to load modules from the extension directory.
The extension directory is now treated as a separate layer in the module system, and modules in the extension directory are loaded by the extension layer's class loader.

how to get and print extension classloader in java 8?
public class GetExtensionClassLoader {
public static void main(String[] args) {
ClassLoader extensionClassLoader = ClassLoader.getPlatformClassLoader();
System.out.println("Extension classloader: " + extensionClassLoader);
}
}
Output:
Extension classloader: sun.misc.Launcher$ExtClassLoader@7852e922

how to use the ModuleLayer class to load classes in java 9?
ModuleLayer layer = ModuleLayer.boot();
Module module = layer.findModule("java.base");
ClassLoader classLoader = module.getClassLoader();
Class<?> clazz = classLoader.loadClass("java.lang.String");
3.	System ClassLoader
This ClassLoader loads classes from the classpath.
The classpath is a list of directories and JAR files that the JVM searches for classes. The classpath can be set using the CLASSPATH environment variable.

1.	How does classloader load classes?
Class loaders follow the delegation model,
where on request to find a class or resource, a ClassLoader instance will delegate the search of the class or resource to the parent class loader.
Let's say we have a request to load an application class into the JVM.
The system class loader first delegates the loading of that class to its parent extension class loader, which in turn delegates it to the bootstrap class loader.
Only if the bootstrap and then the extension class loader are unsuccessful in loading the class, the system class loader tries to load the class itself.

If the class is not found, the JVM throws a ClassNotFoundException.
Loading, linking and initialization
Loading
1.	What is the loading process of classloader?
Creation of a class or interface C denoted by the name N consists of the construction in the method area of the Java Virtual Machine (§2.5.4) of an implementation-specific internal representation of C.
Class or interface creation is triggered by another class or interface D, which references C through its run-time constant pool.
Class or interface creation may also be triggered by D invoking methods in certain Java SE platform class libraries (§2.12) such as reflection.

If C is not an array class, it is created by loading a binary representation of C (§4) using a class loader.
Array classes do not have an external binary representation; they are created by the Java Virtual Machine rather than by a class loader.

There are two kinds of class loaders:
the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders.

Every user-defined class loader is an instance of a subclass of the abstract class ClassLoader.
Applications employ user-defined class loaders in order to extend the manner in which the Java Virtual Machine dynamically loads and thereby creates classes.
User-defined class loaders can be used to create classes that originate from user-defined sources.
For example, a class could be downloaded across a network, generated on the fly, or extracted from an encrypted file.

A class loader L may create C by defining it directly or by delegating to another class loader.
If L creates C directly, we say that L defines C or, equivalently, that L is the defining loader of C.

When one class loader delegates to another class loader, the loader that initiates the loading is not necessarily the same loader that completes the loading and defines the class.

If L creates C, either by defining it directly or by delegation, we say that L initiates loading of C or, equivalently, that L is an initiating loader of C.
At run time, a class or interface is determined not by its name alone, but by a pair: its binary name (§4.2.1) and its defining class loader.
Each such class or interface belongs to a single run-time package.
The run-time package of a class or interface is determined by the package name and defining class loader of the class or interface.

The Java Virtual Machine uses one of three procedures to create class or interface C denoted by N:
•	If N denotes a nonarray class or an interface, one of the two following methods is used to load and thereby create C:
o	If D was defined by the bootstrap class loader, then the bootstrap class loader initiates loading of C (§5.3.1).
o	If D was defined by a user-defined class loader, then that same user-defined class loader initiates loading of C (§5.3.2).
•	Otherwise N denotes an array class. An array class is created directly by the Java Virtual Machine (§5.3.3), not by a class loader. However, the defining class loader of D is used in the process of creating array class C.

Linking
1.	What is the linking process of classloader?

Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary.
Resolution of symbolic references in the class or interface is an optional part of linking.

This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained:
•	A class or interface is completely loaded before it is linked.
•	A class or interface is completely verified and prepared before it is initialized.
•	Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.

For example, a Java Virtual Machine implementation may choose to resolve each symbolic reference in a class or interface individually when it is used ("lazy" or "late" resolution),
or to resolve them all at once when the class is being verified ("eager" or "static" resolution).

This means that the resolution process may continue, in some implementations, after a class or interface has been initialized. Whichever strategy is followed,
any error detected during resolution must be thrown at a point in the program that (directly or indirectly) uses a symbolic reference to the class or interface.

Because linking involves the allocation of new data structures, it may fail with an OutOfMemoryError.
a)	Verification
Verification (§4.10) ensures that the binary representation of a class or interface is structurally correct (§4.9).
Verification may cause additional classes and interfaces to be loaded (§5.3) but need not cause them to be verified or prepared.
If the binary representation of a class or interface does not satisfy the static or structural constraints listed in §4.9,
then a VerifyError must be thrown at the point in the program that caused the class or interface to be verified.
If an attempt by the Java Virtual Machine to verify a class or interface fails because an error is thrown that is an instance of LinkageError (or a subclass),
then subsequent attempts to verify the class or interface always fail with the same error that was thrown as a result of the initial verification attempt.
b)	Preparation
Preparation involves creating the static fields for a class or interface and initializing such fields to their default values (§2.3, §2.4).

This does not require the execution of any Java Virtual Machine code; explicit initializers for static fields are executed as part of initialization (§5.5), not preparation.
During preparation of a class or interface C, the Java Virtual Machine also imposes loading constraints (§5.3.4).
Let L1 be the defining loader of C. For each method m declared in C that overrides (§5.4.5) a method declared in a superclass or superinterface <D, L2>, the Java Virtual Machine imposes the following loading constraints:
Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, ..., Tfn, then:
If Tr not an array type, let T0 be Tr; otherwise, let T0 be the element type (§2.4) of Tr.
For i = 1 to n: If Tfi is not an array type, let Ti be Tfi; otherwise, let Ti be the element type (§2.4) of Tfi.
Then TiL1 = TiL2 for i = 0 to n.
Furthermore, if C implements a method m declared in a superinterface <I, L3> of C, but C does not itself declare the method m, then let <D, L2> be the superclass of C that declares the implementation of method m inherited by C. The Java Virtual Machine imposes the following constraints:
Given that the return type of m is Tr, and that the formal parameter types of m are Tf1, ..., Tfn, then:
If Tr not an array type, let T0 be Tr; otherwise, let T0 be the element type (§2.4) of Tr.
For i = 1 to n: If Tfi is not an array type, let Ti be Tfi; otherwise, let Ti be the element type (§2.4) of Tfi.
Then TiL2 = TiL3 for i = 0 to n.
Preparation may occur at any time following creation but must be completed prior to initialization.
c)	Resolution
In this phase, symbolic references are replaced with direct references present in the runtime constant pool.
The JVM no longer needs to resolve a constant pool reference if the specific reference is already resolved ahead-of-time (at dump time).

The Java Virtual Machine instructions anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface,
invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, and putstatic
make symbolic references to the run-time constant pool.
Execution of any of these instructions requires resolution of its symbolic reference.

Resolution is the process of dynamically determining concrete values from symbolic references in the run-time constant pool.
Resolution of the symbolic reference of one occurrence of an invokedynamic instruction does not imply that the same symbolic reference is considered resolved for any other invokedynamic instruction.

For all other instructions above, resolution of the symbolic reference of one occurrence of an instruction does imply that the same symbolic reference is considered resolved for any other non-invokedynamic instruction.

(The above text implies that the concrete value determined by resolution for a specific invokedynamic instruction is a call site object bound to that specific invokedynamic instruction.)

Resolution can be attempted on a symbolic reference that has already been resolved.
An attempt to resolve a symbolic reference that has already successfully been resolved always succeeds trivially and always results in the same entity produced by the initial resolution of that reference.

If an error occurs during resolution of a symbolic reference, then an instance of IncompatibleClassChangeError (or a subclass) must be thrown at a point in the program that (directly or indirectly) uses the symbolic reference.

If an attempt by the Java Virtual Machine to resolve a symbolic reference fails because an error is thrown that is an instance of LinkageError (or a subclass), then subsequent attempts to resolve the reference always fail with the same error that was thrown as a result of the initial resolution attempt.

A symbolic reference to a call site specifier by a specific invokedynamic instruction must not be resolved prior to execution of that instruction.

In the case of failed resolution of an invokedynamic instruction, the bootstrap method is not re-executed on subsequent resolution attempts.

Certain of the instructions above require additional linking checks when resolving symbolic references. For instance, in order for a getfield instruction to successfully resolve the symbolic reference to the field on which it operates, it must not only complete the field resolution steps given in §5.4.3.2 but also check that the field is not static. If it is a static field, a linking exception must be thrown.

Notably, in order for an invokedynamic instruction to successfully resolve the symbolic reference to a call site specifier, the bootstrap method specified therein must complete normally and return a suitable call site object. If the bootstrap method completes abruptly or returns an unsuitable call site object, a linking exception must be thrown.

Linking exceptions generated by checks that are specific to the execution of a particular Java Virtual Machine instruction are given in the description of that instruction and are not covered in this general discussion of resolution. Note that such exceptions, although described as part of the execution of Java Virtual Machine instructions rather than resolution, are still properly considered failures of resolution.

The following sections describe the process of resolving a symbolic reference in the run-time constant pool (§5.1) of a class or interface D. Details of resolution differ with the kind of symbolic reference to be resolved.

Initialization
1.	What is the loading process of classloader?
Initialization of a class or interface consists of executing its class or interface initialization method (§2.9).
A class or interface may be initialized only as a result of:
•	The execution of any one of the Java Virtual Machine instructions new, getstatic, putstatic, or invokestatic that references the class or interface (§new, §getstatic, §putstatic, §invokestatic).
All of these instructions reference a class directly or indirectly through either a field reference or a method reference.

Upon execution of a new instruction, the referenced class or interface is initialized if it has not been initialized already.
Upon execution of a getstatic, putstatic, or invokestatic instruction, the class or interface that declared the resolved field or method is initialized if it has not been initialized already.

•	The first invocation of a java.lang.invoke.MethodHandle instance which was the result of resolution of a method handle by the Java Virtual Machine (§5.4.3.5) and which has a kind of 2 (REF_getStatic), 4 (REF_putStatic), or 6 (REF_invokeStatic).
•	Invocation of certain reflective methods in the class library (§2.12), for example, in class Class or in package java.lang.reflect.
•	The initialization of one of its subclasses.
•	Its designation as the initial class at Java Virtual Machine start-up (§5.2).
Prior to initialization, a class or interface must be linked, that is, verified, prepared, and optionally resolved.
Because the Java Virtual Machine is multithreaded, initialization of a class ors interface requires careful synchronization,
since some other thread may be trying to initialize the same class or interface at the same time.
There is also the possibility that initialization of a class or interface may be requested recursively as part of the initialization of that class or interface.
The implementation of the Java Virtual Machine is responsible for taking care of synchronization and recursive initialization by using the following procedure.
It assumes that the Class object has already been verified and prepared, and that the Class object contains state that indicates one of four situations:
•	This Class object is verified and prepared but not initialized.
•	This Class object is being initialized by some particular thread.
•	This Class object is fully initialized and ready for use.
•	This Class object is in an erroneous state, perhaps because initialization was attempted and failed.
For each class or interface C, there is a unique initialization lock LC. The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation.
For example, LC could be the Class object for C, or the monitor associated with that Class object. The procedure for initializing C is then as follows:
1.	Synchronize on the initialization lock, LC, for C. This involves waiting until the current thread can acquire LC.
2.	If the Class object for C indicates that initialization is in progress for C by some other thread, then release LC and block the current thread until informed that the in-progress initialization has completed, at which time repeat this procedure.
3.	If the Class object for C indicates that initialization is in progress for C by the current thread, then this must be a recursive request for initialization. Release LC and complete normally.
4.	If the Class object for C indicates that C has already been initialized, then no further action is required. Release LC and complete normally.
5.	If the Class object for C is in an erroneous state, then initialization is not possible. Release LC and throw a NoClassDefFoundError.
6.	Otherwise, record the fact that initialization of the Class object for C is in progress by the current thread, and release LC. Then, initialize each final static field of C with the constant value in its ConstantValue attribute (§4.7.2), in the order the fields appear in the ClassFile structure.
7.	Next, if C is a class rather than an interface, and its superclass SC has not yet been initialized, then recursively perform this entire procedure for SC. If necessary, verify and prepare SC first.
If the initialization of SC completes abruptly because of a thrown exception, then acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete abruptly, throwing the same exception that resulted from initializing SC.
8.	Next, determine whether assertions are enabled for C by querying its defining class loader.
9.	Next, execute the class or interface initialization method of C.
10.	If the execution of the class or interface initialization method completes normally, then acquire LC, label the Class object for C as fully initialized, notify all waiting threads, release LC, and complete this procedure normally.
11.	Otherwise, the class or interface initialization method must have completed abruptly by throwing some exception E. If the class of E is not Error or one of its subclasses, then create a new instance of the class ExceptionInInitializerError with E as the argument, and use this object in place of E in the following step.
If a new instance of ExceptionInInitializerError cannot be created because an OutOfMemoryError occurs, then use an OutOfMemoryError object in place of E in the following step.
12.	Acquire LC, label the Class object for C as erroneous, notify all waiting threads, release LC, and complete this procedure abruptly with reason E or its replacement as determined in the previous step.
A Java Virtual Machine implementation may optimize this procedure by eliding the lock acquisition in step 1 (and release in step 4/5) when it can determine that the initialization of the class has already completed, provided that, in terms of the Java memory model, all happens-before orderings (JLS §17.4.5) that would exist if the lock were acquired, still exist when the optimization is performed.
2.	What is the execution order of static blocks of parent class and subclass static in Java and the setting order of static fields?
1)	Static blocks of the parent class are executed.
2)	Static fields of the parent class are initialized.
3)	Static blocks of the child class are executed.
4)	Static fields of the child class are initialized.

5)	Instance blocks of the parent class are executed. （instantiation）
6)	Instance fields of the parent class are initialized.
7)	Constructor of the parent class is executed.
8)	Instance blocks of the child class are executed.
9)	Instance fields of the child class are initialized.
10)	Constructor of the child class is executed.
Example:
class Parent {
static {
System.out.println("Parent static block");
}


static int parentStaticField = 10;


{
System.out.println("Parent instance block");
}


int parentInstanceField = 20;


Parent() {
System.out.println("Parent constructor");
}
}


class Child extends Parent {
static {
System.out.println("Child static block");
}


static int childStaticField = 30;


{
System.out.println("Child instance block");
}


int childInstanceField = 40;


Child() {
System.out.println("Child constructor");
}
}


public class Main {
public static void main(String[] args) {
new Child();
}
}

Output:
Parent static block
Child static block
Parent instance block
Child instance block
Parent constructor
Child constructor

Java Reflection
Concept
1.	What is the java reflection mechanism?
Reflection is a feature in the Java programming language. It allows an executing Java program to examine or "introspect" upon itself,
and manipulate internal properties of the program.
For example, it's possible for a Java class to obtain the names of all its members and display them.
2.	How to get the Class object use java reflection?
•	Using the Class.forName() method.
Class<?> cls = Class.forName("com.example.MyClass");
•	Using the <obj>.getClass() method.
MyClass obj = new MyClass();
Class<?> cls = obj.getClass();
•	Using <class-name>.class.
Class<?> cls = MyClass.class;
3.	What is the difference between using "Class.forName" and "<class-name>.class" to get a class object?
Obtaining a Class object through the class name does not trigger class initialization.
4.	How to use reflection api to obtain information about fields, methods, constructors?
Here is an example of how to use the Class object to get information about a class:
Class<?> cls = Class.forName("com.example.MyClass");

// Get the name of the class.
String className = cls.getName();

// Get the fields of the class.
Field[] fields = cls.getDeclaredFields();

// Get the methods of the class.
Method[] methods = cls.getDeclaredMethods();

// Get the constructors of the class.
Constructor[] constructors = cls.getDeclaredConstructors();
Here is an example of how to use the Class object to create a new instance of a class:
Class<?> cls = Class.forName("com.example.MyClass");

// Create a new instance of the class.
Object obj = cls.newInstance();

Java EE Standard
Concept
1.	What is java EE standard?
Java Platform, Enterprise Edition (Java EE) is the standard in community-driven enterprise software.
Java EE is developed using the Java Community Process, with contributions from industry experts, commercial and open source organizations, Java User Groups, and countless individuals.
2.	What does java SE stand for?
SE stands for Java Standard Edition.
Java SE is a computing platform that allows developers to build and deploy Java applications on servers and desktops.
It's part of the Java software-platform family and uses the Java programming language. Java SE was previously known as Java 2 Platform, Standard Edition (J2SE).
3.	Does java ee 6 include java ee 5 features?
Yes, Java EE 6 includes some features from Java EE 5, along with new technologies and usability improvements.


Java EE 5
1.	Web Services Technologies
Implementing Enterprise Web Services						JSR 109
Java API for XML-Based Web Services (JAX-WS) 2.0	JSR 224
Java API for XML-Based RPC (JAX-RPC) 1.1					JSR 101
Java Architecture for XML Binding (JAXB) 2.0				JSR 222
SOAP with Attachments API for Java (SAAJ)				JSR 67	JSR 173
Web Service Metadata for the Java Platform				JSR 181
2.	Web Application Technologies
JavaServer Faces 1.2								JSR 252
JavaServer Pages 2.1								JSR 245
JavaServer Pages Standard Tag Library	JSR 52
Java Servlet 2.5										JSR 154
3.	Enterprise Application Technologies
Common Annotations for the Java Platform	JSR 250
Enterprise JavaBeans 3.0									JSR 220
J2EE Connector Architecture 1.5						JSR 112
JavaBeans Activation Framework (JAF) 1.1		JSR 925
JavaMail															JSR 919
Java Message Service API								JSR 914
Java Persistence API											JSR 220
Java Transaction API (JTA)								JSR 907
4.	Management and Security Technologies
J2EE Application Deployment							JSR 88
J2EE Management											JSR 77
Java Authorization Contract for Containers		JSR 115
Java EE 6
1.	Web Services Technologies
Java API for RESTful Web Services (JAX-RS) 1.1			JSR 311
Implementing Enterprise Web Services 1.3					JSR 109
Java API for XML-Based Web Services (JAX-WS) 2.2	JSR 224
Java Architecture for XML Binding (JAXB) 2.2				JSR 222
Web Services Metadata for the Java Platform				JSR 181
Java API for XML-Based RPC (JAX-RPC) 1.1					JSR 101
Java APIs for XML Messaging 1.3								JSR 67
Java API for XML Registries (JAXR) 1.0							JSR 93
2.	Web Application Technologies
Java Servlet 3.0																JSR 315
JavaServer Faces 2.0														JSR 314
JavaServer Pages 2.2/Expression Language 2.2				JSR 245
Standard Tag Library for JavaServer Pages (JSTL) 1.2		JSR 52
Debugging Support for Other Languages 1.0					JSR 45
3.	Enterprise Application Technologies
Contexts and Dependency Injection for Java (Web Beans 1.0)	JSR 299
Dependency Injection for Java 1.0												JSR 330
Bean Validation 1.0																		JSR 303
Enterprise JavaBeans 3.1 (includes Interceptors 1.1)					JSR 318
Java EE Connector Architecture 1.6												JSR 322
Java Persistence 2.0																		JSR 317
Common Annotations for the Java Platform 1.1							JSR 250
Java Message Service API 1.1														JSR 914
Java Transaction API (JTA) 1.1														JSR 907
JavaMail 1.4																					JSR 919
4.	Management and Security Technologies
Java Authentication Service Provider Interface for Containers	JSR 196
Java Authorization Contract for Containers 1.3							JSR 115
Java EE Application Deployment 1.2											JSR 88
J2EE Management 1.1																	JSR 77
5.	Java EE-related Specs in Java SE
Java API for XML Processing (JAXP) 1.3						JSR 206
Java Database Connectivity 4.0									JSR 221
Java Management Extensions (JMX) 2.0						JSR 255
JavaBeans Activation Framework (JAF) 1.1					JSR 925
Streaming API for XML (StAX) 1.0								JSR 173

Java = Usage
Xml reading and writing
There are four main ways for JAVA to manipulate XML documents, namely DOM, SAX, JDOM, and DOM4J
The DOM and SAX is provided by official, and JDOM and DOM4J uses threeparty libraries,
DOM and SAX are officially provided, while JDOM and DOM4J refer to third-party libraries, with the most commonly used being the DOM4J method.
The best one in terms of operational efficiency and memory usage is SAX, but due to its event based approach, SAX cannot modify the written content during the process of writing XML .
But for requirements that do not require frequent modifications, SAX should still be chosen.
DOM
File file = new File(xmlSavePath + "/mb.xml");
File copyFile = new File(xmlSavePath + "/" + filename + ".xml");         Copy Template xml
FileUtils.copyFile(file, copyFile);

DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();         Create a DocumentBuilder object to  convert XML files into Document Objects
Document document = documentBuilder.parse(copyFile);                                                        Create a Document object to parse xml files.

Node processor = document.getElementsByTagName("PROCESSOR").item(0);                        Get the value of the "PROCESSOR" tag.
NamedNodeMap processors = processor.getAttributes();
processors.getNamedItem("path").setTextContent(systemConfig.getAnalysisToolValus());         Modify the "path" attribute.

TransformerFactory transformerFactory = TransformerFactory.newInstance();
Transformer transformer = transformerFactory.newTransformer();
DOMSource domSource = new DOMSource(document);
StreamResult reStreamResult = new StreamResult(copyFile);
transformer.transform(domSource, reStreamResult);
SAX
DefaultHandler
 public class PomParseHandler extends DefaultHandler       必须重写一个hanlder处理xml文件，覆盖startElement方法，可以针对每一个元素遍历
    @Override
    public void startElement (String uri, String localName,
                              String qName, Attributes attributes)
            throws SAXException
    {
        // no op
    }

    @Override
    public void endElement (String uri, String localName, String qName)
            throws SAXException
    {
        // no op
    }


    @Override
    public void characters (char ch[], int start, int length)
            throws SAXException
    {
        // no op
    }
Read Xml file
// sax parser
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser parser = factory.newSAXParser();
PersonHandler personHandler = new PersonHandler();
parser.parse(inStream, personHandler);
inStream.close();
return personHandler.getPersons();

//Sax2解析XML文档
PomParseHandler sax2Handler = new PomParseHandler();
XMLReader xmlReader = XMLReaderFactory.createXMLReader();
xmlReader.setContentHandler(sax2Handler);
xmlReader.setErrorHandler(sax2Handler);

FileReader fileReader = new FileReader("./src/sample.xml");
xmlReader.parse(new InputSource(fileReader));

//sax1解析XML文档
PomParseHandler saxHandler = new PomParseHandler();
SAXParser parser = SAXParserFactory.newInstance().newSAXParser();

File file = new File("./src/sample.xml");
parser.parse(file, saxHandler);
Xml Content
<?xml version="1.0" encoding="utf-8"?>
<websites
    xmlns:sina="http://www.sina.com"
    xmlns:baidu="http://www.baidu.com">

    <sina:website sina:blog="blog.sina.com">新浪</sina:website>
    <baidu:website baidu:blog="hi.baidu.com">百度</baidu:website>
</websites>
sax不支持LocalName、QName和uri。对于属性sina:blog="blog.sina.com"，sax解析的结果是LocalName=QName="sina:blog"，uri=""，value="blog.sina.com"。
sax2支持LocalName、QName、uri。对于属性sina:blog="blog.sina.com"，sax2解析的结果是LocalName="blog"，QName="sina:blog"，uri=""，value="blog.sina.com"。
Original Array
子数组操作
Arrays.asList(array).subList(x, y).
byte [] a2 = {0, 0, 1, 0}; ByteBuffer buf = ByteBuffer.wrap(a1,0,3);   // 针对字节数组
Arrays.copyOfRange(T[] original, int from, int to)
List转换原始数组
List.toArray(T[] a)
XPath
DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
Document doc = builder.parse(new InputSource(new StringReader(xml)));
NodeList nlist = doc.getElementsByTagName("comment");

XPathFactory xpf = XPathFactory.newInstance();
XPath xp = xpf.newXPath();
NodeList nodes = (NodeList)xp.evaluate("//@*", nlist.item(0), XPathConstants.NODESET);
for(int i = 0; i < nodes.getLength(); i++)
    System.out.println(nodes.item(i));



Java = Core
Constants and variables
int a=999,b=a/10;       		int a=0b11001;        	int a=0b11001;       	int a=-017;       	int a=-0xD8;                    			整数，默认值0（4byte）
short a=999,b=a/10;      		short a=0b11001;      	short a=0b11001;   short a=-017;      short a=-0xD8;                 短整数（2byte）【+号运算结果为int型，+=运算结果可以自动转换为short】
long a=88_999L,b=a/10;     long a=0b11001L;      long a=0b11001;     long a=-017l;    	long a=-0xD8L;            长整数（8byte）可以直接与Long包装类型equals为true，可以添加斜杠区分位数
byte a=999,b=a/10;      		byte a=0b11001;       	byte a=0b11001      byte a=-017;     	byte a=-0xD8;  byte a='c'      字节  （1byte）【类似char存储】

float a=3;   							float a =.75f       float a=3.88f;  float a=4.2F;     float a=2e-5f;          float a=4.4E-10F;               单精度浮点，默认值0.0（4byte）【可以省略小数点前的0】
double a=3;    double a=3.88;  double a=4.2d;    double a=2e-5D   double a=4.4E-10;                               双精度浮点，默认值0.0（8byte）【精度丢失：  400 -612.78 = -212.77999999999997 】
char a='x';   char a=68;     char a='\u005d';                              字符（2byte）【计算时等同数字，ASCII码存储：   48-56（0-9）  65-90（A-Z）  97-122（a-z）   -32变大写  +32 变小写】
boolean a=false;  boolean b=true;                                         布尔（1byte）

String a="xx"  String b="xx"      String a=new String("aa");               String 字符串，拼接效率：StringBuilder >> concat > +（字符串比较不能用==，必须equals，因为可能出现地址和字符串的比较）   【 \\(     在JAVA中双斜线才能转义，但是双斜线不能单独使用 】
String k=new String( charArr );    String k=new String(charArr, 2, 3);             "a"+null+"b" = anullb
String k=new String( byteArr )    String k=new String(byteArr, 2, 3)

final int a   final void handleGet(){}    final class Person{}                                                       常量  final常量只能被赋值一次  final方法不能被子类方法覆盖     final类不能被继承，并且类中所有成员 都为final
int[] a;  int a[];  int a[50]{0};    int []a={1,2,3,4};  int a[]= new int[]{1,2,3,4,5};    double[] a = new double[6]    数组  不初始化默认数组内部初始值为0，必须指定数组大小，不能超出指定大小的索引
a.clone()       返回一个克隆原始数组
a.toString()   返回首个元素，使用Arrays.toString()返回所有元素 [33, 44, 55]
Boolean，Character，Byte，Short，Integer，Long，Float，Double   引用类型（引用的初始值为null，基础类型初始值各不相同）

POJO（Plain Ordinary Java Object）     普通对象。没有规则约束（包括DTO，VO，BO，PO）
DTO（Data Transfer Object）           数据传输对象。单纯用来数据传输的对象（有的项目又分InDto 和OutDto ，顾名思义就是输入和输出的Dto）
PO（Persistant Object）                持久对象，可以看成是数据库表的映射。

BO（Business Object）                业务对象，每个业务可能需要很多 PO来组成，也可以就是 PO，是一种满足业务需要的传输对象（当返回前端页面 或者 返回给调用方的时候，需要组合PO进行显示）
VO（Value Object）                  值对象，就是一个传输对象。
DAO（Data Access Object）          数据访问对象，通过 DAO  对数据库做识别操作，最终返回我们想要的数据。


JAVA 四中引用类型：
强引用：在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。
        当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之 一
软引用：软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
弱引用：弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存
虚引用：虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态
面对对象编程：    一切皆对象，如果想要调用一个函数，函数必须属于一个类或对象，然后再使用类或对象进行调用
函数式编程：      可以直接定义一个函数，然后直接调用

核心字符串数据问题：t_user_table  -->  TuserTable


String Literals
1.	A string literal consists of zero or more characters enclosed in double quotes.
Characters may be represented by escape sequences (§3.10.6) - one escape sequence for characters in the range U+0000 to U+FFFF,
two escape sequences for the UTF-16 surrogate code units of characters in the range U+010000 to U+10FFFF.

2.	Instances of class String represent sequences of Unicode code points.
A String object has a constant (unchanging) value.
String literals (§3.10.5) are references to instances of class String.
The string concatenation operator + (§15.18.1) implicitly creates a new String object when the result is not a compile-time constant expression (§15.28).
3.	The program consisting of the compilation unit (§7.3):
package testPackage;
class Test {
    public static void main(String[] args) {
        String hello = "Hello", lo = "lo";
        System.out.print((hello == "Hello") + " ");
        System.out.print((Other.hello == hello) + " ");
        System.out.print((other.Other.hello == hello) + " ");
        System.out.print((hello == ("Hel"+"lo")) + " ");
        System.out.print((hello == ("Hel"+lo)) + " ");
        System.out.println(hello == ("Hel"+lo).intern());
    }
}
class Other { static String hello = "Hello"; }
and the compilation unit:
package other;
public class Other { public static String hello = "Hello"; }
produces the output:
true true true true false true
This example illustrates six points:
•	Literal strings within the same class (§8) in the same package (§7) represent references to the same String object (§4.3.1).
•	Literal strings within different classes in the same package represent references to the same String object.
•	Literal strings within different classes in different packages likewise represent references to the same String object.
•	Strings computed by constant expressions (§15.28) are computed at compile time and then treated as if they were literals.
•	Strings computed by concatenation at run time are newly created and therefore distinct.
•	The result of explicitly interning a computed string is the same string as any pre-existing literal string with the same contents.

Data Type Conversion
Widening or Automatic Type Conversion
Widening conversion takes place when two data types are automatically converted. This happens when:
•	The two data types are compatible.
•	When we assign a value of a smaller data type to a bigger data type.
short，byte, char  →  int  →  long  →  float    →  double
double i = 1/3.33;     //  1.00/3.33
float i = 23;
Narrowing or Explicit Conversion
If we want to assign a value of a larger data type to a smaller data type we perform explicit type casting or narrowing.
•	This is useful for incompatible data types where automatic conversion cannot be done.
•	Here, the target type specifies the desired type to convert the specified value to.
(For primitive types, you can use Widening Type Conversion or Narrowing Type Conversion. but for objects, you can only use Narrowing Type Conversion to convert a subclass to a parent classes.)
double d = 100.04;
long l = (long)d;
int i = (int)l;
char c=(char)2

Child child = new Child();
Parent parent = (Parent)child;

Check Object Type
per instanceof Person         当对象属于此类时true   否则flase （属于子类 同时属于父类）

Common Data Type Conversion
1.	Convert string to other types
Integer.parseInt("22")            严格字符串转换，必须符合当前类型写法（整数 含有字符或小数点就报错）
Byte.parseByte("33")
Short.parseShort("44")
Long.parseLong("55")
Float.parseFloat("99" 或 "99.8")
Double.parseDouble("99" 或 "99.8")
Long.toString()                   转换成字符串
2.	Convert float to other types
Float a= new Float("33" 或 "33.8" 或 33 或 33.8)        同基本类型数据用法
a.doubleValue()     转double类型
a.intValue()         转int类型
3.	Convert double to other types
Double a= new Double("33" 或 "33.8" 或 33 或 33.8)    同基本类型数据用法
a.intValue()         转int类型
4.	Convert enum to string
String.valueOf( RED )
Operator
Reference:
Guide to the Volatile Keyword in Java
https://www.baeldung.com/java-volatile
Statement Keyword
out
out: for(String val : arr ){ }          值遍历  数组/Map/Set
assert
assert listFiles != null;    断言不为空
continue
continue out;            Jump out of the specified "for" code block
break
break out;               Jump out of the specified "if" code block
switch
cal = switch (caltype) {
    case "buddhist" -> new BuddhistCalendar(zone, aLocale);
    case "japanese" -> new JapaneseImperialCalendar(zone, aLocale);
    case "gregory"  -> new GregorianCalendar(zone, aLocale);
    default         -> null;
};
Synchronization Keyword
Reference:
https://www.baeldung.com/java-volatile

volatile
1.	Shared Multiprocessor Architecture
Processors are responsible for executing program instructions. Therefore, they must retrieve the program instructions and required data from RAM.

As CPUs can carry many instructions per second, fetching from RAM isn’t ideal for them.
To improve this situation, processors use tricks like Out of Order Execution, Branch Prediction, Speculative Execution, and Caching.

This is where the following memory hierarchy comes into play:


As different cores execute more instructions and manipulate more data, they fill their caches with more relevant data and instructions.
This will improve the overall performance at the expense of introducing cache coherence challenges.
We should think twice about what happens when one thread updates a cached value.
2.	Cache Coherence Challenges
To expand more on cache coherence, we’ll borrow an example from the book Java Concurrency in Practice:
public class TaskRunner {
private static int number;
private static boolean ready;
private static class Reader extends Thread {
@Override public void run() {
while (!ready) {
Thread.yield();
}
System.out.println(number);
}
}
public static void main(String[] args) {
new Reader().start();
number = 42;
ready = true;
}
}
The TaskRunner class maintains two simple variables.
Its main method creates another thread that spins on the ready variable as long as it’s false.
When the variable becomes true, the thread prints the number variable.

Many may expect this program to print 42 after a short delay;
however, the delay may be much longer. It may even hang forever or print zero.
The cause of these anomalies is the lack of proper memory visibility and reordering.
Let’s evaluate them in more detail.
1)	Memory Visibility
This simple example has two application threads: the main and the reader threads. Let’s imagine a scenario in which the OS schedules those threads on two different CPU cores, where:
•	The main thread has its copy of ready and number variables in its core cache.
•	The reader thread ends up with its copies, too.
•	The main thread updates the cached values.
Most modern processors write requests that won’t be applied right after they’re issued.
Processors tend to queue those writes in a special write buffer.
After a while, they’ll apply those writes to the main memory all at once.

With all that being said, when the main thread updates the number and ready variables,
there’s no guarantee about what the reader thread may see.
In other words, the reader thread may immediately see the updated value, with some delay, or never at all.

This memory visibility may cause liveness issues in programs relying on visibility.
2)	Reordering
To make matters even worse, the reader thread may see those writes in an order other than the actual program order. For instance, since we first update the number variable:
public static void main(String[] args) {
new Reader().start();
number = 42;
ready = true;
}
We may expect the reader thread to print 42. But it’s actually possible to see zero as the printed value.
Reordering is an optimization technique for performance improvements. Interestingly, different components may apply this optimization:
•	The processor may flush its write buffer in an order other than the program order.
•	The processor may apply an out-of-order execution technique. (Instructions may be executed out of order.)
•	The JIT compiler may optimize via reordering.
3.	volatile Memory Order
We can use volatile to tackle the issues with Cache Coherence.
To ensure that updates to variables propagate predictably to other threads, we should apply the volatile modifier to those variables.

This way, we can communicate with runtime and processor to not reorder any instruction involving the volatile variable.
Also, processors understand that they should immediately flush any updates to these variables.
public class TaskRunner {

    private volatile static int number;
    private volatile static boolean ready;

    // same as before
}

This way, we communicate with runtime and processor to not reorder any instruction involving the volatile variable.
Also, processors understand that they should immediately flush any updates to these variables.

4.	Happens-Before Ordering
The memory visibility effects of volatile variables extend beyond the volatile variables themselves.

To make matters more concrete, suppose thread A writes to a volatile variable, and then thread B reads the same volatile variable.
In such cases, the values that were visible to A before writing the volatile variable will be visible to B after reading the volatile variable:


Technically, any write to a volatile field happens-before every subsequent read of the same field. This is the volatile variable rule of the Java Memory Model (JMM).
5.	Piggybacking
Because of the strength of the happens-before memory ordering, sometimes we can piggyback on the visibility properties of another volatile variable.
For instance, in our particular example, we just need to mark the ready variable as volatile:
public class TaskRunner {

    private static int number; // not volatile
    private volatile static boolean ready;

    // same as before
}

Anything prior to writing true to the ready variable is visible to anything after reading the ready variable.
Therefore, the number variable piggybacks on the memory visibility enforced by the ready variable.
Simply put, even though it’s not a volatile variable, it’s exhibiting a volatile behaviour.
6.	How to make using volatile keyword safe in java?
•	Avoid using i++ to update volatile variables, as these are two difference operations.
•	Volatile for Visibility, Not Thread Safety:
The volatile keyword in Java guarantees that all threads see the latest updated value of the variable.
This prevents issues like one thread reading an outdated value from its CPU cache.

However, volatile doesn't make the addition operation itself atomic (indivisible).
If multiple threads try to add to the same volatile variable concurrently, a race condition can occur.

synchronized
1.	Synchronized Instance Methods
The synchronization method locks all the code in the method. The lock object is this and cannot be specified manually.
public synchronized void synchronisedCalculate() {
    setSum(getSum() + 1);
}
2.	Synchronized Static Methods
The synchronization method locks all the code in the method. The lock object is the Class object of the current class and cannot be specified manually.
public static synchronized void syncStaticCalculate() {
     staticSum = staticSum + 1;
 }
3.	Synchronized Blocks Within Methods
The synchronization method locks all the code in the code block. we can manually specify the lock object.
public void performSynchronisedTask() {
    synchronized (this) {
        setCount(getCount()+1);
    }
}

public static void performStaticSyncTask(){
    synchronized (SynchronisedBlocks.class) {
        setStaticCount(getStaticCount() + 1);
    }
}
4.	how is the synchronized keyword implemented in java?
The synchronized keyword uses CAS to implement a lock. When a thread acquires a lock on an object, it uses CAS to set the lock's state to locked.
If the lock is already locked, the thread will wait until the lock is released. Once the thread has acquired the lock, it can safely access the object's state.
When the thread is finished with the object, it releases the lock using CAS.

(The locking information is stored in object header.)
(the synchronized keyword in Java uses bias locking and lightweight locking to optimize locking.)

The monitorenter and monitorexit bytecode instructions are used to implement the synchronized keyword.
When a thread enters a synchronized block, it executes the monitorenter instruction.
This instruction attempts to acquire the lock on the monitor object.
If the lock is already held by another thread, the current thread is blocked until the lock is released.

Class Keyword
sealed
The release of Java SE 17 introduces sealed classes (JEP 409).
This feature is about enabling more fine-grained inheritance control in Java. Sealing allows classes and interfaces to define their permitted subtypes.
In other words, a class or an interface can now define which classes can implement or extend it. It is a useful feature for domain modeling and increasing the security of libraries.

1.	Sealed Interfaces
To seal an interface, we can apply the sealed modifier to its declaration. The permits clause then specifies the classes that are permitted to implement the sealed interface:
public sealed interface Service permits Car, Truck {
    int getMaxServiceIntervalInMonths();
    default int getMaxDistanceBetweenServicesInKilometers() {
        return 100000;
    }
}
2.	Sealed Classes
Similar to interfaces, we can seal classes by applying the same sealed modifier. The permits clause should be defined after any extends or implements clauses:
public abstract sealed class Vehicle permits Car, Truck {

    protected final String registrationNumber;

    public Vehicle(String registrationNumber) {
        this.registrationNumber = registrationNumber;
    }

    public String getRegistrationNumber() {
        return registrationNumber;
    }

}
A permitted subclass must define a modifier. It may be declared final to prevent any further extensions ( the subclass should be sealed or non-sealed or final ):
public final class Truck extends Vehicle implements Service {

    private final int loadCapacity;

    public Truck(int loadCapacity, String registrationNumber) {
        super(registrationNumber);
        this.loadCapacity = loadCapacity;
    }

    public int getLoadCapacity() {
        return loadCapacity;
    }

    @Override
    public int getMaxServiceIntervalInMonths() {
        return 18;
    }

}

Java = Features
Class
Access Modifiers
Class access modifiers
class Person{}              友好类（只能当前包中使用）
public class person{}  公有类
private class Person{}  私有类（其他类不可使用）
Constructor access modifiers
Person(){};              友好成员（当前包中实例化）
public Person(){}    公有构造 （可外部实例化）
private Person(){};  私有成员（其他类不可实例化）
Field access modifiers
float a;                      友好成员（只能当前包中使用）
public float a;            公有成员
protected float a;     保护成员（当前包中使用或子类中使用，子类可以覆写为public或private）
private float a;          私有成员（其他类不可使用）
Definition
public final class Person<T, Y> extends Father<T, Y, String>  {
JVM 只有在第一次使用类时才加载这个类和其内部成员
extends       接收public和protected成员，不支持多继承（先调用父类构造函数）
                   You can directly specify parent generic type.
final            类不能被继承

public Person (double a,  int b)  {          构造函数（没有返回值，当为private时，只能在内部静态方法里new，而不能在外部new）
 super()                                                       call the parent class constructor, and it must be on the first line and in the subclass constructor.
}

  public int a, b=99;                                      普通成员
  public T xxx;                                               泛型类成员，不能在内部被初始化，只能接收值
  public Car xxx=new Car();                          类成员（在父类Father内部定义初始化Person成员会造成死循环）
  public static float money=99.9F;                 静态成员（可用类名访问Person.c）

  static{                                          静态代码块
        System.out.println("base static");
  }

  private final native void func (double a, int b, int ...va) throws SbbException, ApiException {     成员函数：可重载，可缺省，不支持默认参数值
native    Java平台有个用户和本地C代码进行互操作的API，称为Java Native Interface (Java本地接口)
final      方法不可被重写
throws    方法内部可能抛出的异常，并不一定会发生这些异常。由调用者处理
throw     手动抛出一个异常。由调用者处理
子类方法重写：重写不允许新增throw
                       重写返回值  必须和父类型一致，或者父类型的子类
动态参数数组va 必须在最后，可不传入va参数, va可以接受int[]类型的参数，va直接变成参数数组  // test(2, new int[]{1,2,3,4})       va= new int[]{1,2,3,4}
       this.b+=1;   b+=1;  sd+=1;                  可以直接修改内部成员   或者继承过来的成员（可以省略this访问内部成员）
       super.b;    super.sd+=1;    super.func();     重名覆盖会隐藏父类变量和函数，父类指针 可访问隐藏的变量和函数（可修改父类修改静态成员的值，普通成员可以修改，但不会影响到父类初始化）
       throw new ApiException()
  }



public static class FunctionClass implements Function<Integer, String> {     静态类函数（泛型指定参数类型，返回值类型  ）   //  new ShippingService. FunctionClass().apply(s)
    public String apply(Integer t) {
       return Integer.toString(t*t);
    }
}


public interface Car{         内部接口
   public void print()
}

public class Car{              内部类：只能当前类使用，能访问外部类的所有成员，但不能再使用其他类（如果是静态内部类static class，则只能访问外部类的静态成员）    // Person.Car car = new Person.Car();
   public void print() {        静态内部类可以有静态成员。而非静态内部类不能有静态成员
       System.out.println(a);
   }
  }

public void test(final int c) {
    final int d = 1;
    class Car {                 局部内部类（定义在方法中的类）：如果一个类只在某个方法中使用，则可以考虑使用局部类
       public void print() {
           System.out.println(a);
       }
    }
}

finalize 是⼀个⽅法,当垃圾回收器确定不存在对该对象的更多引⽤时，由对象的垃圾回收器调⽤此⽅法。
}


public abstract class Father<P, S, W extends xxclass & xxinterface & xxinterface> {      抽象类（必须包含至少一个抽象方法，子类必须重写抽象方法）
    int a,b=99;                                                                      包含普通类的所有功能，继承
    public abstract void perfunc (double a, int b, int ...va) throws RuntimeException;     抽象方法（限制参数返回值，和抛出的异常）
}
Creation
Father fa = new Person(){  int func (double a, int b, int ...va){return 222;}  }          匿名类创建，可以在内部临时重写方法，接收的参数va变成int[]类型（适用于：函数传参，使用 new 来生成一个对象的引用，继承一个父类或抽象父类，或者实现一个接口）
Father fa =per   Father fa=(Father)null                                                                  强制转换创建

List<String> lista =new ArrayList<String>( 100 ){{     初始化创建
    add("a");
    add("b");
}};


Father fa=new Person();      Father fa=per                    多态创建，父类定义 可以接收 子类对象，在序列化过程中，接受的子类对象额外字段也会包含在其中（但是强转还是  高到低的规则）
Person per= (Person) fa                                                 参数强转，因为父类定义可以接收子类实例，所以使用时需要强转
Person<Animal> per = new Person<>();                       泛型创建：类至少要指定一个类型，可省略构造函数的泛型A

Class clazz=Class.forName("reflection.Person");  Person per=(Person) clazz.newInstance();                                                newInstane 方法创建对象
Constructor cons=clazz.getDeclaredConstructor(String.class,String.class,int.class);    Person per=(Person) cons.newInstance("李四","男",20);   获取构造方法并创建对象
Freatures
泛型：优化java5之前object作为动态参数，get获取时必须强制转换的缺点 （泛型可以直接用传入的类型接收返回的类型，不指定泛型类型时，获取时还是要强制转换）
方法泛型：    public <T extends SomeClassOrInterface & interface1 & interface2 & interface3> T func(T t){ }         extends可以指定继承类，也可以指定实现接口
public static < E > void func( E[] inputArray ){
    for ( E element : inputArray ){
        System.out.printf( "%s ", element );
    }
}
类泛型：      public class Demo<T extends Comparable & Serializable> {   T类型就可以用Comparable声明的方法和Seriablizable所拥有的特性了
     private T t;
     public void add(T t) {
         this.t = t;
     }
     public T get() {
         return t;
     }
}
   通配符泛型：  <? extends T>        表示该通配符所代表的类型是 T 类型的子类（向上限制）      // T extends的语法只能在方法前的泛型声明使用
                                                F extends Enum<F>    表示枚举类型
                        <? super Double>     表示该通配符所代表的类型是Double类型的父类（向下限制）

Wildcard types are a more powerful mechanism than object types, which can match more types, such as inheritance and implementation relationships.
   类型通配符?    类型通配符一般是使用 ? 代替具体的类型参数，单独使用可以理解成Object，有限制会缩小范围。

   类型擦除：泛型会被编译器在编译的时候去掉，生成的字节码文件中是不包含泛型中的类型信息的。// List<Object> ==> List

对象拷贝：
直接赋值： 复制的是引用地址，两个变量都指向的是同一个对象。
浅拷贝：创建一个新对象，然后将目标对象的非静态字段复制到该新对象，如果字段是值类型的， 那么对该字段执行复制；
        如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象
深拷贝：深拷贝不仅复制目标对象本身，而且复制对象包含的 引用指向的所有对象。
序列化：深拷贝的一种实现方式，常常可以先使对象实现 Serializable 接口，然后把对象写到一个流里，再从流里读出来，便可以重建对象。
Object Structrue
Reference:
https://shipilev.net/jvm/objects-inside-out/

Moving on to the actual object structure. Let us start from the very basic example of java.lang.Object. JOL would print this:
(some space will be lost, because JVM requires that the memory size occupied by a Java object should be a multiple of 8 bytes)
$ jdk8-64/java -jar jol-cli.jar internals java.lang.Object
# Running 64-bit HotSpot VM.
# Using compressed oop with 3-bit shift.
# Using compressed klass with 3-bit shift.

Instantiated the sample instance via default constructor.

java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                  VALUE
      0     4        (object header)              05 00 00 00 # Mark word
      4     4        (object header)              00 00 00 00 # Mark word
      8     4        (object header)              00 10 00 00 # (not mark word)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

Arrays come with another little piece of metadata: array length. Since the object type only encodes the array element type, we need to store the array length somewhere else.
$ jdk8-64/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_25_ArrayAlignment
# Running 64-bit HotSpot VM.
# Using compressed oop with 3-bit shift.
# Using compressed klass with 3-bit shift.

[J object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                  VALUE
      0     4        (object header)              01 00 00 00  # Mark word
      4     4        (object header)              00 00 00 00  # Mark word
      8     4        (object header)              d8 0c 00 00  # Class word
     12     4        (object header)              00 00 00 00  # Array length
     16     0   long [J.<elements>                N/A
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
Object Header
1.	What does the object header consist of?
the object header consists of two parts: mark word and class word.
Class word carries the information about the object’s type: it links to the native structure that describes the class.
We will talk about that part in the next section. The rest of the metadata is carried in the mark word.
There are several uses for the mark word:
Storing the metadata (forwarding and object age) for moving GCs.
Storing the identity hash code.
Storing the locking information.
Note that every single object out there has to have a mark word,
because it handles the things common to every Java object.
This is also why it takes the very first slot in the object internal structure: VM needs to access it very fast on the time-sensitive code paths, for example STW GC.
Understanding the use cases for mark word highlights the lower boundaries for the space it takes.
监视器
Lock Record：在代码进入同步块的时候，JVM检测到当前对象是无锁状态，则会在当前线程的栈帧中创建一个名为LOCKRECOD空间（包含一份markword的拷贝 和 锁对象的引用）

拷贝成功后，虚拟机将使用CAS操作尝试将锁对象的Mark Word更新为指向Lock Record的指针，并将线程栈帧中的Lock Record里的owner指针指向Object的 Mark Word。
如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。

如果这个更新操作失败了，虚拟机首先会检查锁对象的Mark Word是否指向当前线程的栈帧，
       如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。
       如果不是，则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。
Monitor：Monitor与每个java对象相关联，即每个java对象都有一个Monitor与之对应。
Monitor是线程私有的数据结构。每个线程都有一个可用的monitor record列表。同时还有一个全局的可用列表。
每一个被锁住的对象都会和monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用
任意线程对Object（Object由synchronized保护）的访问，首先要获得 Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。
当访问获得了Object锁的线程释放了锁，则会唤醒阻塞在同步队列中的线程，使其重新 尝试对监视器的获取。

Monitor的基本结构：
Owner字段     初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL。
EntryQ字段     关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。
RcThis字段      表示blocked或waiting在该monitor record上的所有线程的个数。
Nest字段       用来实现重入锁的计数。
HashCode字段   保存从对象头拷贝过来的HashCode值（可能还包含GC age）。
Candidate字段   用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降；
Candidate只有两种可能的值：0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。
线程状态
当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程
Contention List：   竞争队列。所有请求锁的线程将被首先放置到该竞争队列（新请求锁的线程将首先被加入到ContentionList中，当某个拥有锁的线程调用unlock之后，如果发现EntryList为空，则从ContentionList中移动线程到EntryList。）
Entry List：         候选队列。 	Contention List中那些有资格成为候选人的线程被移到Entry List中
Wait Set：         等待队列。  那些调用wait方法被阻塞的线程被放置到Wait Set中
OnDeck：          竞争线程。 任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck
Owner：     获得锁的线程
!Owner：     释放锁的线程

java对象访问
对象访问：          最简单的对象访问，也会涉及到 Java 栈，java 堆， 方法区。
2. 方法体中定义变量时，“Object obj” 定义部分会作为一个引用数据存储到Java 栈的局部变量表中，”new Object();“   new语句部分会创建一个实例数据值存储到Java 堆中。
3. 创建的对象实例在内存中的长度是不固定的。另外，在JAVA 堆中还必须包含能查找到此对象内存数据的地址信息，而对象类型数据则存储在方法区中。
           由于 引用 类型在 Java 虚拟机中规定了指向对象的引用，但并没有规定这个引用要通过哪种方式去定位，以及访问到 Java 堆中的对象的具体位置，因此虚拟机实现的对象访问方式会有所不同。
  主流的访问方式有两种：句柄访问方式和直接指针。
1)	如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是句柄池的地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。


2)	如果通过直接指针方式访问，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，一般存放在实例数据中，reference 中直接存储的就是对象的地址

3)	两种方式各有优势，句柄访问方式最大的好处是 reference 中存放的是稳定的句柄地址， 在对象被移动时，只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。
而 直接指针访问的最大优势是速度快，它节省了一次指针定位的开销，由于对象访问在 Java 中 非常频繁，一次这类开销积少成多后也是一项非常可观的成本。
      具体的访问方式都是有虚拟机指定的，虚拟机 Sun HotSpot 使用的是直接指针方式，不过 从整个软件开发的范围来看，各种语言和框架使用句柄访问方式的情况十分常见。


Exception
try{
     throw new ApiException();        // 遇到异常直接跳转到下方匹配异常的类型
} catch( Exception e ){
    e.getMessage();
} catch( ApiException e){
     e.getMessage();
} finally {
     info.log('aa')
}


try (OutputStream out = new FileOutputStream("");OutputStream out2 = new FileOutputStream("")){  // 只要实现的自动关闭接口(Closeable)的类都可以在try结构体上定义，java会自动帮我们关闭，及时在发生异常的情况下也会。
	// ...操作流代码
} catch (Exception e) {
	throw e;
}
Package
package a;        package a.b;          声明包
import a.b.*;      import a.b.Tom;       导入包， * 代表全部的类【导入类名相同时，用包前缀指明：    a.b.Tom suibian=new a.b.Tom();  】
Interface
public interface FatherFace<T, Z>{
    void fatherFunc(double size);
    default void defaultFunc(){}
}
public interface MotherFace{
    void motherFunc(double value);
    default void defaultFunc(){}
}
public interface SonFace<T, Z> extends FatherFace<T, Z> {          接口，实现类必须实现接口全部的方法，可继承其他接口（抽象类只需要有一个抽象方法就行了）
    int CC=77;                       接口常量，不可继承，只能通过SonFace.CC访问（接口中的变量默认为public static final，也就是静态常量）
    void begin(long size);      接口方法，必须在实现类中实现，接口中的方法默认为public abstract（可继承，与父类方法冲突时子类优先）
    default void end() {}         接口默认方法（可继承，与父类冲突时覆盖父类，与其他接口冲突时必须重新实现）

    interface SonInsideFace extends SonFace<Double, Integer>, MotherFace {     特殊泛型  自继承
    	@Override                                        覆写标记，表示覆盖之前接口的方法
    	default void accept(Double i) {         给不同情况的泛型，提供默认方法
    	}
    	@Override
    	default void defaultFunc() {
    	}
    }
}


class MyClass{
  static List<String> method(BiFunction<Integer, String, List<String>> fn){
    return fn.apply(5, "FooBar");
  }
}

List<String> lStr = MyClass.method((a, b) -> a+b );


FunctionalInterface
@FunctionalInterface
public interface XXFunc{
    String apply(String b);
}


@FunctionalInterface
public interface XXFunc<T,R>{                      函数式接口，可以缩写成Lambda表达式，T，R表示参数和返回值的类型 （只包含一个抽象方法的接口）
																			 //  XXFunc<String, String>  test      == >   String aa =  test.apply("??")
    R apply(T b);
}

public final <R> Stream<R> map(Function<Integer,  ? extends R> mapper) {    Lambda作为参数
    return mapper.aply(1, 2);
}

使用——————————————————————————————————————————————————————————————————————————
class Person implements BB, AA<Person, Car> {        可以实现多个接口，接口实现至少要指定一个泛型
     public void show(Person b){} }
}

Integer result = AA.PROCESS_CODE          作为固定常量使用
Enum
Default Method
values()  获取所有枚举值
name()  获取枚举名称，也用于序列化
valueOf(String str)       根据获取枚举名称 获取枚举对象，不存在会报错
toString()         获取枚举名称
Decompile
public enum T {
	SPRING,SUMMER,AUTUMN,WINTER;
}

public final class T extends Enum
{
	//省略部分内容
	public static final T SPRING;
	public static final T SUMMER;
	public static final T AUTUMN;
	public static final T WINTER;
	private static final T ENUM$VALUES[];      枚举类型和泛型 < 228
	static
	{
		SPRING = new T("SPRING", 0);
		SUMMER = new T("SUMMER", 1);
		AUTUMN = new T("AUTUMN", 2);
		WINTER = new T("WINTER", 3);
		ENUM$VALUES = (new T[] {
		SPRING, SUMMER, AUTUMN, WINTER
	});
	}
}
StreamOpFlag
@AllArgsConstructor
@Getter
public enum StreamOpFlag {
    DISTINCT(   0,   set(Type.SPLITERATOR).set(Type.STREAM). setAndClear(Type.OP)   ),
    SHORT_CIRCUIT(  12,    set(Type.OP). set(Type.TERMINAL_OP)   );                  使用构造构建成员


    enum Type {                          内部枚举（不需要添加@Getter和@AllArgsConstructor）
        SPLITERATOR,
        STREAM,
        OP,
        TERMINAL_OP,
        UPSTREAM_TERMINAL_OP
    }

    private static class MaskBuilder {          内部类
        final Map<Type, Integer> map;
        MaskBuilder(Map<Type, Integer> map) {
            this.map = map;
        }
        Map<Type, Integer> build() {
            for (Type t : Type.values()) {        枚举 自带获取所有值的内部函数
                map.putIfAbsent(t, 0b00);
            }
            return map;
        }
    }

}
ResultCode
@AllArgsConstructor
@Getter
public enum ResultCode {
    OTHER("AA","BB","CC", 233),       字段可自定义
    SUCCESS(0,"操作成功"),             枚举变量未赋初值，其默认的值是0,后面的依次加1
    REQ_ERROR(101, "请求异常");

    public final int CODE;             真实值的名称（不定义的话从0开始逐渐递增）
    public final String MESSAGE;      命名

   public ResultCodeModel getResultCodeModel () {
        ResultCodeModel s = new ResultCodeModel();
        BeanUtils.copyProperties(this, s);
        return s;
    }
}
ResultCode.PARAMETER_ERROR.CODE            枚举对象成员值

ResultCode.valueOf("OTHER ");  根据枚举名称  获取枚举对象，而不是private value字段值     【找不到异常： IllegalArgumentException 】
ResultCode.values();                              返回一个装有该枚举对象 的一维数组    val.getCODE()
AccountType.REAL.equals("REAL")     永远为false，因为枚举也是对象
Serialize
Enums.getIfPresent( AccountTypeEnum.class ).orNull()
@JsonCreator
public static AccountType fromValue( String text){
    for( AccountType var : AccountType.values() ){
         if( String.valueOf(var.value).equals(text) ){
              return var;
         }
    }
    return null;
}

@JsonValue
public String toString(){
     return String.valueOf(value);
}
Serialization
持久化对象：对象序列化可以在JVM停止运行之后保存为一组字节数组到磁盘中，并在将来再将这些字节数组 组装成对象。（对象序列化保存的是对象的”状态”，不会关注类中的静态变量）
远程对象传输
         除了在持久化对象时会用到对象序列化之外，当使用 RMI（远程方法调用），或在网络中传递对象时， 都会用到对象序列化。
实现序列化
a)	Serializable：   实现 java.io.Serializable 接口，那么该类就可以被序列化。（要想将父类对象也序列化，就需要让父类也实现 Serializable 接口）
在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略，可以对一些密码字段在序列化时进行加密，解密再用对应的密钥解密（对于Serializable，如果没有重写 writeObject和readObject，则调用默认的方法）
b)	ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化
序列化 ID
      private static final long serialVersionUID
      虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）
transient关键字
在变量声明前加上 transient 关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。


Java = java.base
java.awt
BorderLayout
package java.awt;
public class BorderLayout implements LayoutManager2,   java.io.Serializable  边界布局（东西南北中）
CardLayout
package java.awt;
public class CardLayout implements LayoutManager2, Serializable     卡片布局，如同一叠牌，每个牌对应一个组件，但每次只能显示其中的一张牌。适用于在一个空间中防止多个组件的情况
Color
package java.awt;
public class Color implements Paint, java.io.Serializable
public Color(int r, int g, int b)
public Color(int r, int g, int b, int a)
Container
package java.awt;
public class Container extends Component  组件容器
public Component add(Component comp)       添加一个组件
Dimension
package java.awt;
public class Dimension extends Dimension2D implements java.io.Serializable    维度大小
public Dimension(int width, int height)   初始化宽高
Insets
package java.awt;
public class Insets implements Cloneable, java.io.Serializable   边框设置
public Insets(int top, int left, int bottom, int right)    // new Insets(0, 0,  AbstractLayout.DEFAULT_VGAP,  AbstractLayout.DEFAULT_HGAP )
FlowLayout
package java.awt;
public class FlowLayout implements LayoutManager, java.io.Serializable    组件按照加入的先后顺序按照设置的对齐方式从左向右排列，一行排满到下一行开始继续排列
GridLayout
package java.awt;
public class GridLayout implements LayoutManager, java.io.Serializable   网格布局，容器的空间划分成M×N列的网格区域,每个区域只能放置一个组件。
GridBagLayout
package java.awt;
public class GridBagLayout implements LayoutManager2, java.io.Serializable
GridBagConstraints
package java.awt;
public class GridBagConstraints implements Cloneable, java.io.Serializable
public static final int HORIZONTAL = 2;
Robot
package java.awt;
public class Robot

public synchronized void mouseMove(int x, int y)
public synchronized void keyPress(int keycode)
public synchronized void keyRelease(int keycode)
public synchronized void mousePress(int buttons)
// Press the mouse button.
robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);
// Release the mouse button.
robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);
public synchronized void mouseRelease(int buttons)
java.beans
PropertyDescriptor
package java.beans;
public class PropertyDescriptor extends FeatureDescriptor         属性修饰器

public synchronized Method getWriteMethod()      获取set方法
public synchronized Method getReadMethod()      获取get方法
public synchronized Class<?> getPropertyType()    获取属性类型（会丢失泛型class）  // class java.lang.Long    float
FeatureDescriptor
package java.beans;
public class FeatureDescriptor       特性修饰器

public String getName()       获取属性/方法/事件  名称
java.io
Serializable
package java.io;
public interface Serializable      可序列化的，通用数据保存、读取和传输的接口，通过实现Serializable接口的类，该类所实例化的对象的状态信息在内存中可以持久化保存、传输，该过程称为序列化。

private static final long serialVersionUID=1L;
serialVersionUID在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类，如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException
序列号如果我们自己没有定义，那么虚拟机会根据类中的信息会自动地计算出一个序列号（可以手动给一个值就不会变了）
如果我们修改了类中的信息，那么虚拟机会再次计算出一个序列号,
把user对象序列化到本地..---5824992206458892149
修改了javabean类，导致类中的序列号变更4900133124572371851
把文件中的对象读到内存，读取出的序列号和类中的序列号不一致了

private transient String password    给成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程

在父类没有实现 Serializable 接口时，虚拟机是不会序列化父对象的

序列化使用——————————————————————————————————————————————————————————
        File file = new File("person.txt");
        //序列化持久化对象
        ObjectOutputStream out =
            new ObjectOutputStream(new FileOutputStream(file));
        Person person = new Person("Peter", 27);
        out.writeObject(person);
        out.close();

        //反序列化，并得到对象
        ObjectInputStream in =
            new ObjectInputStream(new FileInputStream(file));
        // 没有强制转换到Person类型
        Object newPerson = in.readObject();
        in.close();
        System.out.println(newPerson);
Externalizable
package java.io;
public interface Externalizable extends java.io.Serializable
void writeExternal(ObjectOutput out) throws IOException;
void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
File
File
public class File       文件和目录可以通过File封装成对象，返回对象仅仅是一个路径名，它可以是存在的，也可以是不存在的。

public File(String pathname)                通过将给定的路径名字符串转换为抽象路径名来创建新的File实例
private File(String child, File parent)          自动拼接父子路径，创建新的File实例
public File(String parent, String child)         自动拼接路径，创建新的File实例


public static final String separator     在Windows中，斜杠用的是正斜杠 \，如C:\Program Files\image
                                      在Linux中，斜杠用的是反斜杠 /，如usr/local/nginx

public static File createTempFile(String prefix, String suffix) throws IOException       在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。
public boolean createNewFile()     当前目录创建文件，前方目录不存在不能创建（不管调用者有没有后缀名，只能创建文件）
public boolean mkdir()             创建一个单级文件夹
public boolean mkdirs()            创建一个多级文件夹
public boolean delete()             删除当前文件或目录（包含子文件删除失败）
public void deleteOnExit()

public long length()               文件长度（单位字节）  //通常使用(int) file.length() + 1作为BufferedReader的mark参数
public String getAbsolutePath()     文件绝对路径
public String getParent()           文件父目录
public String getName()            获取文件或目录名
public String getCanonicalPath() throws IOException    此路径方法返回绝对唯一的标准规范路径名        //   /Users/martin6699/../martin6699/test.txt  ==>    /Users/martin6699/test.txt

public boolean canRead()          判断文件是否可读
public boolean canWrite()          判断文件是否可写入
public boolean exists()             文件是否存在
public boolean isFile()            是否是一个普通文件，而不是目录
public boolean isDirectory()      是否是目录
public boolean isHidden()         是否是隐藏文件
public long lastModified()        文件最后修改时间

public String[] list()                        字符串形式返回目录下全部文件
public String[] list(FilenameFilter filter)      用该接口的子类对象（自动传入目录和全部文件 返回筛选的文件）
public File[] listFiles()                                    File对象形式放回目录下全部文件和目录 （当调用者不存在，或是一个文件，或需要权限时，返回null ）
public File[] listFiles(FilenameFilter filter)     File对象形式返回目录下指定类型所有文件和目录
PrintStream
package java.io;
public class PrintStream extends FilterOutputStream    打印流
    implements Appendable, Closeable
InputStream
package java.io;
public abstract class InputStream implements Closeable     输入流

public boolean markSupported()    是否支持mark或者reset方法， 默认返回false


public abstract int read() throws IOException;
Reads the next byte of data from the input stream.
The value byte is returned as an int in the range 0 to 255. If no byte is available because the end of the stream has been reached, the value -1 is returned.
This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.
A subclass must provide an implementation of this method.

FilterInputStream
package java.io;
public class FilterInputStream extends InputStream         A FilterInputStream contains some other input stream, which it uses as its basic source of data,
possibly transforming the data along the way or providing additional functionality.

FilterInputStream is an abstract decorator.
protected volatile InputStream in;
protected FilterInputStream(InputStream in)
public int read(byte b[]) throws IOException
Character Stream
FileReader
public class FileReader文件字符输入流 （java文件，txt文件）
                                            字节流把文本文件中的中文读取到内存中有可能出现乱码，写入时也可能出现乱码
public FileReader(String fileName)
public FileReader(File file)

public int read(java.nio.CharBuffer target)
public int read()
public int read(char cbuf[])         还是读取，但是是一次读取多个字符他把读到的字符都存入到chars数组，返回值表示本次读到了多少个字符。
public int read(char cbuf[], int off, int len)
FileWriter
public class FileWriter                       文件字符输出流，打开就会清空文件
                                             如果文件不存在,就创建。如果文件存在就清空（父级路径不存在报错）

public FileWriter(String fileName)
public FileWriter(String fileName, boolean append)    append为true表示追加，false则清空原有文件
public FileWriter(File file)
public FileWriter(File file, boolean append)

public void write(int c)                   写入一个字符（实际写出的是整数在码表上对应的字母）
public void write(char cbuf[])
public void write(char cbuf[], int off, int len)
public void write(String str)              写出字符串数据，是把字符串本身原样写出
public void write(String str, int off, int len)
public void flush()                      刷新流,还可以继续写数据（flush将数据真正写入文件）
public void close()                      关闭流,释放资源,但是在关闭之前会先刷新流。一旦关闭,就不能再写数据
StringReader
package java.io;
public class StringReader extends Reader        字符串输入流、其本质就是字符串
public StringReader(String s)                             利用字符串创建字符输入流
public int read() throws IOException                                               从流中读取单个字符，若到文件末尾则返回-1
public int read(char cbuf[], int off, int len) throws IOException      读取最多len个字节到目标数组中，从目标数组的下标off开始存储，返回实际读取的字节数
StringWriter
public class StringWriter extends Writer    字符串输出流，基于StringBuffer，可以用来构建字符串
Byte Stream
FileInputStream
package java.io;
public class FileInputStream      字节输入流（音频视频图片）
                                 因为字节流一次读一个字节,而不管GBK还是UTF-8一个中文都是多个字节,用字节流每次只能读其中的一部分,所以就会出现乱码问题。
打开大文件
打开大文件的关键在于，不能直接将文件中的数据全部读取到内存中，以免引发OOM。要使用较小的内存空间来解决问题。（每次读取文件中的一部分内容，分多次处理这个文件）
如果我们打开的是文本文件，期望读取甚至分析该文件中的内容，则可以采用java.util.Scanner来逐行读取文件的内容。在Scanner遍历文件的过程中，每处理一行之后，我们都要丢弃对该行的引用，以节约内存。
如果我们打开的是字节文件，期望拷贝或者搬运该文件中的内容，则可以采用缓冲流或NIO。每次利用缓冲区处理文件中的一小段数据，这样在处理过程中使用的内存空间便是很有限的，不会造成内存溢出的问题。

public FileInputStream(String name)
public FileInputStream(File file)


public int read()                         读取 下一个字节/字符
public int read(byte b[])                 读取字节/字符到数组中（返回的是读入缓冲区的总字节数,也就是实际的读取字节个数）
public int read(byte b[], int off, int len)   读取字节/字符到数组中从索引off存到len   （接近末尾数组可能不读满，末尾返回-1）
public void close() throws IOException    关闭流（打开就要关闭）
FileOutputStream
public class FileOutputStream   字节输出流（音频视频图片）

public FileOutputStream(String name)
public FileOutputStream(File file)
public FileOutputStream(String name, boolean append)      创建文件输出流，如果第二个参数为true，追加内容

public void write(int b)                     一次写一个字节数据（实际上写到文件中的,是这个整数在码表中对应的那个字符）
public void write(byte b[])                  一次写一个字节数组数据
public void write(byte b[], int off, int len)     一次写一个字节数组的部分数据
public void flush()      写入后清空流（强制将所有缓冲的输出字节被写出）
public void close()      关闭流（使用finally保证一定执行）
ByteArrayInputStream
package java.io;
public class ByteArrayInputStream extends InputStream
ByteArrayOutputStream
package java.io;
public class ByteArrayOutputStream extends OutputStream  无需关闭这个流，此类中的方法在关闭此流后仍可被调用（可以使用IOUtils.copy开背inputStream到byteArrayOutputStream）
Decorator Stream
BufferedReader
package java.io;
public class BufferedReader extends Reader   字符缓冲输入流（只需要关闭最外层的缓冲流就可以了）


public BufferedReader(Reader in, int sz)      创建一个新的缓冲字符输出流,使用给定大小的输出缓冲区
public BufferedReader(Reader in)            创建一个新的缓冲字符输出流, 使用默认大小的输出缓冲区

String readLine(boolean ignoreLF)           读取文本行
public void mark(int readAheadLimit)       标记流中的当前位置。对reset（）的后续调用将尝试将流重新定位到此点。
readAheadLimit  限制在保留标记的同时可以读取的字符数。在读取字符达到或超过此限制后，尝试重置流可能会失败。
                  大于输入缓冲区大小的限制值将导致分配一个大小不小于限制的新缓冲区。因此，应谨慎使用较大的值。 // reader .mark( ( int )file.length() + 1 );
public void reset() throws IOException      将流重置为到mark的标记处，下一次readLine返回标记处下一行
public boolean ready() throws IOException   指示此流是否已准备好读取。如果缓冲区不为空，或者基础字符流已准备就绪，则缓冲字符流已准备就绪。
BufferedWriter
package java.io;
public class BufferedWriter extends Writer 字符缓冲输出流

public BufferedWriter(Writer out, int sz)   创建一个新的缓冲字符输出流,使用给定大小的输出缓冲区
public BufferedWriter(Writer out)          创建一个新的缓冲字符输出流, 使用默认大小的输出缓冲区

public void write(int c)
public void write(char cbuf[], int off, int len)
public void write(String s, int off, int len)         把字符串s写到文件中，追加模式（可以循环中转变量取出数组值  然后写入）
public void newLine()                           写一行行分隔符，行分隔符字符串由系统属性定义
public void flush()
public void close()
BufferedInputStream
package java.io;
public class BufferedInputStream extends FilterInputStream     字节缓冲输入流（字节缓冲流仅仅提供缓冲区,而真正的读写数据还得依靠基本的字节流对象进行操作）
                                        这个显得有些多余的过程，用变量b一个一个传递字节到另一个数组其实是因为这个过程是放在内存中的，所以很快
                                        中间如果使用数组就可以每次倒手多个字节



protected int markpos = -1;      The value of the pos field at the time the last mark method was called.
protected int pos;                       The current position in the buffer.

public BufferedInputStream(InputStream in)
public BufferedInputStream(InputStream in, int size)

public synchronized int read() throws IOException
public synchronized int read(byte b[], int off, int len) throws IOException
private void fill() throws IOException     Delegates basic components for deeper operations.
BufferedOutputStream
package java.io;
public class BufferedOutputStream extends FilterOutputStream   字节缓冲输出流

public BufferedOutputStream(OutputStream out)

public synchronized void write(int b)
public synchronized void write(byte b[], int off, int len)
PushbackInputStream
package java.io;
public class PushbackInputStream extends FilterInputStream    A PushbackInputStream adds functionality to another input stream, namely the ability to "push back" or "unread" byptes,
by storing pushed-back byptes in an internal buffer.

PushbackInputStream is a specific decorator.
DataInputStream
package java.io;
 public class DataInputStream extends FilterInputStream implements DataInput
A data input stream lets an application read primitive JAVA data types from an underlying input stream in a machine-independent way.

public final int read(byte b[]) throws IOException
public final int read(byte b[], int off, int len) throws IOException
DataInput
package java.io;
public interface DataInput
The DataInput interface provides for reading bytes from a binary stream and reconstructing from them data in any of the Java primitive types.

Conversion Stream
InputStreamReader
public class InputStreamReader          字节流到字符流的桥梁（文件是什么码表,那么咱们就必须使用什么码表去读取）


public String getEncoding()
OutputStreamWriter
public class OutputStreamWriter      字符流到字节流的桥梁，可以写入ArrayList


public OutputStreamWriter(OutputStream out, String charsetName)
public OutputStreamWriter(OutputStream out)
public OutputStreamWriter(OutputStream out, Charset cs)
public OutputStreamWriter(OutputStream out, CharsetEncoder enc)

public void write(int c)
public void write(char cbuf[], int off, int len)
public void flush()
public void close()


Object Stream
ObjectInputStream
public class ObjectInputStream   对象操作输入流也叫序列化流，就是将对象以字节的形式写到本地文件中，或者在网络中传输对象（需要再次用对象操作流将字节文件读到内存中）

public ObjectInputStream(InputStream in)

public final Object readObject()

                  读到文件结束会有EOFException异常

ObjectOutputStream
public class ObjectOutputStream   对象操作输出流也叫反序列化流，把写到本地文件中的对象读到内存中，或者接收网络中传输的对象

public ObjectOutputStream(OutputStream out)

public final void writeObject(Object obj)          写入对象到本地文件
PushbackInputStream
package java.io;
public class PushbackInputStream extends FilterInputStream        回推输入流，允许读取字节，然后再将它们返回（回推）到流中，可以“偷窥”来自输入流的内容而不对它们进行破坏。
public PushbackInputStream(InputStream in, int size)                      构建一个回推输入流
Security
FilePermission
package java.io;
public final class FilePermission extends Permission implements Serializable     文件权限，权限的顶级类的子类

[Annotation]
@Serial     检查序列化成员（字段和方法），如果它与配置文件不匹配，编译器应该提醒您一个错误。并且它向读者提供了类似的提示，该成员将被序列化使用。

java.lang
(Core)
AutoCloseable
public interface AutoCloseable     自动关闭资源
void close() throws Exception;   关闭系统资源
Class
package java.lang;
public final class Class<T>       代理类，任何类被使用时，系统都会为之建立一个java.lang.Class对象 （类名.class==代理类对象）

public static Class<?> forName(String className) throws ClassNotFoundException      返回一个类，要求JVM查找并加载指定的类
public static Class<?> forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException     使用给定的类加载器返回与具有给定字符串名称的类或接口关联的 类对象。
public String getSimpleName()         获取类名
public String getName()                    获取全类名（内部类显示不同：zengqiang.Log4jTest$Innr）
public String getCanonicalName()       获取全类名    // zengqiang.Log4jTest.Innr

public Field[] getFields() throws SecurityException            返回所有 公共成员变量 对象数组
public Field[] getDeclaredFields() throws SecurityException    返回所有 成员变量 对象数组
public Field getField(String name) throws NoSuchFieldException, SecurityException           返回单个 公共成员变量 对象
public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException   返回单个 成员变量 对象

public Method[] getMethods() throws SecurityException               返回所有 公共成员方法 对象数组
public Method[] getDeclaredMethods() throws SecurityException      返回所有 成员方法 对象数组
public Method getMethod(String var1, Class... var2) throws NoSuchMethodException, SecurityException              返回一个和参数配型相符的 公共成员方法 对象
public Method getDeclaredMethod(String var1, Class... var2) throws NoSuchMethodException, SecurityException     返回一个和参数配型相符的 成员方法 对象

public Constructor<?>[] getConstructors() throws SecurityException            返回所有 公共构造方法 对象数组
public Constructor<?>[] getDeclaredConstructors() throws SecurityException    返回所有 构造方法 对象数组
public Constructor<T> getConstructor(Class... parameterTypes) throws NoSuchMethodException, SecurityException                返回一个和参数配型相符的 公共构造方法 对象
public Constructor<T> getDeclaredConstructor(Class... parameterTypes) throws NoSuchMethodException, SecurityException        返回一个和参数配型相符的 构造方法 对象        // clazz.getDeclaredConstructor(String.class,String.class,int.class)
public Class<?>[] getInterfaces()     获取这个类或接口   直接实现的所有接口

public T newInstance() throws InstantiationException, IllegalAccessException      返回当前类的实例对象，只能调用无参构造（如果是非public的，需要使用setAccessible临时取消检查，然后再创建对象）



public <A extends Annotation> A getAnnotation(Class<A> annotationClass)            获取在当前类上使用的 指定注解类型
public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)     当前类上面是否有 指定注解类型
native Class<? super T> getSuperclass()    获取直接继承的父类类型（不包含泛型参数）
            如果此 Class 表示 Object 类、接口、基本类型或 void，则返回 null
            如果此对象表示一个数组类，则返回表示该 Object 类的 Class 对象
Type getGenericSuperclass()          获取直接继承的父类类型
           如果此 Class 表示 Object 类、接口、基本类型或 void，则返回 null
           泛型的类型是无法在运行时通过反射取得的，泛型类型在编译成字节码的时候已经被虚拟机给去掉了，只是起到提示编译器进行类型检查的作用
           包含泛型参数，返回的Type instanceof ParameterizedType时，可以强转为ParameterizedType获取泛型
native boolean isAssignableFrom(Class<?> cls)   是否是某个类的父类（相比于instanceof，为class判断）
T[] getEnumConstants()      获取枚举值数组
native boolean isInterface()        是否是接口

public java.net.URL getResource(String name)                   获取资源文件绝对路径（不能获取内部目录路径，但是能获取根目录路径"/"）
public InputStream getResourceAsStream(String name)    获取资源文件的流           //  getClass().getResourceAsStream( "/V1.2_price.xlsx" )        读取resources路径下的V1.2_price.xlsx
public T cast(Object obj)   类型转换，可以直接使用赋值强转     // Father fa = Father.class.cast(per)
public native Class<?> getComponentType()      返回一个数组成员类型，如果不是数组，返回null      // T[] array1       array1.getClass().getComponentType()

1.	通过invoke调用实例的方法
obj = Class.forName("org.chen.yuan.reflect.Person");
Method met = c1.getMethod("sayChina");
met.invoke(obj.newInstance());

2.	Access some fields in internal JVM classes and print out the number of object references:
   Class<?> finalizerClass = Class.forName("java.lang.ref.Finalizer");
   Field queueStaticField = finalizerClass.getDeclaredField("queue");
   queueStaticField.setAccessible(true);
   ReferenceQueue<Object> referenceQueue = (ReferenceQueue) queueStaticField.get(null);

   Field queueLengthField = ReferenceQueue.class.getDeclaredField("queueLength");
   queueLengthField.setAccessible(true);
   long queueLength = (long) queueLengthField.get(referenceQueue);
   System.out.format("There are %d references in the queue%n", queueLength);


Object
package java.lang;
public class Object               基础对象

public final native Class<?> getClass();       获取代理类对象（Person.class）
public String toString()                      转为字符串
public native int hashCode()               哈希值    //-1742739278

public final void wait() throws InterruptedException  使当前线程等待，直到另一个线程调用该对象的notify方法或notifyAll方法
public final native void notify();           唤醒正在等待对象监视器的单个线程
public final native void notifyAll();        唤醒正在等待对象监视器的所有线程
protected void finalize() throws Throwable { }       覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法

重写
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return Objects.equals(name, person.name) &&
                Objects.equals(age, person.age);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
使用
MAIN >>
/*消费者步骤：
1，判断桌子上是否有汉堡包。
2，如果没有就等待。
3，如果有就开吃
4，吃完之后，桌子上的汉堡包就没有了
        叫醒等待的生产者继续生产
汉堡包的总数量减一*/



/*生产者步骤：
1，判断桌子上是否有汉堡包
如果有就等待，如果没有才生产。
2，把汉堡包放在桌子上。
3，叫醒等待的消费者开吃。*/

Desk desk = new Desk();
Foodie f = new Foodie(desk);
Cooker c = new Cooker(desk);

foodie.start();
cooker.start();
Desk >>
public class Desk {

    //定义一个标记
    //true 就表示桌子上有汉堡包的,此时允许吃货执行
    //false 就表示桌子上没有汉堡包的,此时允许厨师执行
    public static boolean flag;

    //汉堡包的总数量
    public int count;

    //锁对象
    public final Object lock = new Object();
    public Desk() {
        this(false,10);
    }
    public Desk(boolean flag, int count) {
        this.flag = flag;
        this.count = count;
    }
}
Cooker >>
public class Cooker extends Thread {

    private Desk desk;

    public Cooker(Desk desk) {
        this.desk = desk;
    }
//    生产者步骤：
//            1，判断桌子上是否有汉堡包
//    如果有就等待，如果没有才生产。
//            2，把汉堡包放在桌子上。
//            3，叫醒等待的消费者开吃。

    @Override
    public void run() {
        while(true){
            synchronized (desk.getLock()){
                if(desk.getCount() == 0){
                    break;
                }else{
                    //System.out.println("验证一下是否执行了");
                    if(!desk.isFlag()){
                        //生产
                        System.out.println("厨师正在生产汉堡包");
                        desk.setFlag(true);
                        desk.getLock().notifyAll();
                    }else{
                        try {
                            desk.getLock().wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
Foodie >>
public class Foodie extends Thread {
    private Desk desk;

    public Foodie(Desk desk) {
        this.desk = desk;
    }

    @Override
    public void run() {
//        1，判断桌子上是否有汉堡包。
//        2，如果没有就等待。
//        3，如果有就开吃
//        4，吃完之后，桌子上的汉堡包就没有了
//                叫醒等待的生产者继续生产
//        汉堡包的总数量减一

        //套路:
            //1. while(true)死循环
            //2. synchronized 锁,锁对象要唯一
            //3. 判断,共享数据是否结束. 结束
            //4. 判断,共享数据是否结束. 没有结束
        while(true){
            synchronized (desk.getLock()){
                if(desk.getCount() == 0){
                    break;
                }else{
                    //System.out.println("验证一下是否执行了");
                    if(desk.isFlag()){
                        //有
                        System.out.println("吃货在吃汉堡包");
                        desk.setFlag(false);
                        desk.getLock().notifyAll();
                        desk.setCount(desk.getCount() - 1);
                    }else{
                        //没有就等待
                        //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.
                        try {
                            desk.getLock().wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }

    }
}
Runtime
package java.lang;
public class Runtime    运行环境
public static Runtime getRuntime()       获取当前运行环境
public native long freeMemory()           虚拟机可用内存
public native int availableProcessors();   虚拟机可用处理器

(Data Operation)
Math
package java.lang;
public final class Math        数学计算类

static int max(int a, int b)       计算最大值
static int min(int a, int b)       计算最小值
static float abs(float a)          绝对值
static double random()         返回一个 [0, 1)  值
static double floor(double a)    向下取整
static double ceil(double a)     向上取整
static double rint(double a)   四舍五入( .5的时候会取偶数)
static int round(float a)       四舍五入，float时返回int值，double时返回long值
static double sqrt(double a)              计算平方根
static double cbrt(double a)              计算立方根
static double pow(double a, double b)    计算a的b次方
static double toRadians(double angdeg)    角度转弧度
static double cos(double a)                 根据弧度计算cos
Comparable
package java.lang;
public interface Comparable<T>      内部比较器
public int compareTo(T o);
Cloneable
package java.lang;
public interface Cloneable    对象需要克隆时实现，重写Object类中就有的clone()方法即可，不声明Cloneable调用clone()方法会抛出CloneNotSupportedException异常

Random
package java.lang;
public class Random      随机工具
int nextInt(int bound)     返回一个随机整数 [0, n)
Iterable
package java.lang;
public interface Iterable<T>       遍历器
default void forEach(Consumer<? super T> action)       每一个元素都执行一次action
Integer
package java.lang;
public final class Integer extends Number implements Comparable<Integer>

public static String toHexString(int i)       返回为无符号整数基数为16的整数参数的字符串表示形式 // 170  ==>  aa
public int hashCode()                      hashCode就是数字本身
public static int parseInt(String s, int radix)  throws NumberFormatException    其他进制数转换成10进制        // Integer.parseInt("a7a", 16)     16进制字符串  10进制数
public static Integer valueOf(String s) throws NumberFormatException           其他类型转数字，null会宝空指针
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }

private static class IntegerCache
static final int low = -128;
static final int high;
static final Integer[] cache;         Cache Interger objects.
（Data Type)
Number
package java.lang;
public abstract class Number implements java.io.Serializable
public abstract long longValue();     获取long值
Enum
package java.lang;
public abstract class Enum<E extends Enum<E>>      美剧
implements Comparable<E>, Serializable
public static <T extends Enum<T>> T valueOf(Class<T> enumClass, String name)      jpa enum converter

Character
package java.lang;
public final class Character implements java.io.Serializable, Comparable<Character>, Constable
public static char forDigit(int digit, int radix)     Get a char using the given radix.   // Character.forDigit((bt[i] & 240) >> 4, 16)
CharSequence
package java.lang;
public interface CharSequence       字符序列
public default IntStream chars()      转换为数值流（ASCII码，注意0为48）
String
package java.lang;
public final class String          线程安全，值不可改变，JDK1.7及之后的版本，常量池中存放的是对象的引用（避免对象多次创建）
    implements java.io.Serializable, Comparable<String>, CharSequence
操作少量的数据，用String
统计子串个数       int currentLeftCount = checkCountLine.length()-checkCountLine.replaceAll("\\{","").length();

String s = "zzc";
String s2 = "zzc";
System.out.println(s == s2);  // true

String s = "zzc";
String s2 = new String("zzc");
System.out.println(s == s2);  // false        两个字符串字面量仍然被放进了常量池的常量表中，但是当使用“new”时，JVM就会在运行时创建一个新对象，而不是使用常量表中的引用

String s = "zzc";
String s2 = new String("zzc");
String s3 = s2.intern();
System.out.println(s == s3);  // true       调用intern()后，首先检查字符串常量池中是否有该对象的引用，如果存在，则将这个引用返回给变量，否则将引用加入并返回给变量。
public String()                   默认赋值空字符串""
public String(char value[])        字符数组转换成字符串
public String(byte bytes[])        平台默认字符编码，将字节数组解码为字符串
public String(byte bytes[], int offset, int length)    平台默认字符编码，将字节数组解码为字符串，从索引0开始，长度10
public String(byte bytes[], String charsetName)  throws UnsupportedEncodingException     指定编码的字符串

public static String valueOf(Object obj)                  其他类型转换成字符串
public static String format(String format, Object... args)   返回格式字符串（%s  %.2f  %d填充占位符）
// %-3.2f        保留小数点3为，不算小数点总共3位，超出就超出显示，不会截断
// %-3.3s       字符串为截断长度，即使传入的是数字，字符串也是固定长度
// 6.2f%%    转义显示百分号：%%
public static String join(CharSequence delimiter, CharSequence... elements)    将字符序列用delimiter连接 // String.join("-",strArr);

public int length()              获取字符串长度
public boolean equals(Object anObject)   比较字符串是否相同
public boolean isEmpty()             判断是否为空（根据length判断）
public boolean matches(String regex)                    完全匹配正则
public boolean contains(CharSequence s)                                是否含有字符串【不能传字符】
public int indexOf(String str)                                             查询字符串或字符的索引
public int indexOf(String str, int fromIndex)                              查询字符串或字符的索引（fromIndex可以超出）
public int lastIndexOf(String str)                                         倒序查询字符串或字符的索引
public int hashCode()                                                          返回此字符串的哈希代码，根据字符和字符串长度计算得出，  s[0]*31^(n-1)  +  s[1]*31^(n-2) +…+  s[n-1]

public char charAt(int index)          获取指定索引的字符，超出范围报错
public String replace(CharSequence target, CharSequence replacement)   rep替换k内部的afafa，不修改原字符串，不支持正则（返回替换的字符串）
public String substring(int beginIndex, int endIndex)              获取一个子字符串，endIndex不能超出范围  [0, 2)
public String substring(int beginIndex)                                   获取一个子字符串，包含到最后一个字符
public char[] toCharArray()                     转换成字符数组并返回
public byte[] getBytes()                        平台默认字符编码 字符串编码为字节数组
public byte[] getBytes(String charsetName)     使用指定字符编码，字符串编码成字节数组

public String toUpperCase()          转换成大写
public String toLowerCase()          转换成小写
public String toUpperCase(Locale locale)     转换成大写，指定语言      // "test".toUpperCase(Local.ENGLISH)
public boolean startsWith(String prefix)     开头的字符串是否为prefix，大小写敏感
public boolean endsWith(String suffix)      结尾的字符串是否为suffix
public boolean equalsIgnoreCase(String anotherString)  比较字符串是否相同，不区分大小写
public int compareTo(String anotherString)                比较字符串大小（等于返回0覆盖，小于返回-n，大于返回n）
public String trim()                             得到去掉左右空格的字符串
public String[] split(String regex)                根据符号拆分字符串
public String[] split(String regex, int limit)   根据符号拆分字符串
当limit>0          切割次数=limit-1,因此当limit=1时，不切割，原字符串输出
当limit=0          与不写limit一致：不限制切割次数，出现几次匹配切割几次。但是去除最后空字符串
当limit<0          不限制切割次数，出现几次匹配切割几次，不去除最后空字符串。
public String concat(String str)                 拼接字符串，不修改原字符串
the concat string in the parameters must not be null
public String replaceAll(String regex, String replacement)    替换全部，
replacement内可以通过 $1 获取前方正则分组匹配的内容，$0为前方全部匹配内容
replacement是普通字符串，转义字符用一个斜杠就好   \t
    //  public static void main(String[] args) throws UnknownHostException     (.*\()|(\))         ==>      String[] args throws UnknownHostException
    // configPath.replaceAll("\\\\","\\\\\\\\");      C:\\Users\\saidake\\.smp
Matcher#quoteReplacement
Pattern#quote

public native String intern()                    当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。

String.join("", Collecions.nCopies(n,s));   字符串s重复n遍
StringUtils.SPACE
Boolean
package java.lang;
public final class Boolean implements java.io.Serializable,  Comparable<Boolean>
public static boolean getBoolean(String name)    当且仅当以参数命名的系统属性存在，且等于 “true” 字符串时，才返回 true。
StringBuilder
package java.lang;
public final class StringBuilder          线程不安全，效率高，数组初始容量是16，数组动态扩容
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
如果长度超过了字符串存储空间大小就需要进行扩容，它会重新分配内存，创建一个更大的字符数组，这个字符数组的容量是原来的 （两倍 + 2 ）的大小，并将原先的数组复制过来，再丢弃旧的数组，扩容方法在AbstractStringBuilder中
单线程操作大量数据，用StringBuilder
StringBuffer
package java.lang;
public final class StringBuffer          线程安全，效率低，数组初始容量是16，数组动态扩容。
如果长度超过了字符串存储空间大小就需要进行扩容，它会重新分配内存，创建一个更大的数组，这个数组的容量是原来的 （两倍 + 2 ）的大小，并将原先的数组复制过来，再丢弃旧的数组
多线程操作大量数据，用StringBuffer

public StringBuffer()                   默认16字符 超出时自动增加容量
public StringBuffer(int capacity)        指定字符容量，超出自动增加容量
public StringBuffer(String str)          当前字符串 加16字符   超出自动增加容量

public synchronized int length()                              返回长度
public synchronized int capacity()                                       返回容量

public synchronized StringBuffer append(Object obj)          将各种数据转换成字符串追加到当前对象中
public synchronized char charAt(int index)                    得到索引n上的字符
public synchronized void setCharAt(int index, char ch)          index处字符用ch替换
public synchronized StringBuffer delete(int start, int end)      从当前对象中删除字符串
public synchronized StringBuffer deleteCharAt(int index)       删除索引处的字符

public synchronized StringBuffer insert(int offset, Object obj)   字符串插入索引index处
public synchronized StringBuffer reverse()                               翻转字符串
public synchronized StringBuffer replace(int start, int end, String str)      用str替换指定内容[start, end)
public synchronized String toString()                      转换成字符串  //没有contains方法

public int indexOf(String str)                  返回子串索引（传入字符会保错）
public int lastIndexOf(String str)              返回子串逆序索引（传入字符会报错）

public synchronized void ensureCapacity(int minimumCapacity)                           确保最低容量
public synchronized void getChars(int srcBegin, int srcEnd,   char[] dst, int dstBegin)       返回srcBegin到srcEnd的字符到dst
public synchronized CharSequence subSequence(int start, int end)                        返回字符子序列；
public synchronized String substring(int start)             返回子串；
public synchronized String substring(int start, int end)     返回子串；
public synchronized void trimToSize()                      缩小value的容量到真实内容大小；
(Thread)
package java.lang;
public interface Runnable     函数式接口，可执行内容
public abstract void run();      执行线程内容
Thread
package java.lang;
public class Thread implements Runnable       线程管理
public Thread(Runnable target)    通过Runnable或者匿名函数创建一个线程
public static native Thread currentThread();            返回一个当前执行线程对象的引用
public static native boolean holdsLock(Object obj);        当前线程 已经进入对象锁时，返回 true

private void init(ThreadGroup g, Runnable target, String name,    long stackSize, AccessControlContext acc,     boolean inheritThreadLocals)        线程初始化
this.inheritableThreadLocals =ThreadLocal.createInheritedMap(parent.inheritableThreadLocals)     存储父类的inheritableThreadLocals值

public final void setPriority(int newPriority)      设置优先级
public final int getPriority()                    获取线程优先级，默认5
public final void setDaemon(boolean on)      设置为守护线程（普通线程执行完后，那么守护线程也没有执行必要了）


final native void wait(long timeout)    线程等待。 调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中
static native void sleep(long millis)     线程睡眠。sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致
                                                        线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态
final void join() throws InterruptedException    1. 概念：等待其他线程终止。join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞 状态，
                                                         回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。
                                                     2. 目的：很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要 在子线程结束后再结束，这时候就要用到 join() 方法
System.out.println(Thread.currentThread().getName() + "线程运行开始!");
 Thread6 thread1 = new Thread6();
 thread1.setName("线程 B");
 thread1.join();
System.out.println("这时 thread1 执行完毕之后才能执行主线程");
static native void yield();                       线程让步。yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，
                                                         但这又不是绝对的，有的操作系统对线程优先级并不敏感。
static int activeCount()                            程序中活跃的线程数
static int enumerate(Thread tarray[])               枚举程序中的线程
static native Thread currentThread()                得到当前线程
public ClassLoader getContextClassLoader()        当前线程的类加载器（为了避开双亲委派模型的加载方式的，也就是说它不是用这种方式来加载类）


void interrupt()                          1. 线程中断。中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这 个线程本身并不会因此而改变状态(如阻塞，终止等)
2. 调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。
3. 若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态
4. 许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异 常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。
5. 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止 一个线程 thread 的时候，可以调用 thread.interrupt()方法，
    在线程的 run 方法内部可以 根据 thread.isInterrupted()的值来优雅的终止线程。
final native boolean isAlive();                      判断一个线程是否存活
final boolean isDaemon()                          一个线程是否为守护线程
final void setDaemon(boolean on)                 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线 程依赖于主线程结束而结束)
final synchronized void setName(String name)      为线程设置一个名称
final void setPriority(int newPriority)               设置一个线程的优先级
final int getPriority()                               获得一个线程的优先级


ThreadLocal
package java.lang;
public class ThreadLocal<T>     线程本地存储，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意方法中获取缓存的数据
使用时必须管理它的创建、销毁，线程池重用线程时，必须先清空老数据
ThreadLocal 的作用 是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或 者组件之间一些公共变量的传递的复杂度

ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在一个ThreadLocalMap, Map的key为ThreadLocal对象，Map的value为需要缓存的值

由于ThreadLocalMap通过Thread.currentThread()获取值，子线程无法获取父线程的数据，只能获取当前正在执行线程的数据。

在线程池中使用ThreadLocal会造成内存泄漏，当ThreadLocal对象使用完之后，应该要把设置的key，value，也就是Entry对象进行回收，
但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏。
解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清除Entry对象。

static class ThreadLocalMap        保存Thread线程数据
                                   将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的 ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取 得自己线程保存的那个对象，
                                         避免了将这个对象作为参数传递的麻烦。
                                   ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义     ThreadLocal.ThreadLocalMap threadLocals = null;

public void set(T value)       根据Thread.currentThread()的键，设置ThreadLocalMap一个值
public T get()                 根据Thread.currentThread()的键，获取值，没有初始化时返回null
ThreadLocalMap getMap(Thread t)     获取键值对
使用缺点——————————————————————————————————————————————————————————————————————————————
public class MainTest {

    public static ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>();

    public static void main(String args[]){
        threadLocal.set(new Integer(123));

        Thread thread = new MyThread();
        thread.start();

        System.out.println("main = " + threadLocal.get());  // 123
    }

    static class MyThread extends Thread{
        @Override
        public void run(){
            System.out.println("MyThread = " + threadLocal.get());  // null（无法获取父线程的数据）
        }
    }
}
使用————————————————————————————————————————————————————————————————————————————————————
private static final ThreadLocal threadSession = new ThreadLocal();        //最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等
public static Session getSession() throws InfrastructureException {
    Session s = (Session) threadSession.get();
    try {
       if (s == null) {
       s = getSessionFactory().openSession();
       threadSession.set(s);
       }
    } catch (HibernateException ex) {
       throw new InfrastructureException(ex);
    }
    return s;
}
InheritableThreadLocal
package java.lang;
public class InheritableThreadLocal<T> extends ThreadLocal<T>    父子线程传值（它是在线程创建的时候进行复制上下文的。那么对于线程池的已经创建完了就无从下手了
                                                                       所以在线程提交的时候要进行上下文的复制，可以使用transmittable-thread-local 的TransmittableThreadLocal解决的问题

ThreadLocalMap getMap(Thread t)          返回当前线程的成员inheritableThreadLocals，在thread.init初始化时会获取父线程的值
protected T childValue(T parentValue)
void createMap(Thread t, T firstValue)       同ThreadLocal，创建一个新的ThreadLocalMap
(Exception)
ArithmeticException
package java.lang;
public class ArithmeticException extends RuntimeException        1/0
Throwable
package java.lang;
public class Throwable implements Serializable       Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception

public String getLocalizedMessage()       以用户的本地语言(中文，日语等)返回异常的名称。
public String getMessage()             获取详细信息
public synchronized Throwable getCause()     获取原因
例如线程池抛出的异常，最外层是 ExecutionException，所以 getCause() 能够获取到里层 RuntimeException；
直接捕获抛出的异常，调用 getCause() 则返回的 null；
public final synchronized Throwable[] getSuppressed()    获取压制的异常
public void printStackTrace(PrintWriter s)    打印过程从外向内，最外层抛出的位置最先打印
Exception
package java.lang;
public class Exception extends Throwable
getMessage可能为null
异常捕获还是抛出：如果方法可能会在不同的场景下，被不同的代码调用。在这些场景中，出现"文件未被找到"的处理逻辑可能是不一样的。只有抛出之后再捕获才可以获得多种多样的处理方式，若直接捕获那么就只有那一种固定的处理方式了。

A class that inherits Exception class will become a Checked Exception.
非受检异常RuntimeException：    RuntimeException是所有非受检异常类的基类，如果出现 RuntimeException，那么一 定是程序员的错误（从RuntimeException继承的异常，可以在没有异常说明throws的情况下被抛出）
NullPointerException         空指针异常
ClassCastException         类型转换异常
TypeNotPresentException   类型不存在异常

IndexOutOfBoundsException        索引越界异常
ArrayIndexOutOfBoundsException   数组下标越界异常
NegativeArraySizeException          数组大小为负数异常
ArrayStoreException                 数组元素不匹配异常

NumberFormatException              数字转换异常
StringIndexOutOfBoundsException   字符串截取下标越界异常
EnumConstantNotPresentException   枚举常量不存在异常
ArithmeticException                 算术异常

IllegalArgumentException            非法参数异常
IllegalThreadStateException          线程异常
IllegalStateException                      状态异常
IllegalMonitorStateException         违法的监控状态异常
受检异常CheckedException：    除了RuntimeException和Error之外的异常都属于受检异常，一般是外部错误，这种异常都发生在编译阶段。（Java 编译器会强 制程序手动去捕获此类异常：throws给方法调用者，或者在发生的方法中try/catch掉）
IOException             IO流异常（EOFException   FileNotFoundException）
SqlException            sql异常

ClassNotFoundException          找不到类异常
CloneNotSupportedException     clone异常-未实现Cloneable接口

IllegalAccessException     访问权限异常-private
DataFormatException      数据格式化异常
NoSuchFieldException     反射异常
NoSuchMethodException  方法未找到异常
Error
package java.lang;
public class Error extends Throwable          Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果 出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
VirtualMachineError      虚拟机错误
StackOverflowError
OutOfMemoryError
UnknownError
InternalError
IOError              io错误

AssertionError       断言错误
ThreadDeath         线程死亡（强制将运行的线程停止）
AnnotationFormatError       注解解析错误

AWTError                    发生严重的 Abstract（A） Window（W） Toolkit（T） 错误
RuntimeException
package java.lang;
public class RuntimeException extends Exception

public RuntimeException()
public RuntimeException(String message)
public RuntimeException(String message, Throwable cause)
public RuntimeException(Throwable cause)
protected RuntimeException(
String message,                       细节信息
Throwable cause,                     原因
boolean enableSuppression,
           boolean writableStackTrace
)

StackTraceElement
package java.lang;
public final class StackTraceElement implements java.io.Serializable        异常追踪元素
StackWalker
package java.lang;
public final class StackWalker
The initially called function will be located at the bottom of StackFrames
-	outside2
-	outside1
-	main
public <T> T walk(Function<? super Stream<StackFrame>, ? extends T> function)      Applies the given function to the stream of StackFrames for the current thread.
Walk内的函数必须返回数值而不是stream，确保最终stream是关闭状态。
IllegalArgumentException
package java.lang;
public class IllegalArgumentException extends RuntimeException   非法参数异常

public IllegalArgumentException(String s)      手动抛出异常
IllegalStateException
package java.lang;
public class IllegalStateException extends RuntimeException     非法状态异常

(System)
Runtime
package java.lang;
public class Runtime      运行信息

public static Runtime getRuntime()
public native int availableProcessors();    返回JVM可用处理器的数量
System
package java.lang;
public final class System     系统信息

public final static PrintStream err = null;      “标准”错误输出流。 此流已打开并准备接受输出数据
此输出流用于显示应立即引起用户注意的错误消息或其他信息，即使主要输出流（变量out的值）已重定向到文件或其他目标，即通常不会持续监控

public static native long currentTimeMillis();    获取当前毫秒数
public static String getProperty(String key)     获取系统属性
line.separator  系统换行符（File.separator  路径分隔符）
user.dir            项目根路径      //  System.getProperty("user.dir")    =    D:\Desktop\DevProject\saidake-manage-project
user.home        // C:\Users\saidake
java.io.tmpdir        系统临时目录
FileSystemView.getFileSystemView().getHomeDirectory().getPath();          Desktop directory
public static String lineSeparator()                  获取系统换行符
public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length)     拷贝一个数组
public static native long nanoTime();       从某个固定但任意的起始时间开始的纳秒数

System.out.println()                      换行输出
System.out.print()                       不换行输出
System.out.printf("%d%c%f%s", a, b, c)   格式化输出（ int型  char型  浮点型 字符串型）
ClassLoader
package java.lang;
public abstract class ClassLoader     类加载器
public Enumeration<URL> getResources(String name) throws IOException   获取资源文件的URL
(Security)
SecurityManager
package java.lang;
public class SecurityManager     安全管理  允许应用程序实现安全策略的类。 它允许应用程序在执行可能不安全或敏感的操作之前，确定操作是什么以及是否在允许执行操作的安全上下文中尝试操作。 应用程序可以允许或禁止操作。
权限属于以下类别：文件，套接字，网络，安全性，运行时，属性，AWT，反射和可序列化。 管理这些不同的权限类别类是
java.io.FilePermission ，java.net.SocketPermission ，
 java.net.NetPermission ， java.security.SecurityPermission ， java.lang.RuntimePermission ，
java.util.PropertyPermission ， java.awt.AWTPermission ， java.lang.reflect.ReflectPermission， java.io.SerializablePermission
除前两个之外的所有文件（FilePermission和SocketPermission）都是java.security.BasicPermission子类


public void checkPermission(Permission perm)      如果根据当前有效的安全策略不允许由给定权限指定的请求访问，则抛出 SecurityException 。
线程检查：始终在当前正在执行的线程的上下文中执行安全检查，确定调用线程具有执行所请求的操作的权限。
public void checkPermission(Permission perm, Object context)       除了权限之外还采用上下文对象的checkPermission方法，基于该上下文而不是当前执行线程的方式做出访问决策。
public void checkAccess(Thread t)       如果不允许调用线程修改线程参数，则抛出 SecurityException 。
public void checkWrite(String file)      如果不允许调用线程写入字符串参数指定的文件，则抛出 SecurityException 。
public void checkDelete(String file)     如果不允许调用线程删除指定文件，则抛出 SecurityException 。
 (Annotation)
package java.lang;
@Override               保证编译时候Override函数声明正确性【METHOD】
@SafeVarargs        断定声明的构造函数和方法的主体不会对其varargs参数执行潜在的不安全的操作（对于非static或非final声明的方法，不适用，会编译不通过）    【CONSTRUCTOR, METHOD】
@Deprecated             对不应该再使用的方法添加注解，当编程人员使用这些方法时，会获取提示【CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE】
@SuppressWarnings      关闭特定的警告信息【TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE】
value=“unchcked”
unchecked          告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息，执行了未检查的转换时的警告    //  unchecked call ……
deprecation         如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。使用这个注释将警告信息去掉。
fallthrough          当Switch程序块直接通往下一种情况而没有break时的警告
path                在类路径，源文件路径等中有不存在的路径时的警告
serial                      忽略在serializable类中没有声明serialVersionUID变量
serialVersionUID    定义时的警告
finally              任何finally子句不能正常完成时的警告
all                  关于以上所有情况的警告
rawtypes      抑制没有传递带有泛型的参数的警告
JavadocReference


@SuppressWarnings("unchecked")
	public static <T> T getBean(String name) {     return (T) applicationContext.getBean(name);   	}
注解处理器
概念： 如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中， 很重要的一部分就是创建于使用注解处理器。
       Java SE5 扩展了反射机制的 API，以帮助程序员快速 的构造自定义注解处理器。下面实现一个注解处理器。

FruitProvider >>
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitProvider {          // 定义注解
   public int id() default -1;               // 供应商编号
   public String name() default ""；       // 供应商名称
   public String address() default "";       //供应商地址
}

Apple >>
public class Apple {
    @FruitProvider(id = 1, name = "陕西红富士集团", address = "陕西省西安市延安路")       //注解使用
    private String appleProvider;

    public void setAppleProvider(String appleProvider) {
       this.appleProvider = appleProvider;
    }
    public String getAppleProvider() {
       return appleProvider;
    }
}
FruitInfoUtil >>
public class FruitInfoUtil {                             //注解处理器
    public static void getFruitInfo(Class<?> clazz) {
        String strFruitProvicer = "供应商信息：";
        Field[] fields = clazz.getDeclaredFields();       //通过反射获取处理注解
        for (Field field : fields) {
            if (field.isAnnotationPresent(FruitProvider.class)) {
                FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class);
                strFruitProvicer = " 供应商编号：" + fruitProvider.id() + " 供应商名称："  + fruitProvider.name() + " 供应商地址："+ fruitProvider.address();   //注解信息的处理地方
                System.out.println(strFruitProvicer);
            }
        }
    }
}
FruitRun >>
public class FruitRun {
    public static void main(String[] args) {
        FruitInfoUtil.getFruitInfo(Apple.class);    输出结果：  供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延
    }
}

annotation
Annotation
package java.lang.annotation;
public interface Annotation   注解

Class<? extends Annotation> annotationType()     注解类型
RetentionPolicy
package java.lang.annotation;
public enum RetentionPolicy {          定义被它所注解的注解保留多久
    SOURCE,            只在源代码级别保留，编译时就会被忽略，在class字节码文件中不包含。
    CLASS,              编译时被保留，默认的保留策略，在class文件中存在，但JVM将会忽略，运行时无法获得。
    RUNTIME           将被JVM保留，所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用。
}
ElementType
package java.lang.annotation;
public enum ElementType {
    TYPE,                接口，类，枚举，注解
    FIELD,                  字段，枚举的常量
    METHOD,              方法
    PARAMETER,           方法参数
    CONSTRUCTOR,        构造函数
    LOCAL_VARIABLE,       局部变量
    ANNOTATION_TYPE,      注解
    PACKAGE,                包
    TYPE_PARAMETER,       用来标注类型参数
    TYPE_USE                能标注任何类型名称
}
元注解
Annotation：    注解 是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径 和方法。
                 Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息
元注解： 元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被 用来提供对其它 annotation 类型作说明。

package java.lang.annotation;
@Target     说明了 注解 所修饰的对象范围【ANNOTATION_TYPE】
注解 可被用于 packages、types（类、 接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数 和本地变量（如循环变量、catch 参数）。
在 注解 类型的声明中使用了 target 可更加明晰 其修饰的目标
value=“FIELD”
CONSTRUCTOR       构造器声明
FIELD                 域声明（包括enum实例）
LOCAL_VARIABLE      局部变量声明
METHOD      方法声明
PACKAGE      包声明
PARAMETER    参数声明
TYPE           类，接口（包括注解类型）或enum声明
@Retention       定义了该 注解 被保留的时间长短：表示需要在什么级别保存注解信息，用于描 述注解的生命周期（即：被描述的注解在什么范围内有效）【ANNOTATION_TYPE】
value=“SOURCE”
SOURCE     在源文件中有效（即源文件保留）
CLASS       在 class 文件中有效（即 class 保留）
RUNTIME    在运行时有效（即运行时保留）
@Documented           描述-javadoc。用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因 此可以被例如 javadoc 此类的工具文档化。【ANNOTATION_TYPE】
@Inherited              阐述了某个被标注的类型是被继承的。如果一 个使用了@Inherited 修饰的 注解 类型被用于一个 class，则这个 注解 将被用于该 class 的子类。【ANNOTATION_TYPE】
reflect
AccessibleObject
package java.lang.reflect;
public class AccessibleObject implements AnnotatedElement        对象访问控制

public void setAccessible(boolean var1) throws SecurityException      取消访问检查（public，private）
Field
package java.lang.reflect;
public final class Field          成员变量映射
extends AccessibleObject implements Member

public String getName()         获取字段名
public Type getGenericType()    获取字段类型


public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException               获取实例的 成员变量值
public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException    设置实例的 成员变量值
Method
package java.lang.reflect;
public final class Method extends Executable         成员方法映射
public Object invoke(Object obj, Object... args)                                                   运行实例的成员方法
public <T extends Annotation> T getAnnotation(Class<T> annotationClass)    获取方法上的注解对象，内部也包含注解的参数成员
Type
package java.lang.reflect;
public interface Type           类型
default String getTypeName()    获取类型名
ParameterizedType
package java.lang.reflect;
public interface ParameterizedType extends Type

Type[] getActualTypeArguments()     此类型实际类型参数的 Type 对象的数组（返回的Type强转为class<?>可以获取泛型的class）
Array
package java.lang.reflect;
public final class Array      提供静态方法创建数组
public static Object newInstance(Class<?> componentType, int length)    创建一个原始数组    //  T[] joinedArray = (Object[]) ((Object[]) Array.newInstance(type1, array1.length + array2.length))
Proxy（代理）
package java.lang.reflect;
public class Proxy implements java.io.Serializable   代理对象，会通过InvocationHandler参数执行invoke方法。
System.getProperties().put(""sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");        将JDK动态代理生成的class文件保存到本地
D:\Desktop\DevProject\saidake-manage-project\jdk\proxy1\$Proxy0.class            写入代理类到此文件
public static Object newProxyInstance(             创建代理对象
ClassLoader loader,          代理类的类加载器
Class<?>[] interfaces,      目标对象实现的接口类型
InvocationHandler h        目标方法被执行时触发
)
public static boolean isProxyClass(Class<?> cl)        是否是代理类
ProxyGenerator （代理）
package java.lang.reflect;
final class ProxyGenerator extends ClassWriter   代理类生成器
private static final boolean saveGeneratedFiles =              是否保存生成的代理类文件
            java.security.AccessController.doPrivileged(
                    new GetBooleanAction(
                            "jdk.proxy.ProxyGenerator.saveGeneratedFiles"));
static byte[] generateProxyClass(
ClassLoader loader,          类加载器
final String name,
List<Class<?>> interfaces,
int accessFlags
)
InvocationHandler（代理）
package java.lang.reflect;
public interface InvocationHandler           动态代理，自定义拦截器 加上 反射机制，在加载class时，生成一个继承Proxy，并实现 自定义代理接口UserService的匿名类，在调用具体方法前调用自定义拦截器 的InvokeHandler来处理

public Object invoke(Object proxy, Method method, Object[] args)     执行目标类中所有的方法都会经过invoke方法
使用
使用———————————————————————————————————————————————————————————————————————————————————
ProxyJdkTest >>
package com.saidake;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyJdkTest {

    public static void main(String[] args) {
        System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles", "true");
        Movie target = new Movie();
        IMovie proxyInstance = (IMovie) new MovieProxy(target).getProxyInstance();
        System.out.println("proxyInstance="+proxyInstance.getClass());
        proxyInstance.advertising(true,"开始消息");
        proxyInstance.play(" 速度与激情8 ");
        proxyInstance.advertising(false,"结束消息");
    }

    public  interface IMovie {
        void play(String movieName);
        void advertising(Boolean isBoforMovie,String txt);
    }
    public static class Movie implements IMovie {
        @Override
        public void play(String movieName) {
            System.out.println("播放电影《"+movieName+"》");
        }

        @Override
        public void advertising(Boolean isBoforMovie, String txt) {
            if(isBoforMovie){
                System.out.println("影片马上开始,"+txt);
            }else{
                System.out.println("影片正片已经结束"+txt);
            }
        }
    }
    public static class MovieProxy {
        private Object target;

        public MovieProxy(Object target) {
            this.target = target;
        }
        public Object getProxyInstance(){
            return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                    target.getClass().getInterfaces(),
                    new InvocationHandler() {
                        @Override
                        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                            System.out.println("JDK代理开始~~");
                            //反射机制调用目标对象的方法
                            Object ret = method.invoke(target,args);
                            System.out.println("JDK代理结束~~");
                            return ret;
                        }
                    });
        }
    }

}
$Proxy0 >>
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package jdk.proxy1;

import com.saidake.ProxyJdkTest;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements ProxyJdkTest.IMovie {
    private static final Method m0;
    private static final Method m1;
    private static final Method m2;
    private static final Method m3;
    private static final Method m4;

    public $Proxy0(InvocationHandler var1) {
        super(var1);
    }

    public final int hashCode() {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final boolean equals(Object var1) {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final String toString() {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void play(String var1) {
        try {
            super.h.invoke(this, m3, new Object[]{var1});
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void advertising(Boolean var1, String var2) {
        try {
            super.h.invoke(this, m4, new Object[]{var1, var2});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    static {
        try {
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m2 = Class.forName("java.lang.Object").getMethod("toString");
            m3 = Class.forName("com.saidake.ProxyJdkTest$IMovie").getMethod("play", Class.forName("java.lang.String"));
            m4 = Class.forName("com.saidake.ProxyJdkTest$IMovie").getMethod("advertising", Class.forName("java.lang.Boolean"), Class.forName("java.lang.String"));
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }

    private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup var0) throws IllegalAccessException {
        if (var0.lookupClass() == Proxy.class && var0.hasFullPrivilegeAccess()) {
            return MethodHandles.lookup();
        } else {
            throw new IllegalAccessException(var0.toString());
        }
    }
}




InvocationTargetException（代理）
package java.lang.reflect;
public class InvocationTargetException extends ReflectiveOperationException

java.math
BigDecimal
package java.math;
public class BigDecimal extends Number implements Comparable<BigDecimal>     如果需要精确计算，必须用String来够造BigDecimal，Java里面的商业计算，不能用float和double，因为他们无法 进行精确计算
percision    总位数
scale           保留小数

public BigDecimal(String val)      传入字符串，null，"" 都会报错     // new BigDecimal("2.225667")
public BigDecimal(int val)
public BigDecimal(double val)     这种写法不允许，会造成精度损失

public BigDecimal add(BigDecimal augend)       被加数
public BigDecimal setScale(int newScale, int roundingMode)     保留位数，多余位数处理方式

public BigDecimal multiply(BigDecimal m_val);                                     乘法
public BigDecimal multiply(BigDecimal m_val, MathContext ma_co);  乘法

public final static int ROUND_UP =           0;      进位处理                             // 2.225667   ==>   2.23
public final static int ROUND_DOWN =       1;      直接去掉多余的位数                   // 2.225667   ==>   2.22
public final static int ROUND_CEILING =      2;      向上                                 // 2.225667   ==>   2.23    -2.225667   ==>   -2.22
public final static int ROUND_FLOOR =       3;      向下                                 // 2.225667   ==>   2.22    -2.225667   ==>   -2.23
public final static int ROUND_HALF_UP =     4;     四舍五入（若舍弃部分>=.5，就进位）   // 2.225667   ==>   2.23
public final static int ROUND_HALF_DOWN = 5;      四舍五入（若舍弃部分>.5,就进位）      // 2.225667   ==>   2.22
public final static int ROUND_HALF_EVEN =    6;    如果舍弃部分左边的数字为偶数 则向下，如果舍弃部分左边的数字为奇数 则向上     // 4.05  ==>   4.0      4.15  ==>   4.2
public final static int ROUND_UNNECESSARY = 7;    断言请求的操作具有精确的结果，因此不需要舍入

RoundingMode
BigInteger
package java.math;
public class BigInteger extends Number implements Comparable<BigInteger>    表示任意大小的整数。 BigInteger 内部用一个 int[] 数组来模拟一个非常大的整数
public static final BigInteger TEN = valueOf(10)       表示10
java.net
URI
package java.net;
public final class URI implements Comparable<URI>, Serializable       统一资源定位符


URL
package java.net;
public final class URL implements java.io.Serializable        类URL表示统一资源定位符，指向万维网上的“资源”的指针
public URL(String spec) throws MalformedURLException        解析一个字符串网址
public URL(
String protocol,             协议
String host,                    主机地址
int port,                         端口
String file)                      主机上的文件名
throws MalformedURLException
InetAddress
package java.net;
public class InetAddress implements java.io.Serializable     表示ip地址

public static InetAddress getByName(String host)    确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址
public static InetAddress getLocalHost() throws UnknownHostException     根据网卡取本机内网IP   // InetAddress.getLocalHost().getHostAddress();

public byte[] getAddress()          返回文本显示中的IP地址字符串
public String getHostName()       获取此IP地址的主机名
DatagramSocket
package java.net;
public class DatagramSocket implements java.io.Closeable       单播广播客户端/服务端

public DatagramSocket() throws SocketException          空参绑定随机端口
public DatagramSocket(int port) throws SocketException   绑定指定端口
public void send(DatagramPacket p) throws IOException      发送一个数据包
public synchronized void receive(DatagramPacket p) throws IOException    接收一个数据包
public void close()                                          关闭连接
Client >>
// 找码头
DatagramSocket ds = new DatagramSocket();
// 打包礼物
String s ="送给村长老丈人的礼物";
byte[] bytes = s.getBytes();
InetAddress address = InetAddress.getByName("127.0.0.1");
int port = 1000o;
DatagramPacket dp = new DatagramPacket(bytes,bytes.length, address,port);
//由码头发送包裹
ds.send(dp);
//付钱走羊
ds.close();
Server >>
// 找码头----表示接收端从10000塔口接收致据的.
DatagramSocket ds = new DatagramSocket( 10080);
// 创建一个新的箱子
byte []bytes = new byte[1024];
DatagramPacket dp = new DatagramPacket(bytes,bytes.length);
// 接收礼物,把礼物放到新的箱子中
ds.receive(dp);
// 从新的箱子里面获取礼物
byte[]data = dp.getData();
System.out.println(new String(data));
// 拿完走羊
ds.close();
DatagramPacket
package java.net;
public final class DatagramPacket    数据包

public DatagramPacket(byte buf[], int offset, int length, InetAddress address, int port)     构造一个数据包，发送长度为length的数据包到指定主机上的指定端口号。//  InetAddress.getByName("255.255.255.255");  广播，路由器看到这个地址就会发送给所有主机
public DatagramPacket(byte buf[], int length)                                            构造一个 DatagramPacket用于接收长度为length数据包。
MulticastSocket
package java.net;
public class MulticastSocket extends DatagramSocket    组播客户端/服务端

public void joinGroup(InetAddress mcastaddr) throws IOException    把当前计算机绑定一个组播地址,表示添加到这一组中.  // InetAddress.getByName("224.0.1.0")

ConnectException
package java.net;
public class ConnectException extends SocketException      连接异常

HttpURLConnection
package java.net;
abstract public class HttpURLConnection extends URLConnection     Http连接

connection.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");                设置请求头
connection.setRequestProperty("Content-Length", String.valueOf(param.getBytes().length));

connection.setDoOutput(true);          允许向服务器写入写出数据
 connection.setDoInput(true);

OutputStream outputStream = connection.getOutputStream();         获取输出流，向服务器写入数据。
outputStream.write(param.getBytes());
outputStream.flush();
outputStream.close();


int statusCode = connection.getResponseCode();	获取响应码，判断请求是否成功。

InputStream inputStream = statusCode == 200 ? connection.getInputStream() : connection.getErrorStream();			读取响应数据。
BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
StringBuilder response = new StringBuilder();
String line;
while ((line = reader.readLine()) != null) {
    response.append(line);
}
reader.close();
inputStream.close();
protected HttpURLConnection (URL u)

ServerSocket
package java.net;
public class ServerSocket implements java.io.Closeable

public Socket accept() throws IOException
Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made.

A new Socket s is created and, if there is a security manager,
the security manager's checkAccept method is called with s.getInetAddress().getHostAddress() and s.getPort() as its arguments to ensure the operation is allowed.
This could result in a SecurityException.
URLDecoder
package java.net;
public class URLDecoder       urlj解码器
public static String decode(String s, String enc) throws UnsupportedEncodingException       用编码解码一个字符串   // URLDecoder.decode(keyFileName, "UTF-8"))
java.nio
Buffer
package java.nio;
public abstract class Buffer       缓冲区，实际上是一个容器，是一个连续数组。
Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer

             上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送 数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。
              服务端这边接收数据必 须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。
              在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer


public final Buffer limit(int newLimit)      A container for data of a specific primitive type.
ByteBuffer
package java.nio;
public abstract class ByteBuffer  extends Buffer   implements Comparable<ByteBuffer>      A byte buffer, This class defines six categories of operations upon byte buffers

public static ByteBuffer wrap(
byte[] array,     将备份新缓冲区的数组
int offset,        子数组偏移量，必须为非负数
int length       子数组长度
)
public static ByteBuffer allocate(int capacity)       Allocates a new byte buffer.
channels
Selector
package java.nio.channels;
public abstract class Selector implements Closeable    Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理。 （只是用一个单线程就可 以管理多个通道，也就是管理多个连接）
只有在连接真正有读写事件发生时，才会调用 函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护 多个线程，并且避免了多线程之间的上下文切换导致的开销。

用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络链接。
JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU100%。
官方声称在JDK1.6版本的update18修复了该问题，但是直到DK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决
Netty解决办法：
有事件发生，wakeup时返回值不为0，可以跳出循环。
超时有时间戳记录。
所以每次空轮询，有专门的计数器+1，如果空轮询的次数超过了512次，就认为其触发了空轮询bug。
触发bug后，netty直接重建一个selector，将原来的channel重新注册到新的selector上，将旧的selector关掉


public static Selector open() throws IOException      创建一个Selector对象

public abstract int select() throws IOException;    通 过 select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这 种方式会导致用户线程的阻塞。
select()方法返回的int值表示有多少通道已经就绪，是自上次调用select()方法后有多少通道变成就绪状态。
之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。
selector有4种情况会跳出阻塞：有事件发生，wakeup，超时，空轮询bug
public abstract int select(long timeout) throws IOException;        和select()一样，但最长阻塞时间为timeout毫秒。
public abstract int selectNow() throws IOException;         非阻塞，只要有通道就绪就立刻返回
Channel
package java.nio.channels;
public interface Channel extends Closeable         Channel 和 IO 中的 Stream(流)是差不多一个 等级的。
Stream 是单向的（InputStream，OutputStream），而 Channel 是双向 的，既可以用来进行读操作，又可以用来进行写操作。
NIO 中的 Channel 的主要实现有：
FileChannel              文件 IO
DatagramChannel        UDP
SocketChannel            TCPClient
ServerSocketChannel      TCPServer
SocketChannel
package java.nio.channels;
public abstract class SocketChannel
    extends AbstractSelectableChannel
    implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel

public abstract int read(ByteBuffer dst) throws IOException;
public abstract int write(ByteBuffer src) throws IOException;

SelectableChannel
package java.nio.channels;
public abstract class SelectableChannel
    extends AbstractInterruptibleChannel
    implements Channel

ServerSocketChannel
package java.nio.channels;
public abstract class ServerSocketChannel
    extends AbstractSelectableChannel
    implements NetworkChannel

public static ServerSocketChannel open() throws IOException
Opens a server-socket channel for an Internet protocol socket.

public abstract SocketChannel accept() throws IOException;
Accepts a connection made to this channel's socket.
If this channel is in non-blocking mode then this method will immediately return null if there are no pending connections.
Otherwise it will block indefinitely until a new connection is available or an I/O error occurs.

public final ServerSocketChannel bind(SocketAddress local)  throws IOException
Binds the channel's socket to a local address and configures the socket to listen for connections.
An invocation of this method is equivalent to the following:
  bind(local, 0);

spi
AbstractSelectableChannel
package java.nio.channels.spi;
public abstract class AbstractSelectableChannel
    extends SelectableChannel

public final SelectableChannel configureBlocking(boolean block) throws IOException
Adjusts this channel's blocking mode.

charset
Charset
package java.nio.charset;
public abstract class Charset     字符集

public static Charset defaultCharset()                          返回java虚拟机的默认字符集
public static Charset forName(String charsetName)    根据名称获取字符集
public final String name()    获取当前字符集的经典名称
StandardCharsets
package java.nio.charset;
public final class StandardCharsets    标准字符集
public static final Charset US_ASCII = Charset.forName("US-ASCII");
public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
public static final Charset UTF_8 = Charset.forName("UTF-8");
public static final Charset UTF_16BE = Charset.forName("UTF-16BE");
public static final Charset UTF_16LE = Charset.forName("UTF-16LE");
public static final Charset UTF_16 = Charset.forName("UTF-16");                   Sixteen-bit UCS Transformation Format, byte order identified by an optional byte-order mark
file
Files [CORE]
package java.nio.file;
public final class Files      文件工具
java.nio.file.Paths    路径工具

public static Stream<Path> walk(Path start, FileVisitOption... options) throws IOException     遍历文件夹（包含子文件夹及子其文件），遍历结果是一个Stream

public static Path copy(Path source, Path target, CopyOption... options) throws IOException   拷贝文件
public static List<String> readAllLines(Path path, Charset cs) throws IOException       读取所有行
public static byte[] readAllBytes(Path path) throws IOException      读取所有字节
public static String readString(Path path) throws IOException         读取所有字符串
		Path filePath = Paths.get("C:/", "temp", "test.txt");
		String content = Files.readString(filePath);
public static Path writeString(
Path path,                      写入路径
CharSequence csq,        写入字符串
Charset cs,                     编码
OpenOption... options)
throws IOException

// Files.writeString(Path.of(accountFile.toString()),fileContent, StandardOpenOption.WRITE);   StandardOpenOption will prevent writing to this file.
public static Path writeString(
Path path,
CharSequence csq,
OpenOption... options)
throws IOException

// Files.writeString(Path.of(accountFile.toString()),fileContent, StandardOpenOption.WRITE);
public static Path walkFileTree(      Recursively traverses the directory tree.
Path start,
           Set<FileVisitOption> options,
           int maxDepth,
           FileVisitor<? super Path> visitor)
public static Path createTempFile(
String prefix,
String suffix,
FileAttribute<?>... attrs
) throws IOException
OpenOption
package java.nio.file;
public interface OpenOption
StandardOpenOption
package java.nio.file;
public enum StandardOpenOption implements OpenOption  标准打开方式
READ,         标准读
WRITE,       标准写
APPEND,    WRITE写入时，追加
TRUNCATE_EXISTING,     WRITE写入时，文件长度会被截断为0
CREATE,                          不存在就创建，CREATE_NEW存在时此选项将会被忽略
CREATE_NEW,                 创建新文件
DELETE_ON_CLOSE,        关闭时删除
SPARSE,                          CREATE_NEW创建新文件时，创建稀疏文件
SYNC,                             文件内容和元数据同步写入
DSYNC;                           文件内容同步写入
Paths
package java.nio.file;
public final class Paths      路径工具
public static Path get(String first, String... more)      Splicing Path   // Paths.get("D:\\Desktop\\DevProject\\saidake-manage-project\\smp-service\\smp-oracle\\src\\test\\java\\com\\saidake\\target.properties");
public static Path get(URI uri)                                   Obtain path based on URI
Path
package java.nio.file;
public interface Path  extends Comparable<Path>, Iterable<Path>, Watchable
public static Path of(String first, String... more)    Create a Path
public static Path of(URI uri)                                 Create a Path based on the resource path.
Path getRoot();                                                    Root Path         //    D:\
Path getFileName();                                             File Name          //    test.txt
String toString();                                                  Output path      //   D:\Desktop\DevProject\saidake-manage-project\sdk-service\sdk-generator\src\test\java\com\saidake\test.txt
Path resolve(Path other);                                    Join a other path
Watchable
package java.nio.file;
public interface Watchable
FileVisitor
package java.nio.file;
public interface FileVisitor<T>
FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException;    Called before accessing any directory.
FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException;                  Called after accessing any directory.
FileVisitResult visitFileFailed(T file, IOException exc) throws IOException;                     Called when accessing each file.
FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException;              Called on file access failure.
FileVisitResult
package java.nio.file;
public enum FileVisitResult
CONTINUE,            Continue the traversal.
TERMINATE,           Immediately terminates the traversal.
SKIP_SUBTREE,       Continue without visiting the entries in this directory. This result is only meaningful when returned from the preVisitDirectory method;
                              Otherwise this result type is the same as returning CONTINUE.
SKIP_SIBLINGS;      Continue without visiting the siblings of this file or directory. If returned from the preVisitDirectory method then the entries in the directory are also skipped
                              and the postVisitDirectory method is not invoked.


java.security
Security
package java.security;
public final class Security   管理提供者

public static int addProvider(Provider provider)   添加提供者
AccessController
package java.security;
public final class AccessController   访问控制器
public static native <T> T doPrivileged(PrivilegedAction<T> action);   允许在一个类实例中的代码通知这个AccessController：它的代码主体是享受"privileged(特权的)
在做访问控制决策时，如果checkPermission方法遇到一个通过doPrivileged调用而被表示为 "特权"的调用者，并且没有上下文自变量，checkPermission方法则将终止检查。
如果那个调用者的域具有特定的许可，则不做进一步检查，checkPermission安静地返回，表示那个访问请求是被允许的；
如果那个域没有特定的许可，则象通常一样，一个异常被抛出。
MessageDigest [CORE]
package java.security;
public abstract class MessageDigest extends MessageDigestSpi       为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。简单点说就是用于生成 散列码。
信息摘要：将长度不固定的消息（message）作为输入参数，运行特定的Hash函数，生成固定长度的输出，这个输出就是Hash，也称为这个消息的消息摘要(Message Digest)
散列码：通过一种不可逆的散列（Hash）算法，对一个数据进行计算，获得一个唯一的值。这个值可以对这个数据进行标识，在查找数据的时候，可以通过这个值来快速定位数据，从而有效减少开销。

javax.crypto.Cipher
public Object clone() throws CloneNotSupportedException   如果实现是可复制的，则返回一个副本。
public byte[] digest()                           通过执行诸如填充之类的最终操作完成哈希计算。
public byte[] digest(byte[] input)       使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。
public int digest(byte[] buf, int offset, int len) throws DigestException       通过执行诸如填充之类的最终操作完成哈希计算。


public void update(byte input)                         使用指定的字节更新摘要。
public void update(byte[] input)                        使用指定的字节数组更新摘要。
public void update(byte[] input, int offset, int len)       使用指定的字节数组，从指定的偏移量开始更新摘要。
public final void update(ByteBuffer input)      使用指定的 ByteBuffer 更新摘要。

public final String getAlgorithm()    返回标识算法的独立于实现细节的字符串。
public final int getDigestLength()  返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。
public final Provider getProvider()    返回此信息摘要对象的提供程序。
public void reset()      重置摘要以供再次使用。

public static MessageDigest getInstance(String algorithm) throws NoSuchAlgorithmException      生成实现指定摘要算法的 MessageDigest 对象。
algorithm=
MD5
SHA
SHA1
SHA-224
SHA-256
SHA-384
SHA-512
public static MessageDigest getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException        生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。


public static boolean isEqual(byte[] digesta, byte[] digestb)    比较两个摘要的相等性。


Usage
    public static String encryptMode(String str, String mode) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(mode);
        md.update(str.getBytes());
        byte[] bt = md.digest();
        StringBuffer buffer = new StringBuffer();
        for (int i = 0; i < bt.length; i++) {
            buffer.append(Character.forDigit((bt[i] & 240) >> 4, 16));      Number
            buffer.append(Character.forDigit(bt[i] & 15, 16));                   String
        }
        return buffer.toString();
    }
KeyStore
package java.security;
public class KeyStore   单纯的存储证书、秘钥数据，不包含任何逻辑。（可以是有私钥的Keystore，也可以是只有公钥的Keystore）

public static KeyStore getInstance(String type)    返回一个指定类型的KeyStore对象 【JKS, PKCS12 】
public final static String getDefaultType()             获取默认KeyStore类型jks
public final void load(InputStream stream, char[] password)   throws IOException, NoSuchAlgorithmException, CertificateException   从输入流中加载一个证书，即使是新文件证书，也需要调用  // load(null, "xxx")
public final void store(OutputStream stream, char[] password) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException     保存
public final String getType()    获取证书类型
public final Enumeration<String> aliases()  throws KeyStoreException     获取证书内的所有 alia
public final boolean isKeyEntry(String alias)   throws KeyStoreException     alia是否是一个 密钥对
public final Key getKey(String alias, char[] password)  throws KeyStoreException, NoSuchAlgorithmException,    UnrecoverableKeyException     返回和alia关联的key
public final Certificate[] getCertificateChain(String alias) throws KeyStoreException             返回和alia关联的 证书链
public final Certificate getCertificate(String alias) throws KeyStoreException                        返回和alia关联的 证书（私钥只有一个）
public final void setKeyEntry(String alias, Key key, char[] password,  Certificate[] chain) throws KeyStoreException     设置一个 密钥对
Key
package java.security;
public interface Key extends java.io.Serializable    密钥
public byte[] getEncoded()    获取编码内容

读取密钥————————————————————————————————————————————————————————————
ObjectInputStream ois = new ObjectInputStream(new FileInputStream(path));
Key key = Key.class.cast(ois.readObject());
ois.close();
PrivateKey
package java.security;
public interface PrivateKey extends Key, javax.security.auth.Destroyable    私钥
PublicKey
package java.security;
public interface PublicKey extends Key   公钥
KeyPair
package java.security;
public final class KeyPair implements java.io.Serializable   密钥对，包括公钥和私钥，私钥需要有自己的密钥（PrivateKey）

public KeyPair(PublicKey publicKey, PrivateKey privateKey)
KeyPairGenerator
package java.security;
public abstract class KeyPairGenerator extends KeyPairGeneratorSpi     密钥对生成器
public static KeyPairGenerator getInstance(String algorithm, String provider) throws NoSuchAlgorithmException, NoSuchProviderException   获取 实例
algorithm= RSA     算法
provider= SUN      提供者
public static KeyPairGenerator getInstance(String algorithm) throws NoSuchAlgorithmException    根据算法获取实例
public void initialize(int keysize)    初始化   //  initialize(2048)
public KeyPair generateKeyPair()     生成生成 根证书公钥与私钥对
Signature
package java.security;
public abstract class Signature extends SignatureSpi  签名
public static Signature getInstance(String algorithm) throws NoSuchAlgorithmException  获取一个实现了签名算法的签名
public final void initVerify(Certificate certificate) throws InvalidKeyException    初始化用于验证的对象，使用证书的公钥
public final void update(byte[] data) throws SignatureException         更新证书信息，用于验证
public final boolean verify(byte[] signature) throws SignatureException       验证证书的签名
SecureRandom
package java.security;
public class SecureRandom extends java.util.Random
public static SecureRandom getInstance(String algorithm) throws NoSuchAlgorithmException   生成指定算法的 安全随机生成器     // SecureRandom.getInstance("SHA1PRNG");

synchronized public void setSeed(byte[] seed)        重新设置此随机对象的种子。给定的种子补充而不是替换现有种子。因此，保证重复调用永远不会降低随机性。
Certificate
package java.security.cert;
public abstract class Certificate implements java.io.Serializable     证书
数字证书有多种文件编码格式，主要包含CER编码、DER编码等：
CER(Canonical Encoding Rules，规范编码格式)：                    是数字证书的一种编码格式，它是BER(Basic Encoding Rules，基本编码格式)的一个变种，比BER规定得更加严格。
DER(Distinguished Encoding Rule, 卓越编码格式)：                同样是BER的一个变种，与CER不的同之处在于：DER使用定长模式，而CER使用变长模式。
PKCS(Public-Key Cryptography Standards，公钥加密标准)：  由RSA实验室和其它安全系统开发商为促进公钥密码发展而制定的一系列标准。
其中CER、DER格式证书都符合公钥基础设施（PKI）制定的X509国际标准（X.509标准），统称为X509格式证书。
数字证书中包含的信息：版本号、序列号、签名算法、签名哈希算法、颁发者ISSUER、有效期、使用者SUBJECT、公钥、指纹、指纹算法，扩展属性信息。
DN： Distinguish Name   颁发者或使用者的 标识名称
       格式：CN=姓名，OU=组织单位名称，O=组织名称，L=城市或区域名称，ST=省/市/自治区名称，C=国家双字母
       浏览器验证时，CN与域名完全一致。
 指纹：指纹是一个证书的签名，是通过指纹算法sha1计算出来的一个hash值，用于验证证书内容是否有被篡改。
          证书在发布前，CA机构会把所颁发证书的内容通过指纹算法计算得到一个hash值，并用自己的根私钥加密，得到一个签名，  这个加密hash值只有对应的公钥才能解密
         所以在验证证书时，使用同样的指纹算法将证书内容计算得到一个hash值，与公钥解密的hash进行比对，就代表证书没有被篡改过。

证书颁发：其实就是使用证书颁发者的私钥对证书使用者的证书进行签名，并设置使用者证书的颁发者，证书一般情况下需要由权威的证书认证机构颁发，其原因就是对证书进行签名使用的是私钥，私钥只有颁发机构才有
证书验证：获取证书颁发机构，从系统中寻找此颁发机构是否为信任机构。
                 指纹验证证书是否被篡改

CA机构：GeoTrust，
根证书：CA机构除了给别人颁发证书外，它自己也有证书，也就是根证书。
             根证书也有自己的公钥和私钥，称为根公钥和根私钥，根公钥加密算法是向外公布的，根私钥是保密的
自签名证书：使用的数字签名是网站自己的私钥，而不是来自CA
             使用自签名证书，没有外部权威机构验证服务器是否是它声称的身份，浏览器认为自签名证书不可信。


.p12、.pfx        PKCS12 为个人信息交换语法标准，故个人信息证书采用该格式
.p10、.csr         PKCS10 为证书请求语法标准，故证书请求文件采用该格式
.p7b、.p7c、.spc    PKCS7为密码消息语法标准
public abstract PublicKey getPublicKey()   获取证书的公钥
public abstract byte[] getEncoded() throws CertificateEncodingException   返回此证书的编码结果  //  FileOutputStream fos = new FileOutputStream("H:/certtest/ca.cer ");    fos.write(encoded);        fos.close()
X509Certificate
package java.security.cert;
public abstract class X509Certificate extends Certificate implements X509Extension   X.509证书，提供了一个标准访问X.509证书的所有属性的方法

public abstract String getSigAlgName()       获取证书的签名算法  //  SHA256withRSA
public abstract byte[] getTBSCertificate() throws CertificateEncodingException      获取DER编码的证书信息
public abstract byte[] getSignature()           获取证书的签名
CertificateFactory
package java.security.cert;
public class CertificateFactory   证书工厂
public static final CertificateFactory getInstance(String type) throws CertificateException    获取一个证书工厂实例   // CertificateFactory.getInstance("X.509");
public final Collection<? extends Certificate> generateCertificates(InputStream inStream) throws CertificateException      生成一个证书
RSAPublicKeySpec
package java.security.spec;
public class RSAPublicKeySpec implements KeySpec     RSA公钥
public RSAPublicKeySpec(BigInteger modulus, BigInteger publicExponent)
public BigInteger getModulus()             获取模数
public BigInteger getPublicExponent()   获取公共指数
X500Principal
package javax.security.auth.x500;
public final class X500Principal implements Principal, java.io.Serializable     X.500  证书颁发者/证书使用者 标识名（" CN=Digicert, OU=Digicert, O=Digicert, L=Linton, ST=Utah, C=US "）

public X500Principal(String name)     构建一个标识名
public abstract byte[] getTBSCertificate() throws CertificateEncodingException      获取DER编码的证书信息
java.sql
连接
DataSource
public interface DataSource       自定义数据库连接池

Connection getConnection()      获取内部自定义数据库连接成员
DriverManager
package java.sql;
public class DriverManager      驱动管理对象

public static synchronized void registerDriver(java.sql.Driver driver)                                  注册驱动 Class.forName("com.mysql.jdbc.Driver")
public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da)
private static Connection getConnection(String url,  java.util.Properties info,  Class<?> caller)    获取数据库连接
public static Connection getConnection(String url,  String user,  String password)
Connection
package java.sql;
public interface Connection extends Wrapper, AutoCloseable     数据库连接


Statement createStatement()                      获取执行者对象
PreparedStatement prepareStatement(String sql)   获取预编译执行者对象（对sql进行预编译，明确sql的格式后，就不会改变了，避免sql注入攻击）
void setAutoCommit(boolean autoCommit)        参数为false开启事务
void commit()   提交事务
void rollback()   回滚事务
数据类型
Timestamp
package java.sql;
public class Timestamp extends java.util.Date        时间戳类型（timestamp）
public Timestamp(int year, int month, int date, int hour, int minute, int second, int nano)   时间数字
public Timestamp(long time)   时间戳类型

public static Timestamp from(Instant.now())    获取时间  2021-03-31 04:08:28
public static Timestamp valueOf(String s)      转换为时间，格式必须为yyyy-[m]m-[d]d hh:mm:ss[.f...]    // "2018-05-18 09:32:32"
public String toString()               转换为字符串，格式为       yyyy-mm-dd hh:mm:ss.fffffffff       // 2022-03-02 11:22:33.0
Date
package java.sql;
public class Date extends java.util.Date      java.sql.Date只是一个java.util.Date，其时间设置为yyyy-mm-dd
public static Date valueOf(String s)           转换为日期，格式必须为 yyyy-[m]m-[d]d   // 2222-12-22    2222-1-2
public String toString ()                 转换为字符串，格式为  yyyy-mm-dd
Time
package java.sql; （datetime）
public static Time valueOf(String s)   时间，格式必须为   hh:mm:ss    //   3:3:3
public String toString ()                     转换为字符串，格式为  hh:mm:ss
数据操作
Statement
package java.sql;
public interface Statement extends Wrapper, AutoCloseable

ResultSet executeQuery(String sql)             执行查询
void addBatch( String sql ) throws SQLException;  将sql添加到批处理中，等待统一执行（批处理不支持select）
int[] executeBatch() throws SQLException;         统一执行sql（缓存了多个Statement，等待executeBatch逐一执行）

PreparedStatement
package java.sql;
public interface PreparedStatement extends Statement    预编译处理

ResultSet executeQuery() throws SQLException;
ResultSet
package java.sql;
public interface ResultSet extends Wrapper, AutoCloseable

boolean next()
String getString(int columnIndex)       根据列名索引获取数据
DatabaseMetaData
package java.sql;
public interface DatabaseMetaData extends Wrapper     数据库的源信息


String getDatabaseProductName()       获取数据库产品名称
String getDatabaseProductVersion()      获取数据库产品版本号
ParameterMetaData
package java.sql;
public interface ParameterMetaData extends Wrapper     参数的源信息

int getParameterCount()  获取sql中参数的个数
ResultSetMetaData
package java.sql;
public interface ResultSetMetaData extends Wrapper

int getColumnCount()                  获取列总数
String getColumnName(int column)     获取列名
实例
jdbc连接参数：  jdbc:mysql://192.168.22.129:8083/test_spring?verifyServerCertificate=false

user=xxx					用户名
password=xxx				密码
autoReconnect=true		联机失败,是否重新联机
maxReconnect=3			尝试重新联机次数
initialTimeout=3			尝试重新联机间隔
maxRows=200			传回最大行数
useUnicode=true			是否使用Unicode 字体编码
characterEncoding=UTF-8	何种编码，GB2312/UTF-8
relaxAutocommit=true		是否自动提交
capitalizeTypeNames=true	数据定义的名称以大写表示
userSSL=false               是否使用ssl连接

手动连接数据库：
    public static void connectDb(){
        //声明驱动类
        Class jdbcDriverClass;
        //声明数据库连接
        Connection conn = null;
        try {
            //加载驱动类
            jdbcDriverClass = Class.forName("com.mysql.cj.jdbc.Driver");
            //创建驱动
            Driver driver = (Driver) jdbcDriverClass.newInstance();
            //注册驱动
            DriverManager.registerDriver(driver);
            //创建连接
            conn = (Connection) DriverManager.getConnection("jdbc:mysql://192.168.22.129:8083/test_spring","labuladuo","balabala@@");
            Statement statement=conn.createStatement();
            ResultSet resultSet=statement.executeQuery("select * from student;");
            resultSet.next();
            System.out.println(resultSet.getString(2));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
(exception)
SQLRecoverableException
package java.sql;
public class SQLRecoverableException extends java.sql.SQLException      重试事务分支时，在以前失败的操作可能成功的情况下，抛出的SQLException的子类。恢复操作至少必须包括关闭当前连接和获取新连接

SQLException
package java.sql;
public class SQLException extends java.lang.Exception
                          implements Iterable<Throwable>
java.sql.SQLException: Fail to convert to internal representation		When the return result order does not match, an error will be reported

java.time
Instant
package java.time;
public final class Instant    implements Temporal, TemporalAdjuster, Comparable<Instant>, Serializable
时间类更新：
java.util.Date           ==>      java.time.Instant
java.sql.Timestamp ==>      java.time.Instant
java.sql.Date            ==>      java.time.LocalDate
java.sql.Time            ==>      java.time.LocalTime
public static final Instant EPOCH = new Instant(0, 0);                                                          时间原点 1970-01-01T00:00:00Z
public static final Instant MAX = Instant.ofEpochSecond(MAX_SECOND, 999_999_999);    时间最大值  +1000000000-12-31T23:59:59.999999999Z
public static final Instant MIN = Instant.ofEpochSecond(MIN_SECOND, 0);                        时间最小值  -1000000000-01-01T00:00:00Z
private final long seconds;     从时间原点 纪元1970-01-01T00:00:00Z开始的 秒数，时间戳
private final int nanos;           从秒字段开始沿时间线的纳秒数。它总是正的，并且永远不会超过999 999 999。

public static Instant now()     返回当前的Instant对象，这个构造方法不够精准，无法到纳秒级。
public static Instant ofEpochSecond(        纳秒级时间对象
long epochSecond,              从1970-01-01T00:00:00Z开始的秒数
long nanoAdjustment          对秒数的纳秒调整，无论是正的还是负的
)
public static Instant parse(final CharSequence text)   读取字符串为时间对象，格式必须为：2007-12-03T10:15:30.00Z
public long getEpochSecond()   获取时间戳                                                                                 // 155 557 4669
public int getNano()                  获取纳秒数                                                                                  // 633000000
public long toEpochMilli()         从时间原点 纪元1970-01-01T00:00:00Z开始的 毫秒数，时间戳  // 155 557 4669 633
public int compareTo(Instant otherInstant)   比较两个时间点
public boolean isAfter(Instant otherInstant)      是否在时间点之后
public boolean isBefore(Instant otherInstant)   是否在时间点之前
public Instant plusSeconds(long secondsToAdd)    加上秒数
public Instant plus(long amountToAdd, TemporalUnit unit)     加上指定类型的时间

LocalDate
package java.time;
public final class LocalDate  implements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable
一个不可变的时间日期对象，表示日期，表现为年月日（2010-10-10），在对LocalDate对象进行 加减修改操 作后，返回的都是一个不可变的新日期对象
public String format(DateTimeFormatter formatter)
public static LocalDate now()    获取当前时间
public static LocalDate of(int year, Month month, int dayOfMonth)      指定日期获取LocalDate对象 //  LocalDate.of(2022, 1, 1);
public static LocalDate parse(CharSequence text)    以固定格式的字符串获取LocalDate对象          //   LocalDate.parse("2023-03-01");
public static LocalDate parse(CharSequence text, DateTimeFormatter formatter)        以指定格式的字符串获取LocalDate对象
public static LocalDate now(ZoneId zone)             指定时区创建  // LocalDate.now(ZoneId.of("Asia/Shanghai"));
public int getYear()       获取年份
public int getMonthValue()      获取月份
public Month getMonth()        获取月份
public DayOfWeek getDayOfWeek()      获取星期几
public int getDayOfMonth()        一个月的哪一天，从1到31
public int getDayOfYear()           一年中的一天，从1到365，或闰年中的366
public LocalDate withYear(int year)   修改年份
public LocalDate withMonth(int month)   修改月份
public LocalDate withDayOfMonth(int dayOfMonth)   修改日期在当月的天数
public LocalDate withDayOfYear(int dayOfYear)           修改日期在当年的天数
public LocalDate plusYears(long yearsToAdd)           增加年份
public LocalDate minusYears(long yearsToSubtract)
public LocalDate plusMonths(long monthsToAdd)   增加月份
public LocalDate minusMonths(long monthsToSubtract)
public LocalDate plusWeeks(long weeksToAdd)       增加星期
public LocalDate minusWeeks(long weeksToSubtract)
public LocalDate plusDays(long daysToAdd)             增加日期
public LocalDate minusDays(long daysToSubtract)
public boolean isEqual(ChronoLocalDate other)     是否相等
public boolean isBefore(ChronoLocalDate other)
public boolean isAfter(ChronoLocalDate other)
public int compareTo(ChronoLocalDate other)
LocalDateTime
package java.time;
public final class LocalDateTime    本地日期时间
implements Temporal, TemporalAdjuster, ChronoLocalDateTime<LocalDate>, Serializable
一个不可变的时间日期时间对象，在对LocalDateTime对象进行 加减修改操 作后，返回的都是一个不可变的新日期时间对象


public static LocalDateTime now()    从系统中获取当前时间返回实例
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)     构造一个本地日期时间
public static LocalDateTime of(LocalDate date, LocalTime time)     合并两个时间
public static LocalDateTime now(Clock clock)     从指定时钟获取当前日期时间
public int getHour()      一天中的时间，从0到23
public int getMinute()      小时的分钟，从0到59
public int getSecond()     分钟的秒，从0到59
public int getNano()        秒的纳秒，从0到999999999

LocalTime
package java.time;
public final class LocalTime
        implements Temporal, TemporalAdjuster, Comparable<LocalTime>, Serializable  本地时间

Duration
package java.time;
public final class Duration        持续时间
        implements TemporalAmount, Comparable<Duration>, Serializable
public static Duration ofMillis(long millis)              获取表示多个标准小时数的持续时间
public static Duration ofMinutes(long minutes)       此方法返回以1分钟格式表示时间的Duration

ZoneId
package java.time;
public abstract class ZoneId implements Serializable   时区id
public static ZoneId of(String zoneId)                     获取指定时区   //  ZoneId.of("Asia/Shanghai")
GMT         前世界标准时，
UTC          现世界标准时。UTC 比 GMT更精准，以原子时计时，适应现代社会的精确计时。
GMT+8    东八区的时间

public static Set<String> getAvailableZoneIds()    获取地球所有时区id
Month
package java.time;
public enum Month implements TemporalAccessor, TemporalAdjuster    月份抽象
public Month firstMonthOfQuarter()      获取与本季度的第一个月对应的月份
public int minLength()     本月最少天数
public int getValue()        获取值，一年中的月份，从1月1日到12月12日
Clock
package java.time;
public abstract class Clock implements InstantSource   时钟
public static Clock systemUTC()    获取UTC时区时钟


DayOfWeek
package java.time;
public enum DayOfWeek implements TemporalAccessor, TemporalAdjuster       星期几
public int getValue()     从1（星期一）到7（星期日）
temporal
TemporalUnit
package java.time.temporal;
public interface TemporalUnit   临时单位
ChronoUnit
package java.time.temporal;
public enum ChronoUnit implements TemporalUnit  计时单位
NANOS("Nanos", Duration.ofNanos(1))              纳秒
MICROS("Micros", Duration.ofNanos(1000))       微秒
MILLIS("Millis", Duration.ofNanos(1000_000))    毫秒
SECONDS("Seconds", Duration.ofSeconds(1))    秒
MINUTES("Minutes", Duration.ofSeconds(60))    分钟
HOURS("Hours", Duration.ofSeconds(3600))       小时
HALF_DAYS("HalfDays", Duration.ofSeconds(43200))       半天
DAYS("Days", Duration.ofSeconds(86400))                      天数
WEEKS("Weeks", Duration.ofSeconds(7 * 86400L))         星期
MONTHS("Months", Duration.ofSeconds(31556952L / 12))     一个月
YEARS("Years", Duration.ofSeconds(31556952L))                    年
DECADES("Decades", Duration.ofSeconds(31556952L * 10L))  10年
CENTURIES("Centuries", Duration.ofSeconds(31556952L * 100L))    100年
MILLENNIA("Millennia", Duration.ofSeconds(31556952L * 1000L))   1000年
ERAS("Eras", Duration.ofSeconds(31556952L * 1000_000_000L))       一个纪元
FOREVER("Forever", Duration.ofSeconds(Long.MAX_VALUE, 999_999_999))    永远
TemporalAdjuster
package java.time.temporal;
public interface TemporalAdjuster     时间调整器
Temporal adjustInto(Temporal temporal);     将一个时间调整一下
public long between(Temporal temporal1Inclusive, Temporal temporal2Exclusive)     获取两个时间之前的  指定单位数量
获取两个日期之间的每一天
LocalDate startDate = LocalDate.parse("2021-09-01");
LocalDate endDate = LocalDate.parse("2021-10-20");

List<LocalDate> gapDays = new ArrayList<>();
Stream.iterate(endDate, d -> d.minusDays(1)).limit(ChronoUnit.DAYS.between(startDate, endDate) + 1).forEach(gapDays::add);
System.out.println(gapDays);
format
DateTimeFormatter
package java.time.format;
public final class DateTimeFormatter     日期时间格式器
public static final DateTimeFormatter ISO_LOCAL_DATE_TIME;          // 2023-03-03T10:36:08.72

public static DateTimeFormatter ofPattern(String pattern)    指定时间格式返回一个格式器    // DateTimeFormatter.ofPattern("yyyy-MM-dd");
java.text
DateFormat
package java.text;
public abstract class DateFormat extends Format

public Date parse(String source) throws ParseException       解析字符串返回日期对象     // parse("2021-08-06 00:00:01")
public final String format(Date date)                         格式化日期，返回字符串
SimpleDateFormat
package java.text;
public class SimpleDateFormat extends DateFormat       SimpleDateFormat是线程不安全的  // "yyyy-MM-dd HH:mm:ss";
yyyy：   年
MM：   月
dd：     日
d：     不显示前面的0的数字

hh：     1~12小时制(1-12)
h          不显示前面的0的数字
HH：    24小时制(0-23)
hh24          Hours (oracle, 0-23)
mm                 Minutes
mi             Minutes    (oracle)
ss：     秒
S：     毫秒
EEE  	   星期几     //  Tue
EEEE              星期几     // Tuesday
ZZZ 	   时区   //  CST
D：     一年中的第几天
F：     一月中的第几个星期(会把这个月总共过的天数除以7)
w：     一年中的第几个星期
W：    一月中的第几星期(会根据实际情况来算)
a：     上下午标识 AM  PM
k：     和HH差不多，表示一天24小时制(1-24)。
K：     和hh差不多，表示一天12小时制(0-11)
“MMMMM dd, yyyy”, Locale.ENGLISH       英文日期    // September 29, 2013
public SimpleDateFormat(String pattern)       构造  // new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")

public Date parse(String text, ParsePosition pos)
public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos)
NumberFormat
package java.text;
public abstract class NumberFormat extends Format     数字格式

public final static NumberFormat getPercentInstance()    获取百分比格式化对象
public final static NumberFormat getNumberInstance()    获取数字格式化对象
public void setMaximumIntegerDigits(int newValue)        设置数的整数部分所允许的最大位数
public void setMinimumIntegerDigits(int newValue)         设置数的 整数部分 所允许的最小位数

public void setMaximumFractionDigits(int newValue)       设置最多保留小数位数，不足不补0              // nf.setMaxmumFractionDigits( 2 )   nf.format( 3.66666 )
public void setMinimumFractionDigits(int newValue)       设置最少小数点位数，不足的位数以0补位，超出的话按实际位数输出。

public void setGroupingUsed(boolean newValue)     设置是否分组

public final String format(double number)     格式化小数
DecimalFormat
package java.text;
public class DecimalFormat extends NumberFormat      小数格式

public DecimalFormat(String pattern)       定义小数格式
new DecimalFormat("#.##").format(345.6666666)           345.67
new DecimalFormat("#.##").format(0.66666)                    0.67
new DecimalFormat("##,##.##").format(345.6666666)    3,45.67        每隔两位，自动省略前方0
new DecimalFormat("##,##.##").format(0.6666666)        0.67            每隔两位，自动省略前方0

new DecimalFormat("0.00").format(345.66666)                345.67
new DecimalFormat("0.00").format(0.66666)                    0.67
new DecimalFormat("00,00.00").format(345.6666666)      03,45.67     每隔两位，不省略0
new DecimalFormat("00,00.00").format(0.6666666)          00,00.67     每隔两位，不省略0

new DecimalFormat("#.00").format(345.66666)      345.67
new DecimalFormat("#.00").format(0.66666)          .67

java.util
(Data Type)
Collection
package java.util;
public interface Collection<E> extends Iterable<E>    集合，集合的派生类不支持多态，add只能指定一种类型，List、Set、Map、Quque
快速失败：在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行修改（增加、删除、修改)，则会抛出ConcurrentModificationException.
原理∶迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。
每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历;否则抛出异常，终止遍历。
注意∶这里异常的抛出条件是检测到modCount=expectedmodCount这个条件。如果集合发生变化时修改modCount值，刚好又设置为了expectedmodCount值，则异常不会抛出。
      因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

场景: java.util包下的集合类都是快速失败的，不能在多线程下发生并发迭代修改（迭代过程中被修改)。

安全失败：采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。
缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器可能访问不到修改后的内容（迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的）

场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

default Stream<E> stream()              串行流（适合存在线程安全问题、阻塞任务、重量级任务，以及需要使用同一事务的逻辑）  //  List<String> names = userList.stream().map( usera -> 22 ) .collect(Collectors.toList())
default Stream<E> parallelStream()      并行流，多线程异步任务（适合没有线程安全问题、较单纯的数据处理任务。）
Queue
package java.util;
public interface Queue<E> extends Collection<E>
boolean add(E e);   		Inserts the specified element into the tail of this queue if it is possible to do so immediately without violating capacity restrictions,
returning true upon success and throwing an IllegalStateException if no space is currently available.
E poll()
boolean offer(E e);		Inserts the specified element into the tail of this queue if it is possible to do so immediately without violating capacity restrictions.
When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
PriorityQueue
public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable
An unbounded priority queue based on a priority heap.
The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used.
A priority queue does not permit null elements. A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException).


public PriorityQueue(int initialCapacity)
Creates a PriorityQueue with the specified initial capacity that orders its elements according to their natural ordering.
Params:
initialCapacity – the initial capacity for this priority queue
Throws:
IllegalArgumentException – if initialCapacity is less than 1
Deque
package java.util;
public interface Deque<E> extends Queue<E>        Double ended queue, FIFO (First-In-First-Out) behavior results.

void addFirst(E e);
void addLast(E e);
E pollFirst();
E pollLast();

boolean offerFirst(E e);
boolean offerLast(E e);
E peekFirst();
E peekLast();

ArrayDeque
package java.util;
public class ArrayDeque<E> extends AbstractCollection<E> implements Deque<E>, Cloneable, Serializable      Resizable-array implementation of the Deque interface.
Stack
public class Stack<E> extends Vector<E>

public E push(E item)
public synchronized E pop()
public synchronized E peek()    找到栈顶的元素，长度0会报错
public boolean empty()         是否为空
List
package java.util;
public interface List<E> extends Collection<E>  数组，当类型为对象时，允许元素为null
Because the list stores object references, when an object is added to the list, it can be changed externally.
boolean add(E e);                                                             末尾追加元素
void add(int index, E element);                                         索引index添加元素，排开包括索引index和它后方的元素。
boolean addAll(Collection<? extends E> c);                     末尾追加List
boolean addAll(int index, Collection<? extends E> c);      索引index添加list，排开包括索引index和它后方的元素
boolean remove(Object o);                                                删除索引o的数据 或  删除值为o 的数据（后方元素前移）       // remove(2)   remove("xx")
boolean removeAll(Collection<?> c);                                删除值存在于c内部的数据（多个相同的值存在于原始list内会被全部删除）
E get(int index);                        获取值
E set(int index, E element);       设置值
int size();                                                          返回数组长度
boolean isEmpty();                                          是否为空
List<E> subList(int fromIndex, int toIndex)    返回子数组 [ 2, 9 )
Object[] toArray();                                             返回一个普通数组
default void sort(Comparator<? super E> c)   根据指定的比较器产生的顺序对该列表进行 排序，     //  listP.sort((x1,x2)->x1.getName().compareTo(x2.name))
         listP.sort((x1,x2)-> {           //自定义排序规则
           if(x1.getWeight()>x2.getWeight()){
               return 1;
           } else if(x1.getWeight()<x2.getWeight()){
               return -1;
           }else{
               return 0;
           }
         });
Arrays.stream(nameList)
default Spliterator<E> spliterator()     返回分流器
boolean tryAdvance(Consumer<? super T> action)      组合了迭代器的hasNext()和next() 方法
default void forEachRemaining(Consumer<? super T> action)      遍历剩下的元素
Spliterator<T> trySplit();                   分流
static <E> List<E> copyOf(Collection<? extends E> coll)              Returns an unmodifiable list containing the elements of the given Collection.
ArrayList
package java.util;
public class ArrayList<E>           ArrayList的底层数据结构是数组，查询数据快。默认初始值大小为10，容量不足时会扩容成原来的150%（第一次添加元素时，会将容量设置为10，如果容量不够，则每次会扩容成原来的150%）
extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable, java.io.Serializable
     当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。  因此，它适合随机查找和遍历，不适合插入和删除（适合查询多，增删少）

public ArrayList(Collection<? extends E> c)     This constructor can convert an immutable list into a modifiable one.
public ArrayList(int initialCapacity)


public void add(int index, E element)    在索引index插入元素
LinkedList
package java.util;
public class LinkedList<E>                               LinkedList（链表）是用链表结构存储数据的，将元素添加到链表的末尾，无需扩容，很适合数据的动态插入和删除，随机访问和遍历速度比较 慢。（适合查询少，增删多）
extends AbstractSequentialList<E>
implements List<E>, Deque<E>, Cloneable, java.io.Serializable

public LinkedList(Collection<? extends E> c)

public boolean add(E e)                     add 是加在list尾部，push 施加在list头部. 等同于addFirst
public E getFirst()     获取首元素
public E getLast()     获取尾元素
public void addFirst(E e)       添加首元素
public void addLast(E e)       添加尾元素
public E removeFirst()         移除首元素
public E removeLast()         移除尾元素

public E poll()                  将首个元素从队列中弹出，如果队列是空的，就返回null
public E peek()                 查看首个元素，不会移除首个元素，如果队列是空的就返回null
public E element()            查看首个元素，不会移除首个元素，如果队列是空的就抛出异常NoSuchElementException
public void push(E e)       添加首元素
public E pop()                  移除首元素
Vector
package java.util;
public class Vector<E>             主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。
extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable, java.io.Serializable
Vector（数组实现、线程同步访问） 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，效率比较低。默认初始值大小为10，容量不足时会扩容成原来的200% （第一次添加元素时，会将容量设置为10，如果容量不够，则每次会扩容成原来的200%）
public synchronized void insertElementAt(E obj, int index)        在指定索引插入元素
public synchronized void removeElementAt(int index)              在指定索引移除元素
public synchronized E elementAt(int index)                              获取指定索引的元素
public synchronized boolean add(E e)       添加元素并扩容
Set<T>
package java.util;
public interface Set<E> extends Collection<E>       去重集合
Set不能存放重复元素，无序的，只允许插入一个null 。
对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的。
如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。
boolean add(E e);    添加元素
void clear();          去掉集合中所有的元素
boolean remove(Object o);   移除一个元素
boolean contains(Object o);     判断集合中是否包含某一个元素
boolean isEmpty();              判断集合是否为空
nt size();                       返回集合的大小
Iterator<E> iterator();        返回一个迭代器 从上到下扫描    //   遍历while(iterator.hasNext()){E x=i.next()}
Object[] toArray();           转换成数组
HashSet
package java.util;
public class HashSet<E>          基于HashMap实现，初始最大容量16，初始容量=c.size()/.75f（因为无序，所以用iterator遍历）
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
HashSet（哈希表） 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存储的，所以取数据也是按照哈希值取得。
HashSet 通过 hashCode来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素
HashSet 首先判断两个元素的hashCode
如果hashCode值一样，接着会比较equals 方法， 如果 equls 结果为 true，HashSet 就视为同一个元素，不会存入。
如果 equals 为false 就不是同一个元素。在同样的哈希值下插入（哈希桶）


private transient HashMap<E,Object> map;

public HashSet(Collection<? extends E> c)
public HashSet(int initialCapacity, float loadFactor)
public HashSet(int initialCapacity)

public Iterator<E> iterator()
LinkedHashSet
package java.util;
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable     按照元素的加入顺序保存元素
继承HashSet、又基于 LinkedHashMap 来实现的。
LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法 操作上又与 HashSet 相同，
public LinkedHashSet(Collection<? extends E> c)     使用指定的初始容量和默认加载因子（0.75）构造一个新的空链接哈希集。
TreeSet
package java.util;
public class TreeSet<E>                基于TreeMap实现，默认排序规则为字母
    extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
是使用红黑树的原理对新add的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置
特点： 排序集合，元素默认自动排序。
public TreeSet(Comparator<? super E> comparator)     HashSet和LinkedSet都没有添加comparator的功能
BitSet
package java.util;
public class BitSet implements Cloneable, java.io.Serializable
public BitSet(int nbits)

public void set(int bitIndex, boolean value)     设置一个元素
public boolean get(int bitIndex)                       获取一个元素
Map
package java.util;
public interface Map<K,V>
不实现Cloneable和Serializable和语义相关，应由实现类决定是否需要这些功能
interface Entry<K, V>     键值对类
V setValue(V value);       设置值同步更新到map中
V put(K key, V value);      添加键值对（键已经存在就覆盖）
V get(Object key);          根据键获取值 （不存在返回null）
V remove(Object key);      根据键删除 键值对
boolean containsKey(Object key);         是否包含键
boolean containsValue(Object value);      是否包含值
default V getOrDefault(Object key, V defaultValue)          得到null时返回默认值

int size();                   获取大小
boolean isEmpty();          是否为空
void clear();                清空map
Set<K> keySet();            返回键Set
Set<Map.Entry<K, V>> entrySet();        获取 转换后的 键值对Set
default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)      将每个条目的值替换为对该条目调用指定函数的结果

computeIfAbsent
default V computeIfAbsent(K key,
        Function<? super K, ? extends V> mappingFunction) {
    Objects.requireNonNull(mappingFunction);
    V v;
    if ((v = get(key)) == null) {
        V newValue;
        if ((newValue = mappingFunction.apply(key)) != null) {
            put(key, newValue);
            return newValue;
        }
    }

    return v;
}

SortedMap
package java.util;
public interface SortedMap<K,V> extends Map<K,V>
Hashtable
package java.util;
public class Hashtable<K, V>                    线程安全，但效率太低（并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁，优先使用ConcurrentHashMap）
extends Dictionary<K, V>
implements Map<K, V>, Cloneable, Serializable
结构：由entry数组，链表组成，数组长度默认initialCapacity= 11，加载因子默认loadFactor=0.75，扩容的阈值threshold 表示存满11*0.75=8.25个元素后 哈希表就要扩容成原来的 （两倍+1）
存储过程：根据键的哈希值计算出应存入的索引
如果索引内为null则生成一个Entry对象放到数组进行存储（Hashtable计算hash是直接使用键的hashcode）
如果已经有值了，调用equals比较两个对象的属性值是否相同
属性值相同就不存，
属性值不同时，用头插法新的元素存入到数组中（老元素挂在新元素的下面形成链表结构，也叫哈系桶）
最后检测entry数组是否需要扩容。
多线程：在多线程情况下，Hashtable采用悲观锁的形式，只要有线程来访问，就锁住整张表（使用synchronized方法）
加载因子为什么0.75：加载因子如果比较大，扩容发生的频率就比较低，发生hash冲突的几率就比较大，容易造成其中一条链表过长影响性能
                     加载因子如果比较小，扩容发生的频率就比较高，会占用更多的空间，容易造成空间浪费。
0.75与泊松分布的关系：当负载因子=0.75，带入泊松分布公式中，计算出来长度为8时，概率=0.00000006，这个0.00000006概率已经很小了，所以链表长度为8时，转换成红黑树。
链表插入方式：1.7 和HashMap一样 采用的头插法，在多线程情况下，扩容rehash时，一定小几率下，会造成元素之间形成一个循环链表，get链表里的元素时会死循环了。
遍历：Hashtable支持Iterator和Enumeration两种遍历方式


private static class Entry<K,V>                键值对象
implements Map.Entry<K,V>
final int hash;
final K key;
V value;
Entry<K,V> next;
HashMap
package java.util;
public class HashMap<K, V>              非线程安全
extends AbstractMap<K, V>
implements Map<K, V>, Cloneable, Serializable
存储过程：根据键的哈希值计算出应存入的索引
使用hash算法计算key的索引，如果索引内为null则生成一个Entry对象放到数组进行存储（JDK1.7是Entry对象，JDK1.8是Node对象并且有二次hash）

1.7中，如果已经有值了，首先会判断是否需要扩容，如果要扩容就进行扩容，再生成Entry对象，并使用头插法添加到当前链表中（老元素挂在新元素的下面形成链表结构，也叫哈系桶）
1.8中，如果已经有值了，则会先判断当前位置上的Node类型
如果是链表节点的Node，则将key和value封装为一个Node并通过尾插法插入到链表的最后位置去（因为是尾插法，所以需要遍历链表，在遍历过程中会判断是否存在当前key，如果存在则更新其value）
当遍历完链表后，将新的Node插入到链表中
插入到链表后，会看当前链表的节点个数，如果大于8则会将链表转为红黑树
如果是红黑树TreeNode，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value。
插入完毕后再判断是否需要扩容，如果需要扩容，就结束put方法。
1.7原理：
结构：由entry数组，链表组成，数组长度默认initialCapacity= 18，加载因子默认loadFactor=0.75，扩容的阈值threshold 表示存满11*0.75=8.25个元素后 哈希表就要扩容成原来的 （两倍）【和HashTable在数据结构上是基本相同】
与Hashtable的不同：
HashMap中key和value都允许为null。最多只允许一条记录的key为 null ，key为null的键值对永远都放在以table[0]为头结点的链表中，所以get方法返回null时可能表示没有该键或键对应的值为null（HashTable键值都不能为null，会抛出NullPointerException异常）
HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模（Hashtable直接使用键的hashcode）
HashMap指定初始化容量initialCapacity时，会调用roundUpToPowerOf2方法比这个容量大的2的幂次方数，再用计算后的容量初始化    // 10 ==> 16
HashMap超出扩容的阈值后，哈希表就要扩容成原来的 两倍（Hashtable扩容两倍+1）
由于数组的容量是以2的幂次方扩容的，那么在扩容时，新的位置要么在原索引，要么在 原索引+原长度 的位置。
原因是数组长度变为原来的2倍，表现在二进制上就是多了一个高位参与数组下标计算。
也就是说，在元素拷贝过程不需要重新计算元素在数组中的位置，只需要看看原来的hash值新增的那个bit是1还是0，是0的话索引没变，是1的话索引变成 原索引+原长度oldCap（根据e.hash&oldCap ==0判断是否小于原数组长度)
这样可以省去重新计算hash值的时间，而且由于新增的1bit是0还是1可以认为是随机的，因此resize的过程会均匀的把之前的冲突的节点分散到新的bucket 。
HashMap把Hashtable的contains方法去掉了。
HashMap仅支持Iterator的遍历方式（Hashtable支持Iterator和Enumeration两种遍历方式）
1.8原理：
结构：由node数组，链表，红黑树组成。
不同：1.8链表中的元素超过了8个以后， 会将链表转换为红黑树
1.8 采用的尾插法，解决了扩容rehash时的循环链表问题，但是多线程情况下HashMap还是存在数据丢失问题，推荐使用ConcurrentHashMap



public HashMap(int initialCapacity, float loadFactor)

public V put(K key, V value)      如果table没有初始化就先进行初始化过程，再执行存储过程
public void clear()                    Removes all of the mappings from this map.  The map will be empty after this call returns.

public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)      如果给定的Key值不存在执行put(key, value)，如果存在则执行函数，旧值和新值组合成最终值      //  map.merge(word, 1, (prev, one) -> prev + one)
public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)           直接执行put(key, result)。 如果键的值不存在，则prev参数为null                               //  map.compute(word, (w, prev) -> prev != null ? prev + 1 : 1)
LinkedHashMap
package java.util;
public class LinkedHashMap<K,V>            记录插入顺序。  LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，
    extends HashMap<K,V>
    implements Map<K,V>
        在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序
IdentityHashMap
package java.util;
public class IdentityHashMap<K,V>      此类使用哈希表实现Map接口，在比较键和值时使用引用相等性代替对象相等性（使用a==b判断，而不是equals，Map接口的规则是比较对象时使用equals方法）
    extends AbstractMap<K,V>
    implements Map<K,V>, java.io.Serializable, Cloneable

public IdentityHashMap()
public IdentityHashMap(int expectedMaxSize)
public IdentityHashMap(Map<? extends K, ? extends V> m)
TreeMap
package java.util;
public class TreeMap<K,V>                   基于红黑树实现，能够把它保存的记录根据键排序，默认是按键值的升序排序， 也可以指定排序的比较器，
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
           当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。
在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常
Integer 和 String 对象都可以进行默认的 规则排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。
在覆写 compare()函数时，要返回相应的值才能使 TreeMap按照一定的规则来排序
比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。
Date
package java.util;
public class Date
    implements java.io.Serializable, Cloneable, Comparable<Date>
public Date(long date)
public void setTime(long time)    指定当前时间戳（毫秒值）
public long getTime()                  获取当前时间戳（毫秒值）   //  167 940 0168 936
使用——————————————————————————————————————————————————————————————————————————————————
Date dd =  new Date(2014-1900, 6-1, 12);   指定年月日，年份的参数是实际年份减1900，实际月份减1。
Date dd=   new Date(19999)               指定当前时间戳（毫秒值，13位）
UUID
package java.util;
public final class UUID
    implements java.io.Serializable, Comparable<UUID>
public static UUID randomUUID()          生成一个全局唯一的随机UUID    // 569b1416-c38e-4b67-9a47-2ffd303c3f79     uuid.toString().substring(24) = 2ffd303c3f79
public static UUID nameUUIDFromBytes(byte[] name)
Scanner
package java.util;
public final class Scanner implements Iterator<String>, Closeable    输入类     // Scanner k=new Scanner(System.in);

public Scanner(InputStream source)
public boolean hasNext()     是否有下一个（会阻塞住，直到关闭scanner）
public boolean hasNextLine()  是否有下一行（会阻塞住，直到关闭scanner）
public String nextLine()       返回字符串（回车截至输入，回车换行）
public String next()            返回字符串（空格截至输入，回车换行）

package java.util;
public interface Spliterator<T>     分流器，和迭代器Iterator不同的是，它可以隔断所有元素

Random
package java.util;
public class Random implements java.io.Serializable

public int nextInt()            		返回一个随机整数
public int nextInt(int bound)   取值范围：[0,bound)

PriorityQueue
package java.util;
public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable
An unbounded priority queue based on a priority heap.
The elements of the priority queue are ordered according to their natural ordering,
or by a Comparator provided at queue construction time, depending on which constructor is used.
A priority queue does not permit null elements.
A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException).
public PriorityQueue(Comparator<? super E> comparator)
// PriorityQueue<Integer> heap = new PriorityQueue<>((o1, o2) -> map[o2] - map[o1]);

Properties
package java.util;
public class Properties extends Hashtable<Object,Object>    是一个Map体系的集合类


public synchronized void load(InputStream inStream)             从输入字节流读取属性列表，load完毕stream可以关闭（键和元素对，properties文件）
public synchronized void load(Reader reader)                          从输入字符流读取属性列表，load完毕stream可以关闭（键和元素对，properties文件）
public synchronized Object setProperty(String key, String value)        设置集合的键和值，都是String类型，底层调用Hashtable方法put
public String getProperty(String key)                                       使用此属性列表中指定的键搜索属性
public Set<String> stringPropertyNames()                             从该属性列表中返回一个不可修改的集，其中健及其对应的值是字符由
public void store(OutputStream out, String comments)             将此属性列表(键和元素对)写入此Properties表中,以适合于使用load(InputStream)方法的格式写入输出字节流
public void store(Writer writer, String comments)                       将此属性列表（键和元素对）写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流
public synchronized void putAll(Map<?, ?> t)   合并一个properties文件或map集合
ResourceBundle
package java.util;
public abstract class ResourceBundle     xxx.properties文件操作类

public static final ResourceBundle getBundle(String baseName)       获取redis.properties文件
public final String getString(String key)                              获取键对应的值
EventObject
package java.util;

public class EventObject implements java.io.Serializable          事件对象
public Object getSource()       事件初始 源对象
EventListener
package java.util;
public interface EventListener    事件监听器
(Data Operation)
Arrays
package java.util;
public class Arrays   数组工具

public static <T> Stream<T> stream(T[] array)        	转换数组为流
普通数组转引用数组：int[] nums = {1,2,3};           IntStream stream = Arrays.stream(nums);        Stream<Integer> integerStream = stream.boxed();       Integer[] integers = integerStream.toArray(Integer[]::new);
public static <T> List<T> asList(T... a)             将普通数组转为ArrayList（add和remove数组方法不可用，容器长度不可变，普通类型不可用，不能传递给泛型）
The code "Arrays.asList( arr )" will convert original array as a single element to a new ArrayList.
public static String toString(Object[] a)                		打印数组
public static String toString(long[] a)   						数组转字符串 // [33, 44, 55]
public static <T> T requireNonNull(T obj, String message)     		为空抛出带有信息的空指针

public static <T> T[] copyOf(T[] original, int newLength)     			拷贝数组，指定新数组长度，不够补0
public static <T> T[] copyOfRange(T[] original, int from, int to)      拷贝数组，可指定子数组范围 [ from, to )


public static void fill(int[] a, int val)			Assigns the specified int value to each element of the specified array of ints.
public static <T> void sort(T[] a, Comparator<? super T> c)
public static void sort(Object[] a)
public static <T> void sort(T[] a, Comparator<? super T> c)			Sorts the specified array of objects according to the order induced by the specified comparator.
        Arrays.sort(envelopes, new Comparator<int[]>() {
            public int compare(int[] e1, int[] e2) {
                if (e1[0] != e2[0]) {
                    return e1[0] - e2[0];
                } else {
                    return e2[1] - e1[1];
                }
            }
        });

public static int binarySearch(int[] a, int fromIndex, int toIndex, int key)
Searches a range of the specified array of ints for the specified value using the binary search algorithm.  //  [ fromIndex , toIndex )
The range must be sorted (as by the sort(int[], int, int) method) prior to making this call.
If it is not sorted, the results are undefined.
If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
Returns:
index of the search key,
if it is contained in the array within the specified range; otherwise, (-(insertion point) - 1).
The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key,
or toIndex if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.


Base64
package java.util;
public class Base64

Collections
package java.util;
public class Collections       集合工具

public static final <T> List<T> emptyList()      返回一个空List，不可修改
public static final <T> Set<T> emptySet()      返回一个空Set，不可修改
public static <T> List<T> synchronizedList(List<T> list)     获取同步List，可用于 多个异步任务储存结果

public static boolean isEmpty(Collection coll)   判断数组是否为null或者数组长度为0
public static <T> List<T> synchronizedList(List<T> list)    返回一个线程安全的list

public static <T> void sort(List<T> list, Comparator<? super T> c)             使用Comparetor排序一个数组
// Collections.sort(employees, (o1, o2) -> o1.getName().compareTo(o2.getName()));
public static <T extends Comparable<? super T>> void sort(List<T> list)   排序一个数组

public static void reverse(List<?> list)                                     Reverse an array
// Collections.reverse(Arrays.asList(a));
public static <T> boolean addAll(Collection<? super T> c, T... elements)      将所有元素添加到一个集合中

static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m)       只读的Map，当你调用此map的put方法时会抛错
public static <T> List<T> unmodifiableList(List<? extends T> list)                            只读List
static class UnmodifiableCollection<E> implements Collection<E>, Serializable           产生只读的List
public static <E> Set<E> newSetFromMap(Map<E, Boolean> map)              根据Boolean的Map创建一个Set
Comparator
package java.util;
public interface Comparator<T>
A comparison function, which imposes a total ordering on some collection of objects.
Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow precise control over the sort order.
The item that wins during the comparison will be at the back of the array.
        int arr[][]=new int[][]{{1},{5},{4}};
        Arrays.sort(arr,(a,b)->a[0]-b[0]);
        System.out.println(arr[0][0]+" "+arr[1][0]+" "+arr[2][0]);
        // 1, 4, 5

        int arr[][]=new int[][]{{1},{5},{4}};
        Arrays.sort(arr, Comparator.comparingInt(a -> a[0]));
        System.out.println(arr[0][0]+" "+arr[1][0]+" "+arr[2][0]);
        // 1, 4, 5

int compare(T o1, T o2);
Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.

public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor)       将对象根据 键age从小到大排列     //  Comparator.comparingInt( XXClass::getAge )

public static <T, U extends Comparable<? super U>> Comparator<T> comparing( Function<? super T, ? extends U> keyExtractor )
public static <T, U> Comparator<T> comparing( Function<? super T, ? extends U> keyExtractor,  Comparator<? super U> keyComparator)
default <U extends Comparable<? super U>> Comparator<T> thenComparing( Function<? super T, ? extends U> keyExtractor)                        连接排序
public static <T> Comparator<T> nullsFirst(Comparator<? super T> comparator)      																								 针对null友好的比较器，null元素排在集合的最前面
//  Collections.sort(employees, Comparator.nullsFirst(Comparator.comparing(Employee::getName)));

public static <T extends Comparable<? super T>> Comparator<T> reverseOrder()     反转排序      //  Comparator.comparing(类::属性一, Comparator.reverseOrder());
public static <T extends Comparable<? super T>> Comparator<T> naturalOrder() 自然顺序

default <U> Comparator<T> thenComparing( Function<? super T, ? extends U> keyExtractor,  Comparator<? super U> keyComparator)          连接排序
                        // List<Fruit> listP2 = listP.stream().sorted(Comparator.comparing(Fruit::getName).reversed().thenComparing(Comparator.comparing(Fruit::getWeight).reversed())).collect(Collectors.toList());
default Comparator<T> reversed()                               反转    // stream.sorted(Comparator.reverseOrder())
ComparableTimSort
package java.util;
class ComparableTimSort
This is a near duplicate of TimSort, modified for use with arrays of objects that implement Comparable, instead of using explicit comparators.

static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen)

DualPivotQuicksort
package java.util;
final class DualPivotQuicksort
static void sort(int[] a, int left, int right,    int[] work, int workBase, int workLen)     排序一个数组   【排序数组，排序左索引，排序右索引   工作数组，工作数组基础可用空间，工作数组可用长度】
Enumeration
package java.util;
public interface Enumeration<E>      枚举（一次获得一个）对象集合中的元素，这种传统接口已被迭代器取代

boolean hasMoreElements()    测试此枚举是否包含更多的元素
E nextElement()                 如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素
使用————————————————————————————————————————————————————————————————
while(iter.hasMoreElements()) {
    String value= iter.nextElement();          能获得map中的每一个键值对了
}
EnumSet
package java.util;
public abstract class EnumSet<E extends Enum<E>>
    extends AbstractSet<E>
    implements Cloneable, java.io.Serializable

public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType)       创建一个包含指定枚举类里所有枚举值的EnumSet集合。
public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s)  创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，
									                                          新EnumSet集合包含原EnumSet集合所不包含的、此类枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来是该枚举类的所有枚举值）。
public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c)      	 使用一个普通集合来创建EnumSet集合。
public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s)  		 创建一个指定EnumSet具有相同元素类型、相同集合元素的EnumSet集合。
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType)   创建一个元素类型为指定枚举类型的空EnumSet。
public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4, E e5) 	  创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类。
public static <E extends Enum<E>> EnumSet<E> range(E from, E to)        		 创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合。
ImmutableCollections
AAA--SpringBoot.docx#hibernatePersistentBag
AAA--SpringBoot.docx#hibernateCollectionType
package java.util;
class ImmutableCollections
static UnsupportedOperationException uoe()
static abstract class AbstractImmutableCollection<E> extends AbstractCollection<E>
public void    clear()       Throw uoe
Iterator
package java.util;
public interface Iterator<E>   迭代器

boolean hasNext();      是否存在下一个对象元素
E next();                 获取下一个元素（从首个元素开始）
default void remove()    移除元素，不会导致快速失败
ListIterator
package java.util;
public interface ListIterator<E> extends Iterator<E>
使用————————————————————————————————————————————————————————————————
while(iter.hasNext()) {
    Entry obj = iter.next();          能获得map中的每一个键值对了
}
Local
package java.util;
public final class Locale implements Cloneable, Serializable           本机操作系统信息，包括语言、国家等信息
public static Locale getDefault(Locale.Category category)        获取操作系统的本地信息
public String getCountry()                    获取城市                //  CN
public final String getDisplayCountry()    获取显示的城市   // 中国
public String getLanguage()                     获取语言           // zh
public final String getDisplayLanguage()   获取显示语言  // 中文

public enum Category
DISPLAY("user.language.display",
                "user.script.display",
                "user.country.display",
                "user.variant.display"),
FORMAT("user.language.format",
               "user.script.format",
               "user.country.format",
               "user.variant.format");
Objects
package java.util;
public final class Objects   对象工具
public static <T> T requireNonNull(T obj)   对象为空抛出异常，不为空返回对象
public static int hash(Object... values)他      创建一个hash值
Optional
package java.util;
public final class Optional<T>

public static <T> Optional<T> of(T value)           创建一个Optional实例，value不能为空（null值时，会有空指针异常NullPointerException）      // Optional<User> opt = Optional.of(user);
public static <T> Optional<T> ofNullable(T value)   创建一个Optional实例，value可以为空


public void ifPresent(Consumer<? super T> consumer)       存在则操作，否则不操作      //  ifPresent( user -> log.info(u.getName())  );
public T get()                          获取创建创建时的值 value，使用orThrow更好，因为get null值时有异常
public boolean equals(Object obj)      判断其他Optional内的值是否等于 Optional的值
public boolean isPresent()                                   检查实例是否存在，等同 user != null，不建议使用
public T orElse(T other)                              存在时 直接返回实例，否则返回默认值
public T orElseGet(Supplier<? extends T> other)      存在时 直接返回实例，否则 通过方法来 设置返回值
public T orNull()                                         获取值，不存在返回null
public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X      值为空抛Supplier继承的异常         // orElseThrow( () -> new RuntimeException("出错啦") );


public <U> Optional<U> map(Function<? super T, ? extends U> mapper)            存在使用map方法获取Optional数据，并返回自动被Optional包装的 新数据，  不存在什么都不做 //  map( user -> user.getName() )
public <U> Optional<U> flatMap(Function<? super T, Optional<U>> mapper)    使用flatmap方法获取可能为null的真实数据，并返回 真实值，需要自己手动用Optional.ofNullable包装     // flatmap( user -> user.getName() )

使用————————————————————————————————————————————————————————————————————————————————————————
List<Integer> list1 = Lists.newArrayList(1, 2, 3);
Optional<List<Integer>> listOptional = Optional.fromNullable(list1);     遍历
listopt.transform(object -> {
    for (int i = 0; i < object.size(); i++) {
        object.set(i, object.get(i) + 1);
    }
    return object;                   返回新数组   // Optional.of([2, 3, 4])
}
OptionalInt
package java.util;
public final class OptionalInt

public int getAsInt()   获取整数值

Spliterator
package java.util;
public interface Spliterator<T>      抽象的能力就是对于一个源头的遍历（traverse）和分区（partition）的能力。
通过Spliterator来遍历数据流源头的每个元素（或者一个bulk的批量），也通过它来分区数据将其parallel并行化。


public static final int ORDERED    = 0x00000010;        是否有序
public static final int DISTINCT   = 0x00000001;          是否不同
public static final int IMMUTABLE  = 0x00000400;      是否不可变

boolean tryAdvance(Consumer<? super T> action);                      单个遍历的能力抽象
default void forEachRemaining(Consumer<? super T> action)      批量遍历的抽象
Spliterator<T> trySplit();                                                                 分区的抽象
Spliterators
package java.util;
public final class Spliterators    分流器工具
public static <T> Spliterator<T> spliterator(Object[] array, int fromIndex, int toIndex, int additionalCharacteristics)         构造一个分流器
public static <T> Spliterator<T> spliterator(Object[] array, int additionalCharacteristics)     构造一个分流器
public static <T> Spliterator<T> spliterator(Collection<? extends T> c,  int characteristics)    构造一个分流器


static class IteratorSpliterator<T> implements Spliterator<T>                      可遍历分流器
static final class DoubleArraySpliterator implements Spliterator.OfDouble   双精度 数组分流器

TimSort
package java.util;
class TimSort<T>
static <T> void sort(T[] a, int lo, int hi, Comparator<? super T> c,
                         T[] work, int workBase, int workLen)
(Time Operation)
Calendar
package java.util;
public abstract class Calendar implements Serializable, Cloneable, Comparable<Calendar>
public String getCalendarType()           The state method of this class.
protected abstract void computeTime();
abstract public void add(int field, int amount);      添加时间信息        //  add(Calendar.DATE, 30);

protected int           fields[];                Stores the current calendar time information.
public static Calendar getInstance()     获取当前系统时间实例
public final void set(int year, int month, int date, int hourOfDay, int minute, int second)         设置当前时间（年月日 时分秒）  //  set(2018, 1, 15,  23, 59, 59);
public void set(int field, int value)                             设置当前时间      // set(Calendar.YEAR, 2018);
public int get(int field)    获取年月日时分秒            //  get(Calendar.MONTH)+1

public final void setTime(Date date)         设置时间
public final Date getTime()                        获取date对象
public void setTimeInMillis(long millis)     设置时间戳时间
public long getTimeInMillis()                     时间戳（毫秒值）
final void internalSet(int field, int value)    Sets the value of given calendar field.
private int compareTo(long t)                    Implements the Comparable interface method.
private void updateTime()

public final static int ERA = 0;
public final static int YEAR = 1;            年份
public final static int MONTH = 2;       月份（从零开始）
public final static int DATE = 5;                        日期     // 11月30日    =>  30
public final static int DAY_OF_MONTH = 5;     日期
public final static int HOUR = 10;         小时
public final static int MINUTE = 12;       分钟
public final static int SECOND = 13;       秒

public final static int WEEK_OF_YEAR = 3;
public final static int WEEK_OF_MONTH = 4;
public final static int DAY_OF_MONTH = 5;
public final static int DAY_OF_YEAR = 6;
public final static int DAY_OF_WEEK = 7;
public final static int DAY_OF_WEEK_IN_MONTH = 8;

使用
Date date = new Date();//获取当前时间
System.out.println(date);
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//设置格式

Calendar calendar = Calendar.getInstance(); //创建Calendar 的实例
calendar.setTime(date);
calendar.add(Calendar.DAY_OF_MONTH, -1); //当前时间减去一天
System.out.println(simpleDateFormat.format(calendar.getTime()));

Calendar calendar2 = Calendar.getInstance();
calendar2.add(Calendar.MONTH, -1);//当前时间减去一个月
System.out.println(simpleDateFormat.format(calendar2.getTime()));

Calendar calendar3 = Calendar.getInstance();
calendar.add(Calendar.YEAR, -1);//当前时间减去一年
System.out.println(simpleDateFormat.format(calendar3.getTime()));
TimeZone
package java.util;
abstract public class TimeZone implements Serializable, Cloneable
GregorianCalendar
package java.util;
public class GregorianCalendar extends Calendar
private static final Gregorian gcal = CalendarSystem.getGregorianCalendar();
public GregorianCalendar(TimeZone zone, Locale aLocale)
public String getCalendarType()
protected void computeTime()
JapaneseImperialCalendar
package java.util;
class JapaneseImperialCalendar extends Calendar
public String getCalendarType()
protected void computeTime()
(Exceptions)
llegalFormatConversionException
package java.util;
public class IllegalFormatConversionException extends IllegalFormatException         String.format()不匹配的参数格式         //  String.format("ddd%d","ffff")
UnknownFormatConversionException
package java.util;
public class UnknownFormatConversionException extends IllegalFormatException     String.format()非法格式   // String.format("ddd%z","ffff")
EmptyStackException
package java.util;
public class EmptyStackException extends RuntimeException        空stack的pop()异常
ConcurrentModificationException
package java.util;
public class ConcurrentModificationException extends RuntimeException     当我们对集合进行 遍历 的时候，多线程同时对集合进行修改，就会产生并发修改
发生情况：
一边遍历集合，而另一边在修改集合时
在多线程进行插入操作时，由于没有进行同步操作，容易丢失数据。
NoSuchElementException
package java.util;
public class NoSuchElementException extends RuntimeException
logging
Logger
package java.util.logging;
public class Logger      日志
Logger的默认级别定义是在jre安装目录下
jre/lib/logging.properties  >>
# 缺省的全局级别.
.level= INFO

# 控制台级别
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
public static Logger getLogger(String name)       获取日志对象
public static Logger getLogger(String name, String resourceBundleName)      获取日志对象
public void severe(String msg)          打印日志
public void warning(String msg)      打印日志
public void info(String msg)           打印日志


Level
package java.util.logging;
public class Level implements java.io.Serializable   日志级别
public static final Level OFF = new Level("OFF",Integer.MAX_VALUE, defaultBundle);      关闭日志记录
public static final Level SEVERE = new Level("SEVERE",1000, defaultBundle);               最高值
public static final Level WARNING = new Level("WARNING", 900, defaultBundle);
public static final Level INFO = new Level("INFO", 800, defaultBundle);                       Logger默认的级别是INFO，比INFO更低的日志将不显示
public static final Level CONFIG = new Level("CONFIG", 700, defaultBundle);
public static final Level FINE = new Level("FINE", 500, defaultBundle);
public static final Level FINER = new Level("FINER", 400, defaultBundle);
public static final Level FINEST = new Level("FINEST", 300, defaultBundle);                  最低值
public static final Level ALL = new Level("ALL", Integer.MIN_VALUE, defaultBundle);       启用所有消息的日志记录
concurrent
 (data type)
CopyOnWriteArrayList
package java.util.concurrent;
public class CopyOnWriteArrayList<E>         CopyOnWriteArrayList是一个线程安全的List，底层是通过复制数组的方式来实现的。所谓的CopyOnWrite，就是写时复制。
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
原理：当我们往容器添加元素时,不直接往容器添加，而是先将当前容器进行复制，复制出一个新的容器，然后往新的容器添加元素，添加完元素之后，再将原容器的引用指向新容器。
优点：这样做的好处就是可以对CopyOnWrite容器进行并发的读而不需要加锁,因为当前容器不会被修改。
缺点：内存占用问题。由于CopyOnWrite的写时复制机制，在进行写操作的时候，内存里会同时驻扎两个对象的内存。
      CopyOnWrite容器不能保证数据的实时一致性，可能读取到旧数据。
ConcurrentHashMap
package java.util.concurrent;
public class ConcurrentHashMap<K, V>         ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。
    extends AbstractMap<K, V>
    implements ConcurrentMap<K, V>, Serializable
1.7：
结构：由数组Segment[]，小数组HashEntry[]，链表组成，Segment数组一旦创建不可扩容 默认长度16，小数组加载因子默认0.75
存储过程：
初始化时创建一个长度为2的小数组HashEntry[]，把地址值赋值给0索引，其他索引都是null
根据键的哈希值计算出应存入的索引，如果为null就根据索引0的模板创建一个小数组，不为null直接使用已有的的小数组。
再利用键的哈希值计算出在小数组HashEntry应存入的索引（二次哈希，超出2*0.75时，小数组就要扩容成原来的2倍）
如果为null直接添加
如果不为null，调用equals比较两个对象的属性值是否相同，属性值相同就不存，属性值不同就会把新的元素存入到数组中，老元素挂在新元素的下面形成链表结构（这个链表也称为哈希桶结构）
多线程：Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每 个 Segment 是线程安全的，也就实现了全局的线程安全（线程进入也会锁住小数组HashEntry[]）
        在默认情况下，最多允许16个线程同时访问。

1.8：
结构：由数组数组Node[]，链表，红黑树组成，结合CAS机制+synchronized同步代码块形式保证线程安全（synchronized1.6优化了）
存储过程：
根据键的哈希值计算出应存入的索引
如果为null则利用cas算法将结点添加到数组中
不为null则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。
当链表的长度大于等于8时，自动转换成红黑树
多线程：以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性。
在默认情况下，最多允许16个线程同时访问。
为什么使用红黑树：二叉树在极端情况下会退化成链表，全是左子树或全是右子树，时间复杂度变成O(n)，而avl平衡二叉树，但是任何节点的两个子树的高度差不大于1，条件太苛刻。
而红黑树折中一点，可以通过左旋右旋来调整树，使之符合红黑树的特征。




public ConcurrentHashMap() {}               构造函数什么都没做，会在第一次添加元素时初始化。
(thread pool)
Executors
package java.util.concurrent;
public class Executors     帮助创建线程池对象
newCachedThreadPool和newScheduledThreadPool 两个方法最大线程数为Integer.MAX_VALUE，如果达到上限，没有任务服务器可以继续工作，会抛出OOM异常（阿里禁用Executors原因）
newSingleThreadExecutor和newFixedThreadPool两个方法的workQueue参数为newLinkedBlockingQueue<Runnable>()，容量为Integer.MAX_VALUE，如果瞬间请求非常大，会有OOM风险。
线程池使用场景：数据分割成几分，开启多线程分别处理，最后将处理结果汇总

public static ExecutorService newCachedThreadPool()
        return new ThreadPoolExecutor( 0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());

Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available.
These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks.
Calls to execute will reuse previously constructed threads if available.
If no existing thread is available, a new thread will be created and added to the pool.
Threads that have not been used for sixty seconds are terminated and removed from the cache.
Thus, a pool that remains idle for long enough will not consume any resources.
Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.

public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)
Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
Params:
corePoolSize – the number of threads to keep in the pool, even if they are idle
Returns:
the newly created scheduled thread pool
Throws:
IllegalArgumentException – if corePoolSize < 0


public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)
Creates an Executor that uses a single worker thread operating off an unbounded queue.
(Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.)
Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time.
Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.
Returns:
the newly created single-threaded Executor

public static ExecutorService newFixedThreadPool(int corePoolSize, ThreadFactory threadFactory)
Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.
At any point, at most nThreads threads will be active processing tasks.
If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available.
If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.
The threads in the pool will exist until it is explicitly shutdown.
Params:
nThreads – the number of threads in the pool
Returns:
the newly created thread pool
Throws:
IllegalArgumentException – if nThreads <= 0
public static ThreadFactory defaultThreadFactory()
ExecutorService
package java.util.concurrent;
public interface ExecutorService extends Executor
An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks.

<T> Future<T> submit(Callable<T> task)
Submits a value-returning task for execution and returns a Future representing the pending results of the task.
The Future's get method will return the task's result upon successful completion.
Submits a value-returning task for execution and returns a Future representing the pending results of the task.
The Future's get method will return the task's result upon successful completion.
If you would like to immediately block waiting for a task, you can use constructions of the form result = exec.submit(aCallable).get();
Note: The Executors class includes a set of methods that can convert some other common closure-like objects,
for example, java.security.PrivilegedAction to Callable form so they can be submitted.
Params:
task – the task to submit
Returns:
a Future representing pending completion of the task
Throws:
RejectedExecutionException – if the task cannot be scheduled for execution
NullPointerException – if the task is null
void shutdown()
Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted.
Invocation has no additional effect if already shut down.
This method does not wait for previously submitted tasks to complete execution. Use awaitTermination to do that.
Throws:
SecurityException – if a security manager exists and shutting down this ExecutorService may manipulate threads that the caller is not permitted to modify because it does not hold RuntimePermission("modifyThread"),
or the security manager's checkAccess method denies access.

boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.
Params:
timeout – the maximum time to wait unit – the time unit of the timeout argument
Returns:
true if this executor terminated and false if the timeout elapsed before termination
Throws:
InterruptedException – if interrupted while waiting

ThreadPoolExecutor
package java.util.concurrent;
public class ThreadPoolExecutor extends AbstractExecutorService

private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
public ThreadPoolExecutor(
                          int corePoolSize,             								The number of threads that will always be kept in the pool, even if they are idle.
                          int maximumPoolSize,        							The maximum number of threads that can be created in the pool.
                          long keepAliveTime,          								The amount of time that idle threads will be kept in the pool before they are terminated.
                          TimeUnit unit,               									Specifies the time unit of the duration during which threads may remain idle.
                          BlockingQueue<Runnable> workQueue,    	The queue that will be used to hold tasks that are submitted to the executor
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)         This parameter specifies how the executor should handle tasks that are rejected because there are no available threads.

public static class AbortPolicy implements RejectedExecutionHandler                This is the default policy. It throws a RejectedExecutionException when a task is rejected.
public static class DiscardPolicy implements RejectedExecutionHandler             This policy silently discards the task when it is rejected. (no exception will be thrown)
public static class DiscardOldestPolicy implements RejectedExecutionHandler   When a new task is rejected, this policy discards the oldest task in the queue, and insert the new task.
public static class CallerRunsPolicy implements RejectedExecutionHandler        Runs the rejected task in the calling thread.

public int getPoolSize()

public void allowCoreThreadTimeOut(boolean value)
Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive.
When false, core threads are never terminated due to lack of incoming tasks.
When true, the same keep-alive policy applying to non-core threads applies also to core threads.
To avoid continual thread replacement, the keep-alive time must be greater than zero when setting true.
This method should in general be called before the pool is actively used.

public void execute(Runnable command)     执行任务
如果有空闲线程，则直接执行该任务
如果没有空闲线程，且当前线程数少于corePoolSize，则创建新的线程执行该任务；
如果没有空闲线程，且当前线程数等于corePoolSize，同时阻塞队列未满，则将任务入队列，而不添加新的线程；
如果没有空闲线程，且阻塞队列已满，同时池中的线程数小于maximumPoolSize ，则创建新的线程执行任务
如果没有空闲线程，且阻塞队列已满，同时池中的线程数等于maximumPoolSize ，则根据构造函数中的 handler 指定的拒绝策略来拒绝新的任务。
(blocking queue)
BlockingQueue
package java.util.concurrent;
public interface BlockingQueue<E> extends Queue<E>
A Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element,
and wait for space to become available in the queue when storing an element.

boolean add(E e);
Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions,
returning true upon success and throwing an IllegalStateException if no space is currently available.
When using a capacity-restricted queue, it is generally preferable to use offer.
Throws:
IllegalStateException 			 	if the element cannot be added at this time due to capacity restrictions
ClassCastException 					if the class of the specified element prevents it from being added to this queue
NullPointerException 				if the specified element is null
IllegalArgumentException 		if some property of the specified element prevents it from being added to this queue

void put(E e) throws InterruptedException;      Inserts the specified element into this queue, waiting if necessary for space to become available. (will block the thread)
E take() throws InterruptedException;              取出第一个数据，取不到会阻塞（组成生产者消费者模式）

boolean offer(E e);
Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions,
returning true upon success and false if no space is currently available.
When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
	Throws:
ClassCastException – if the class of the specified element prevents it from being added to this queue
NullPointerException – if the specified element is null
IllegalArgumentException – if some property of the specified element prevents it from being added to this queue

boolean offer(E e, long timeout, TimeUnit unit)
Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.
Throws:
InterruptedException		 		if interrupted while waiting
ClassCastException 					if the class of the specified element prevents it from being added to this queue
NullPointerException				if the specified element is null
IllegalArgumentException 		if some property of the specified element prevents it from being added to this queue

E poll(long timeout, TimeUnit unit) throws InterruptedException;          从 BlockingQueue 取出一个队首的对象，如果在 指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数 据可取，返回失败。
int drainTo(Collection<? super E> c, int maxElements);                   一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个 数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。
int drainTo(Collection<? super E> c);

ArrayBlockingQueue
package java.util.concurrent;
public class ArrayBlockingQueue<E>
extends AbstractQueue<E>
implements BlockingQueue<E>, Serializable

A bounded blocking queue backed by an array. This queue orders elements FIFO (first-in-first-out).
The head of the queue is that element that has been on the queue the longest time.
The tail of the queue is that element that has been on the queue the shortest time.
New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.

public ArrayBlockingQueue(int capacity)                   		   Creates an ArrayBlockingQueue with the given (fixed) capacity and default access policy.
public ArrayBlockingQueue(int capacity, boolean fair)      Creates an ArrayBlockingQueue with the given (fixed) capacity and the specified access policy.
Params:
capacity 	    the capacity of this queue
fair 				if true then queue accesses for threads blocked on insertion or removal, are processed in FIFO order; if false the access order is unspecified.
Throws:
IllegalArgumentException – if capacity < 1

LinkedBlockingQueue
package java.util.concurrent;
public class LinkedBlockingQueue<E>
extends AbstractQueue<E>
implements BlockingQueue<E>, java.io.Serializable

An optionally-bounded blocking queue based on linked nodes. This queue orders elements FIFO (first-in-first-out).
The head of the queue is that element that has been on the queue the longest time.
The tail of the queue is that element that has been on the queue the shortest time.
New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.
Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.

The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion.
The capacity, if unspecified, is equal to Integer.MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity.

private final ReentrantLock takeLock = new ReentrantLock();
private final ReentrantLock putLock = new ReentrantLock();
public LinkedBlockingQueue(int capacity)			Creates a {@code LinkedBlockingQueue} with the given (fixed) capacity.
public LinkedBlockingQueue()      						Creates a LinkedBlockingQueue with a capacity of Integer.MAX_VALUE.

LinkedBlockingDeque
package java.util.concurrent;
public class LinkedBlockingDeque<E>
An optionally-bounded blocking deque based on linked nodes.

The optional capacity bound constructor argument serves as a way to prevent excessive expansion.
The capacity, if unspecified, is equal to Integer.MAX_VALUE.
Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity.

public LinkedBlockingDeque()							Creates a LinkedBlockingDeque with a capacity of Integer.MAX_VALUE.
public LinkedBlockingDeque(int capacity)		Creates a LinkedBlockingDeque with the given (fixed) capacity.
Params:
capacity 								 the capacity of this deque
Throws:
IllegalArgumentException	 if capacity is less than 1
void addFirst(E e)
void addLast(E e)
boolean offerFirst(E e)
boolean offerLast(E e)
E peekFirst()
E peekLast()
E take()                  等同 于 takeFirst
E takeFirst()


LinkedTransferQueue
package java.util.concurrent;
public class LinkedTransferQueue<E> extends AbstractQueue<E>
    implements TransferQueue<E>, java.io.Serializable
An unbounded TransferQueue based on linked nodes. This queue orders elements FIFO (first-in-first-out) with respect to any given producer.
The head of the queue is that element that has been on the queue the longest time for some producer.
The tail of the queue is that element that has been on the queue the shortest time for some producer.

public LinkedTransferQueue()													Creates an initially empty LinkedTransferQueue.
public LinkedTransferQueue(Collection<? extends E> c)			Creates a LinkedTransferQueue initially containing the elements of the given collection, added in traversal order of the collection's iterator.
Params:
c – the collection of elements to initially contain
Throws:
NullPointerException – if the specified collection or any of its elements are null

public void transfer(E e) throws InterruptedException
Transfers the element to a consumer, waiting if necessary to do so.
More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll),
else inserts the specified element at the tail of this queue and waits until the element is received by a consumer.
Throws:
NullPointerException – if the specified element is null

public boolean tryTransfer(E e)
Transfers the element to a waiting consumer immediately, if possible.
More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll),
otherwise returning false without enqueuing the element.
Throws:
NullPointerException – if the specified element is null
public boolean tryTransfer(E e, long timeout, TimeUnit unit)
Transfers the element to a consumer if it is possible to do so before the timeout elapses.
More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll),
else inserts the specified element at the tail of this queue and waits until the element is received by a consumer,
returning false if the specified wait time elapses before the element can be transferred.
Throws:
NullPointerException – if the specified element is null

public E take() throws InterruptedException
The consumer in the LinkedTransferQueue class in Java is a thread that takes elements from the queue and processes them.
The consumer can use the take() method to take an element from the queue, or the poll() method to take an element from the queue if one is available without waiting.
PriorityBlockingQueue
package java.util.concurrent;
public class PriorityBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, java.io.Serializable
An unbounded blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations.
While this queue is logically unbounded, attempted additions may fail due to resource exhaustion (causing OutOfMemoryError).
This class does not permit null elements.
A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so results in ClassCastException).

DelayQueue
package java.util.concurrent;
public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
    implements BlockingQueue<E>
An unbounded blocking queue of Delayed elements, in which an element can only be taken when its delay has expired.
The head of the queue is that Delayed element whose delay expired furthest in the past.
If no delay has expired there is no head and poll will return null.
Expiration occurs when an element's getDelay(TimeUnit.NANOSECONDS) method returns a value less than or equal to zero.
Even though unexpired elements cannot be removed using take or poll, they are otherwise treated as normal elements.
For example, the size method returns the count of both expired and unexpired elements. This queue does not permit null elements.

SynchronousQueue
package java.util.concurrent;
public class SynchronousQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, java.io.Serializable
A blocking queue in which each insert operation must wait for a corresponding remove operation by another thread, and vice versa.
A synchronous queue does not have any internal capacity, not even a capacity of one.
You cannot peek at a synchronous queue because an element is only present when you try to remove it;
you cannot insert an element (using any method) unless another thread is trying to remove it; you cannot iterate as there is nothing to iterate.
The head of the queue is the element that the first queued inserting thread is trying to add to the queue;
if there is no such queued thread then no element is available for removal and poll() will return null.
For purposes of other Collection methods (for example contains), a SynchronousQueue acts as an empty collection.
This queue does not permit null elements.

public void put(E e) throws InterruptedException
Adds the specified element to this queue, waiting if necessary for another thread to receive it.
Throws:
InterruptedException – if interrupted while waiting
NullPointerException – if the specified element is null

public E take() throws InterruptedException
Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.
Returns:
the head of this queue
Throws:
InterruptedException – if interrupted while waiting
(thread management)
CountDownLatch
package java.util.concurrent;
public class CountDownLatch          让某一条线程等待其他线程执行完毕之后再执行。
                                 而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时 执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的
private static final class Sync extends AbstractQueuedSynchronizer
protected int tryAcquireShared(int acquires)
protected boolean tryReleaseShared(int releases)
private final Sync sync;

public CountDownLatch(int count)                  等待其他线程的数量，并定义了一个计数器
public void await() throws InterruptedException     让线程等待，当计数器变成0后，自动唤醒这个线程
public void countDown()                           线程执行完毕时调用，调用完毕后计数器-1（每个子线程执行完后 countDown()一次，state 会 CAS 减 1，等到所有子线程都执行完后即 state=0，会 unpark()主调用线程，然后主调用线程 就会从 await()函数返回，继续后余动作）
使用——————————————————————————————————————————————————————————————————————————
Main >>
//创建countDownLatch的对象,需要传递给四个线程。
CountDownLatch countDownLatch = new CountDownLatch(3);
//创建四个线程对象并开启他们。
MotherThread motherThread= new MotherThread(countDownLatch);
motherThread.start();
childThread1 t1=new childThread1(countDownLatch);
t1.setName("小明");
childThread1 t2=new childThread2(countDownLatch);
t1.setName("小红");
childThread1 t3=new childThread2(countDownLatch);
t1.setName("小刚");
t1.start();
t2.start();
t3.start();
MotherThread >>
public class MotherThread extends Thread {
    private CountDownLatch countDownLatch;
    public MotherThread( CountDownLatch countDownLatch) {
        this.countDownLatch = countDownLatch;
    }
    @Override
    public void run() {
        //等待
        try {
            countDownLatch. await();
        }catch (InterruptedException e) {
            e.printStackTrace();
        }
        //都吃完了，收拾碗筷
        System.out. println("妈妈在收拾碗筷");
    }
}
ChildThread >>
public class childThread1 extends Thread {
    private CountDownLatch countDownLatch;
    public chileThread1(CountDownLatch countDownLatch) {
        this.countDownLatch = countDownLatch;
    }
    @Override
    public void run() {
        //吃饺子
        for (int i = 1; i <= 15; i++) {
            System.out.println(getName() + "在吃第" + i + "个饺子");
        }
        //吃完说一声
        countDownLatch.countDown();
    }
}
CyclicBarrier
package java.util.concurrent;
public class CyclicBarrier              回环栅栏-等待至 barrier 状态再全部同时执行, 字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。
                                     叫做回环 是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做 barrier，当调用 await()方法之后，线程就处于 barrier 了

int await()                              用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任 务
int await(long timeout, TimeUnit unit)    让这些线程等待至一定的时间，如果还有 线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务
public static void main(String[] args) {         // 具体使用如下，另外 CyclicBarrier 是可以重用的
    int N = 4;
    CyclicBarrier barrier = new CyclicBarrier(N);
    for(int i=0;i<N;i++)
       new Writer(barrier).start();
    }
    static class Writer extends Thread{
       private CyclicBarrier cyclicBarrier;
       public Writer(CyclicBarrier cyclicBarrier) {
          this.cyclicBarrier = cyclicBarrier;
       }
       @Override
       public void run() {
          try {
             Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作
            System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕");
             cyclicBarrier.await();
          } catch (InterruptedException e) {
          e.printStackTrace();
          }catch(BrokenBarrierException e){
          e.printStackTrace();
          }
          System.out.println("所有线程写入完毕，继续处理其他任务，比如数据操作");
     }
 }
Semaphore
package java.util.concurrent;
public class Semaphore implements Serializable     信号量, 可以控制访问特定资源的线程数量。
               1. 概念：Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信 号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来 构建一些对象池，资源池之类的，比如数据库连接池
                       2. 实现互斥锁（计数器为 1）： 我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量， 表示两种互斥状态。
    3. 代码实现：它的用法如下
Semaphore semp = new Semaphore(5);          // 创建一个计数阈值为 5 的信号量对象，只能 5 个线程同时访问
try {       // 申请许可
    semp.acquire();
try {
    // 业务逻辑
} catch (Exception e) {
} finally {
    semp.release();  // 释放许可
}
} catch (InterruptedException e) {
}
4. Semaphore 与 ReentrantLock：Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与release()方法来获得和释放临界资源。
    经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。
    此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。
    Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。



public Semaphore(int permits)    许可证的数量

public void acquire()                获取一个许可，（若无许可能够获得，则会一直等待，直到获得许可）
public void acquire(int permits)      获取 permits 个许可
public void release()                归还许可 （在归还许可之前，必须先获获得许可）
public void release(int permits)      归还permits 个许可（上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法）

public boolean tryAcquire()                                    尝试获取一个许可，若获取成功，则立即返回 true，若获取失 败，则立即返回 false
public boolean tryAcquire(long timeout, TimeUnit unit)         尝试获取一个许可，若在指定的 时间内获取成功，则立即返回 true，否则则立即返回 false
public boolean tryAcquire(int permits)                         尝试获取 permits 个许可，若获取成功，则立即返 回 true，若获取失败，则立即返回 false
public boolean tryAcquire(int permits, long timeout, TimeUnit unit)    尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false
public int availablePermits()                                          得到可用的许可数目
使用——————————————————————————————————————————————————————————————————————————————————————————————————————
SemaphoreRunnable >>
public class SemphoreRunnable  implements Runnable {
    //获得管理员对象
    private Semaphore semaphore = new Semaphore(  2);
    @Override
    public void run( ) {
        //获得通行证
        try {
            semaphore.acquire();
            //开始行驶
            System.out.println("获得了通行证开始行驶");
            Thread.sleep(2000);
            System.out.println("归还通行证");
            //归还通行证
            semaphore.release();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
Main >>
SemphoreRunnable sr = new SemphoreRunnable();
for (int i = 0; i < 100; i++){
    new Thread(sr).start();
}

异步
Flow
package java.util.concurrent;
public final class Flow

Future
package java.util.concurrent;
public interface Future<V>
异步编程使用场景：定时服务，拉取结果回写，比如日志，数据库，更新缓存等。
V get() throws InterruptedException, ExecutionException;    阻塞模式
CountedCompleter
package java.util.concurrent;
public abstract class CountedCompleter<T> extends ForkJoinTask<T>   触发时执行完成操作，并且没有剩余的待处理操作。 与其他形式的ForkJoinTasks相比，CountedCompleters在子任务停顿和阻塞的情况下通常更强大，但编程不太直观。
CompletionStage
package java.util.concurrent;
public interface CompletionStage<T>       完成阶段动作
public CompletionStage<T> whenComplete (BiConsumer<? super T, ? super Throwable> action)    返回一个新的CompletionStage
CompletableFuture
package java.util.concurrent;
public class CompletableFuture<T> implements Future<T>, CompletionStage<T>      1.8 提供，异步多线程（创建的线程new Thread不在spring容器中，也就无法获得spring中的bean对象）

public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)          等待 所有的异步任务 并行完成（之后执行join 是获取 异步任务的返回值）
CompletableFuture.allOf(allFutures.toArray(new CompletableFuture[0])).join();
List<ContactDetail> allContactbetails = allFfutures.stream().map(Completableruturet:;join)..tolist();         获取每一个异步任务的返回值

public static CompletableFuture<Void> runAsync(Runnable runnable)                 注册无返回值的异步任务（可以不像Future一样阻塞get，直接在任务结束执行回调）
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)     Run asynchronis task immidiately, you can get return value later. 注册有返回值的异步任务
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,  Executor executor)         注册有返回值的异步任务
public static <U> CompletableFuture<U> completedFuture(U value)              拿到 异步任务返回值后， 返回新的CompletableFuture
public static <U> CompletableFuture<U> failedFuture(U value)         Returns a new CompletableFuture that is already completed with a given exception.
public <U> CompletableFuture<U> thenCompose(Function<? super T, ? extends CompletionStage<U>> fn)                组合多个CompletableFuture，将前一个任务的返回结果作为下一个任务的参数，它们之间存在着业务逻辑上的先后顺序。
public <U,V> CompletableFuture<V> thenCombine( CompletionStage<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)    合并给定的其他任务，两个一起完成时一起执行action
public boolean completeExceptionally(Throwable ex)                                       捕获特定异常
public CompletableFuture<T> whenComplete( BiConsumer<? super T, ? super Throwable> action)            返回一个新的CompletableFuture，完成后 异步执行action
T                  是上一个任务的返回值，
Throwable   是上一个任务出现的异常
public <U> CompletableFuture<U> handle( BiFunction<? super T, Throwable, ? extends U> fn)                返回一个新的CompletableFuture，完成后 执行action
public CompletionStage<T> whenCompleteAsync (BiConsumer<? super T, ? super Throwable> action)     返回一个新的CompletableFuture，完成后 异步执行action
public CompletionStage<T> exceptionally (Function<Throwable, ? extends T> fn)         异常处理
When an exception occurs, if multiple exception handlers are used, only the first one takes effect..
public CompletableFuture<T> exceptionally( Function<Throwable, ? extends T> fn)   发生异常时，进入catch函数内，可以返回默认数据，继续执行后续逻辑
public T get() throws InterruptedException, ExecutionException       获取 异步任务的返回值，抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）
public T get(long timeout, TimeUnit unit)          获取 异步任务的返回值，并添加超时时间
        throws InterruptedException, ExecutionException, TimeoutException
public T getNow(T valueIfAbsent)       立即获取，不论异步任务执行完成或没有
public T join()    获取 异步任务的返回值，抛出的是uncheck异常（即RuntimeException),不会强制开发者抛出
If there is no exception handler, throw exception directly.

使用————————————————————————————————————————————————————————————————————————————————
// 创建异步执行任务，有返回值
CompletableFuture<Double> cf = CompletableFuture.supplyAsync(()->{
    System.out.println(Thread.currentThread()+" start,time->"+System.currentTimeMillis());
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
    }
    if(true){
        throw new RuntimeException("test");
    }else{
        System.out.println(Thread.currentThread()+" exit,time->"+System.currentTimeMillis());
        return 1.2;
    }
});
System.out.println("main thread start,time->"+System.currentTimeMillis());
//等待子任务执行完成
System.out.println("run result->"+cf.get());
System.out.println("main thread exit,time->"+System.currentTimeMillis());
springboot >>
@Async("musterExecutor")
public CompletableFuture<Status> execute(Payload payload) {
    HttpHeaders headers = setHeaders();
    String input = Constructor.createPayload(payload);
    HttpEntity<String> requestEntity = new HttpEntity<String>(input, headers);
    Status s = restTemplate.postForObject(execution_url, request_execution, Status.class);

    return CompletableFuture.completedFuture(s);
}

所有阶段完成再处理>>
static void allOfExample() {
    StringBuilder result = new StringBuilder();
    List messages = Arrays.asList("a", "b", "c");
    List<CompletableFuture> futures = messages.stream()
            .map(msg -> CompletableFuture.completedFuture(msg).thenApply(s -> delayedUpperCase(s)))
            .collect(Collectors.toList());
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()])).whenComplete((v, th) -> {
        futures.forEach(cf -> assertTrue(isUpperCase(cf.getNow(null))));
        result.append("done");
    });
    assertTrue("Result was empty", result.length() > 0);
}

public List<R> getAllResult() {
    List<CompletableFuture<R>> futureList = taskList.stream().map(workFunction).collect(Collectors.toList());
    CompletableFuture<Void> allCompletableFuture = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[futureList.size()]));
    return allCompletableFuture.thenApply(e -> futureList.stream().map(CompletableFuture::join).collect(Collectors.toList())).join();
}
ScheduledExecutorService
package java.util.concurrent;
public interface ScheduledExecutorService extends ExecutorService   基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响
锁
AbstractOwnableSynchronizer
package java.util.concurrent.locks;
public abstract class AbstractOwnableSynchronizer
    implements java.io.Serializable
private transient Thread exclusiveOwnerThread;
AbstractQueuedSynchronizer
package java.util.concurrent.locks;
public abstract class AbstractQueuedSynchronizer   AQS，定义了一套多线程访问 共享资源的同步器框架（抽象的队列同步器）
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable

state：共享资源计数器（如果state的获取方法都定义成abstract，那么每个模式也要去实现另一模 式下的接口。不同的自定义同步器争用共享资源的方式也不同。）
该属性的值即表示了锁的状态，state为0表示锁没有被占用，state大于0表示当前已经有线程持有该锁（因为可能存在可重入的情况，可以把state变量当做是当前持有该锁的线程数量）
在监视器锁中，我们用objectMonitor对象的_owner属性记录了当前拥有监视器锁的线程，而在AQS中，我们将通过 exclusiveOwnerThread属性获取。
AQS 同步器实现：只需实现 tryAcquire+tryRelease、tryAcquireShared+tryReleaseShared 中的一种即可 （自定义同步器在实现时只需要实 现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队/ 唤醒出队等，AQS 已经在顶层实现好了）
独占资源：ReentrantLock
共享资源：Semaphore/CountDownLatch
双向链表 添加尾节点步骤：  并发环境下，添加尾节点的第2、3步只会有一个线程能够执行到
node.prev=tail                  当前节点指向尾部
compareAndSetTail(tail, node)   CAS设置node为尾节点
tail.next=node                 如果CAS成功，则修改tail的next指向node节点

AQS尾分叉：如果存在很多个线程都刚好执行到了node.prev = tail这里，那么CAS失败的线程不能成功入队，此时它们的prev还暂时指向的旧tail
prev的有效性：当CAS设置node为尾节点了，但是还没来的及修改tail.next指针，此时如果另一个线程如果通过next指针从前向后遍历队列，就会漏掉最后一个（但如果另一个线程通过tail成员的prev指针从后向前遍历队列，就不会漏掉node了）
prev的有效性也解释了AQS源码里遍历队列时，为什么常常使用tail成员和prev指针来遍历

static final class Node       FIFO 线程等待队列（由双向链表形成的双向队列，多线程争用锁资源被阻塞时会进入此队列）
private volatile int state;     共享资源状态计数
protected final int getState()
protected final void setState(int newState)
protected final boolean compareAndSetState(int expect, int update)

protected boolean isHeldExclusively()               该线程是否正在独占资源。只有用到 condition 才需要去实现它。【自定义同步器】
protected boolean tryAcquire(int arg)              独占方式。尝试获取资源，成功则返回 true，失败则返回 false（获取锁后，state+1，其他线程再 tryAcquire时就会失 败，直到 A 线程 unlock()到 state=0为止） 【自定义同步器】
protected boolean tryRelease(int arg)               独占方式。尝试释放资源，成功则返回 true，失败则返回 false。【自定义同步器】

protected int tryAcquireShared(int arg)            共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。【自定义同步器】
protected boolean tryReleaseShared(int arg)       共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。【自定义同步器】
Lock
package java.util.concurrent.locks;
public interface Lock       更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock（Lock则采用“CAS+volatile”实现，其实现的核心是AQS）

void lock();                 获取锁（当锁被其他线程持有，当前线程会一直等待）
void unlock();              释放锁（锁只能由持有者释放, 如果线程 并不持有锁, 却执行该方法, 会导致异常的发生）


boolean tryLock();          尝试获取锁，返回获取结果（当锁被其他线程持有，返回false继续执行下方代码）
Condition newCondition();   条件对象，获取等待通知组件。该组件和当前的锁绑定， 当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。
Condition
package java.util.concurrent.locks;
public interface Condition
                    Condition 类和 Object 类锁方法区别：
Condition 类的 awiat 方法和 Object 类的 wait 方法等效
Condition 类的 signal 方法和 Object 类的 notify 方法等效
Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效
ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的
ReentrantLock
package java.util.concurrent.locks;
public class ReentrantLock implements Lock, Serializable   可重入锁 【6】
synchronized和ReentrantLock的区别：使用synchronized关键字实现同步，线程执行完同步代码块会自动释放锁，而ReentrantLock需要手动释放锁。（为了避免程序出 现异常而无法正常解锁或死锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操 作）
synchronized是非公平锁，ReentrantLock默认是非公平锁，可以设置为公平锁
ReentrantLock上等待获取锁的线程是可中断的，线程可以放弃等待锁。而synchonized会无限期等待下去。
ReentrantLock可以设置超时获取锁。在指定的截止时间之前获取锁，如果截止时间到了还没有获取到锁，则返回。
ReentrantLock的tryLock()方法可以尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回true，否则返回false。
底层实现不一样， synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略
public ReentrantLock()                  空参构造
public ReentrantLock(boolean fair)      ReentrantLock 在构造函数中提供了是否公平锁的初始化方式

abstract static class Sync extends AbstractQueuedSynchronizer
private final Sync sync;


public Condition newCondition()                返回用来与此 Lock 实例一起使用的 Condition 实例。在使用内置监视器锁时，返回的 Condition 实例支持与 Object 的监视器方法（wait、notify 和 notifyAll）相同的用法。
final int getQueueLength()                       返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个 线程获得锁，此时返回的是 9
int getWaitQueueLength(Condition condition)       返回等待与此锁相关的给定条件的线 程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10
boolean hasWaiters(Condition condition)        查询是否有线程等待与此锁有关的给定条件 (condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法
final boolean hasQueuedThread(Thread thread)    查询给定线程是否等待获取此锁
final boolean hasQueuedThreads()                 查询给定线程是否等待获取此锁
final boolean isFair()                               该锁是否公平锁
boolean isHeldByCurrentThread()                  当前线程是否保持锁锁定，线程的执行 lock 方法的前后分 别是 false 和 true
boolean isLocked()                                此锁是否有任意线程占用

void lockInterruptibly()                            能获得锁就返回 true，不能的话一直等待获得锁（此时中断当前线程会抛出异常）
public void lock()                                  能获得锁就返回 true，不能的话一直等待获得锁（此时中断当前线程不会抛出异常）
boolean tryLock()                                  尝试获得锁，能获得锁就返回 true，不能就立即返回 false
boolean tryLock(long timeout, TimeUnit unit)       可以增加时间限制，如果超过该时间段还没获得锁，返回 false
final int getHoldCount()                           查询当前线程拿到锁的次数，也就是执行此线程执行 lock 方法的次 数

使用————————————————————————————————————————————————————————————————————————
MAIN >>
private Lock lock = new ReentrantLock();
//Lock lock=new ReentrantLock(true);//公平锁
//Lock lock=new ReentrantLock(false);//非公平锁
private Condition condition=lock.newCondition();//创建 Condition
public void testMethod() {
    try {
        lock.lock();          //lock 加锁
        condition.await();    //开始wait 方法等待（通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁）
        condition.signal();   //signal 方法唤醒（condition 对象的 signal 方法可以唤醒 wait 线程）
        for (int i = 0; i < 5; i++) {
            System.out.println("ThreadName=" + Thread.currentThread().getName()+ (" " + (i + 1)));
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    finally{
        lock.unlock();
    }
}
ReadWriteLock
package java.util.concurrent.locks;
public interface ReadWriteLock      读写锁，在读的地方使用读锁，在写的地方使用写锁，如 果没有写锁的情况下，读是无阻塞的（多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可）
ReentrantReadWriteLock
package java.util.concurrent.locks;
public class ReentrantReadWriteLock                      AQS 同步器实现类，同时实现独占和共享两种方式
        implements ReadWriteLock, java.io.Serializable

锁设计：AQS的状态state是int类型（2byte）的，分成两份：读锁用高16位，表示持有读锁的线程数（sharedCount)，写锁低16位，表示写锁的重入次数( exclusivecount) 。

Sync源码:  ReadLock和WriteLock方法都是通过调用Sync的方法实现的
Sync状态值为0表示锁空闲，sharedCount不为0表示分配了读锁，exclusiveCount不为0表示分配了写锁。（sharedCount和exclusiveCount一般不会同时不为0，除了锁降级情况：线程占用了写锁，该线程可以重入获取读锁）

独占锁（写）和公平锁（读）:
写锁：当一个写线程拥有锁后，其他读写线程不能获取锁。
读锁：当一个读线程获取锁后，其他读线程仍然可以获取锁，但是写线程不能获取锁
锁策略
公平锁策略：线程排队获取锁
非公平锁策略：不用排队就直接竞争获取锁，但除了一种情况：为了防止写线程饥饿，如果同步队列中的第一个节点是写线程，则阻塞当前线程。
锁升级和降级
升级：同一个线程中，在没有释放读锁的情况下，就去申请写锁，这属于锁升级，ReentrantReadWriteLock是不支持的。
ReadWriteLock rtLock = new ReentrantReadWriteLock();
rtLock.readLock().lock();
System.out.println("get readLock.");

rtLock.writeLock().lock();    // 可能获取不到写锁
System.out.println("blocking");
rtLock.readLock().unlock();
rtLock.writeLock().unlock();
降级：同一个线程中，在没有释放写锁的情况下，就去申请读锁，这属于锁降级，ReentrantReadWriteLock是支持的
ReadWriteLock rtLock = new ReentrantReadWriteLock();
rtLock.writeLock().lock();
System.out.println("writeLock");

rtLock.readLock().lock();
System.out.println("get read lock");
rtLock.writeLock().unlock();
rtLock.readLock().unlock();

private final ReentrantReadWriteLock.ReadLock readerLock;
private final ReentrantReadWriteLock.WriteLock writerLock;

abstract static class Sync extends AbstractQueuedSynchronizer
static final int SHARED_SHIFT   = 16;
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;

static final int SHARED_UNIT= (1 << SHARED_SHIFT);           读线程获取到了读锁，则state值就会加一个 SHARED_UNIT, 写线程获取到了锁，这时候 state 会直接加1  // 也就是二进制 1000 0000 0000 0000
static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;              // 也就是 0111 1111 1111 1111

static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }
static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

final Sync sync;
atomic
AtomicBoolean
package java.util.concurrent.atomic;
public class AtomicBoolean implements java.io.Serializable


compareAndSet
public final boolean compareAndSet(boolean expectedValue, boolean newValue) {   // Atomically sets the value to newValue if the current value == expectedValue.
    return VALUE.compareAndSet(this,
                               (expectedValue ? 1 : 0),
                               (newValue ? 1 : 0));
}


AtomicInteger
package java.util.concurrent.atomic;

public class AtomicInteger extends Number implements Serializable         原子包（多线程环境下可以同步原子的更新值，通常AtomicInteger的性能是 ReentantLock 的好几倍）

public final int get()                        获取值
public final int getAndIncrement()          以原子方式将当前值加1，注意，这里返回的是自增前的值。
public final int incrementAndGet()          以原子方式将当前值加1，注意，这里返回的是自增后的值。（getIntVolatile获取副本值，再调用compareAndSwapInt比较旧值和内存值，成功赋值副本值，失败重试）
public final int addAndGet(int data)         以原子方式将参数与对象中的值相加，并返回结果。
public final int getAndSet(int value)        以原子方式设置为newvalue的值，并返回旧值。
AtomicReference
package java.util.concurrent.atomic;
public class AtomicReference<V> implements Serializable       将一个对象的所有操作转化成原子操作
LongAdder
package java.util.concurrent.atomic;
public class LongAdder extends Striped64 implements Serializable       JDK1.8新增，因为非常高并发的请求下AtomicLong的性能是不能让人接受的

结构：内部维护一个Cells数组和一个基值变量base。数组的下标使用每个线程的hashcode值的掩码表示。每个Cell里面有一个初始值为0的long型变量。
      数组大小保持2的N次方大小。
设计目的：减少了高并发情况下对共享资源的争夺。
执行过程：多个线程在争夺同一个原子变量时候，如果失败并不是自旋CAS重试，而是尝试获取其他原子变量的锁，最后当获取当前值时候是把所有变量的值累加后再加上base的值返回的。
stream
Collectors
package java.util.stream;
public final class Collectors           收集器
public static Collector<CharSequence, ?, String> joining(CharSequence delimiter)    根据字符拼接字符串数组
public static <T> Collector<T, ?, List<T>> toList()   返回数组收集器
public static <T> Collector<T, ?, Set<T>> toSet()    返回去重集合收集器
public static <T, C extends Collection<T>>  Collector<T, ?, C> toCollection(Supplier<C> collectionFactory)   将所有元素传入指定的构造中，返回集合收集器
、、 List<String> linkedListResult = list.stream().collect(Collectors.toCollection(LinkedList::new))      返回LinkedList
public static<T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)   先把流中的所有元素传递给第一个参数，然后把生成的集合传递给第二个参数来处理。
(List)implementations.stream().distinct().collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));

public static <T, K, U>Collector<T, ?, Map<K,U>> toMap(
Function<? super T, ? extends K> keyMapper,
Function<? super T, ? extends U> valueMapper,
BinaryOperator<U> mergeFunction)
list变map，Function.identity()表示item自己，为空返回空map
// list.stream().collect(   Collectors.toMap(Contact::getContactId, Function.identity())   )
map.values() is immutable.
the return map is modifiable.
     Map<Integer, List<String>> collect = people.stream().collect(Collectors.toMap(Person::getAge, item -> new ArrayList<>(Arrays.asList(item.getName())), (v1, v2) -> {
            v1.addAll(v2);
            return v1;
        }));
usage
Collectors.groupingBy( Product::getCategory )                                                属性值分组 -- Object
//{ "啤酒":[{"category":"啤酒","id":4},{"category":"啤酒","id":5}],   "零食":[{"category":"零食","id":1 },{"category":"零食","id":2} ] }
Collectors.groupingBy(item -> item.getCategory() + "_" + item.getName() )  拼接值分组  -- Object
//{ "零食_月饼":[{"category":"零食","id":3,"name":"月饼"}],   "零食_面包":[{"category":"零食","id":1,"name":"面包" }] }
Collectors.groupingBy(item -> {                                                                         条件分组
//{"other":[{"id":3,"num":3},{"id":4, "num":3},  3":[{"id":1, "num":1 },{"id":2,"num":2}]}
	if(item.getNum() < 3) {
		return "3";
	}else {
		return "other";
	}
})
Collectors.collectingAndThen( Collectors.toCollection(()->new TreeSet<>(Comparator.comparing( WorkItem::getWorkItemId )) ) ,    ArrayList::new )       先进行结果集的收集，然后将收集到的结果集进行下一步的处理
Stream
package java.util.stream;
public interface Stream<T> extends BaseStream<T, Stream<T>>     所有的流对象只能使用一次，用完就关闭了，不能复用
String[] => List;            List<element> list = new ArrayList<element>(array.length);     Collections.addAll(list, array);
String[] = LinkedList;       LinkedList sourceList=Arrays.stream(array).map(Integer::valueOf).collect(Collectors.toCollection(LinkedList::new));
"aaa"=> Character[]        Character[] charObjectArray = str.chars().mapToObj(c -> (char)c).toArray(Character[]::new);
核心类：
java.util.stream.StreamSupport       流支持


public static<T> Stream<T> of(T... values)       快速创建一个数组，调用Arrays.stream方法
This code "Stream.of(arr)" will convert original arr as a single element to an array.
However, " Arrays.stream(arr)" will convert original arr to a new complete array.
public static<T> Stream<T> empty()               返回一个空流
public static<T> Stream<T> iterate(
final T seed,                               初始参数
final UnaryOperator<T> f         使用初始参数制造下一个参数，以此循环，以此循环可以制造无限个元素，在实际使用中一般使用limit（n）方法去获取包含n个的流
)
public static<T> Stream<T> generate(Supplier<? extends T> s)      根据提供者生成流

Stream<T> distinct();     使用equals方法去重
<R> Stream<R> map(Function<? super T, ? extends R> mapper);       遍历，根据返回值组成新数组（person的类型会变成Object，R为动态识别类型）         //  map(  person -> func()  )
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)         扁平化流，把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流
当你需要将 [[a,b,c],[d,e,f],[x,y,z]] 具有两个级别的数据结构转换为 [a,b,c,d,e,f,x,y,z] 这样单层的数据结构时，就选择使用 flatMap 处理。
//  words.stream()  .map(w -> w.split(""))  .flatMap(Arrays::stream)  .distinct()  .collect(Collectors.toList());     Stream<String[]>  =>  Stream<String>
IntStream mapToInt(ToIntFunction<? super T> mapper);                遍历返回intStream    //  mapToInt(num -> Integer.parseInt(num))
LongStream mapToLong(ToLongFunction<? super T> mapper);
// int collect = (int)smpYmlProperties.getProject().stream().mapToLong(projectInfo -> projectInfo.getEnvList().size()).sum();
// EnvAction[] envActionList=new EnvAction[collect];
Stream<T> sorted();                                                  返回排序流
Integer:     1, 2, 3, 4
Stream<T> sorted(Comparator<? super T> comparator);   指定排序规则
                                              // List<Fruit> listP2 = listP.stream().sorted(Comparator.comparing(Fruit::getName).reversed().thenComparing(Comparator.comparing(Fruit::getWeight).reversed())).collect(Collectors.toList());
Collections.reverseOrder()

Stream<T> filter(Predicate<? super T> predicate);                     遍历筛选           // filter(x -> x.getSalary() > 8000)
void forEach(Consumer<? super T> action);                           遍历
Optional<T> reduce(BinaryOperator<T> accumulator)               reduce中返回的结果会作为下次累加器计算的第一个参数（第一个参数是上次函数执行的返回值，初始值为第一个元素的值，第二个参数是stream中的元素，初始值为第二个元素的值）     // reduce((x, y) -> x += y)
T reduce(T identity, BinaryOperator<T> accumulator);                reduce中返回的结果会作为下次累加器计算的第一个参数（第一个参数是上次函数执行的返回值，初始值为identity，第二个参数是stream中的元素，初始值为第一个元素的值）     // reduce(999, (x, y) -> x += y)


Optional<T> findAny();                                              结果任何符合要求的数据，和findFirst一样，filter找到后不会往后执行     //  A a =bList().stream().filter(b->"test".equals(b.getName())).findAny().orElse(null);
Optional<T> findFirst();

<R, A> R collect(Collector<? super T, A, R> collector);      处理结果流          // collect( xxCollectors.xxxx() )
Stream<T> distinct();            结果去重
boolean anyMatch(Predicate<? super T> predicate);        满足一个就返回true   //  .anyMatch( student -> student.getAge() > 27 )
<A> A[] toArray(IntFunction<A[]> generator)              将流转换到 指定创建的数组        //  Integer[] integers = integerStream.toArray(Integer[]::new);
Object[] toArray();                                        将流转换为一个默认数组
Stream<T> limit(long maxSize);             限制管道前方返回的结果

<R> R collect(
Supplier<R> supplier,
BiConsumer<R, ? super T> accumulator,       第一个参数是提供者提供的对象，也就是最终作为结果要返回的对象。      第二个参数是流里面的数据，要进行循环的数据
BiConsumer<R, R> combiner                       对上一个并行流返回的各个对象 进行合并
);

List<String> strList = Stream.builder()
                .add("aaa")
                .add("bbb")
                .add("ccc")
                .build().parallel()
                .collect(() -> new ArrayList<String>(),
                        (list, str) -> list.add(String.valueOf(str)),
                        (list1, list2) -> list1.addAll(list2));
IntStream
package java.util.stream;
public interface IntStream extends BaseStream<Integer, IntStream>    数值流

public static IntStream of(int... values)    转换成数值流
public static IntStream range(int startInclusive, int endExclusive)         返回的一个startInclusive - endInclusive的数字流，开区间 [2,30）
//  String[] s1, String[] s2    =>   IntStream.range(0, s1.length).allMatch(i -> s1[i].equals(s2[i]));
public static IntStream rangeClosed(int startInclusive, int endInclusive)   返回的一个startInclusive - endInclusive的数字流，闭区间 [2,30]

boolean allMatch(IntPredicate predicate);     判断每次返回的条件是否全部相等

OptionalInt reduce(IntBinaryOperator op)              reduce中返回的结果会作为下次累加器计算的第一个参数
（第一个参数是上次函数执行的返回值，初始值为第一个元素的值，第二个参数是stream中的元素）     // reduce((x, y) -> x += y)
int reduce(int identity, IntBinaryOperator op)           reduce中返回的结果会作为下次累加器计算的第一个参数
（第一个参数是上次函数执行的返回值，初始值为identity，第二个参数是stream中的元素）     // reduce(999, (x, y) -> x += y)
int sum()                    			计算总和
int[] toArray()                 将流转换为数组

Stream<Integer> boxed()     数值流转换为流，流中的元素全部装箱  // 完全等于：mapToObj(Integer::valueOf);
<U> Stream<U> mapToObj(IntFunction<? extends U> mapper)    数值流转换为流，遍历每一个元素并返回成新数组流
<R> R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner);						Unlike Stream::collect, it needs to be used with IntStream::boxed method
StreamSupport
package java.util.stream;
public final class StreamSupport     流支持
public static <T> Stream<T> stream(            创建ReferencePipeline.Head引用流抽象
Spliterator<T> spliterator,        分流器
boolean parallel                        并行化
)
ReferencePipeline
package java.util.stream;
abstract class ReferencePipeline<P_IN, P_OUT>                   pipeline里对于中间操作和源头实现的抽象类
        extends AbstractPipeline<P_IN, P_OUT, Stream<P_OUT>>
        implements Stream<P_OUT>
static class Head<E_IN, E_OUT> extends ReferencePipeline<E_IN, E_OUT>    自继承接口，头部操作抽象
Head(Supplier<? extends Spliterator<?>> source, int sourceFlags, boolean parallel)
Head(Spliterator<?> source, int sourceFlags, boolean parallel)
public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper)    map操作
StreamSpliterators
package java.util.stream;
class StreamSpliterators       流分流器工具
abstract static class InfiniteSupplyingSpliterator<T> implements Spliterator<T>       无穷供给分流器工具
public boolean tryAdvance(Consumer<? super T> action)        提供者作为参数，消费
regex
Matcher
package java.util.regex;
public final class Matcher implements MatchResult

public boolean find()      为true表示匹配到，如果匹配到多个，下一次调用 偏移到下一个匹配结果，每一次匹配可以理解为一组，从0开始，没有匹配到更多的返回false
public boolean find(int start)  从指定位置开始 匹配，此种方式不会移动指针
public int start()           匹配字符串 第一个字符索引
public int end()           匹配字符串 最后一个字符索引
public String group()                           当前regex匹配到的字符串（必须先调用find，和find使用同一个matcher）
public String group(int group)             0为整个字符串，其他表示当前regex匹配到第几组的字符串，正则括号的内容，没匹配到为null（必须先调用find，和find使用同一个matcher）
如果出现分组(xxx)+  匹配多个的情况，此分组只会匹配第一种情况
public String replaceFirst(String replacement)     替换第一次匹配的数据
public String replaceAll(String replacement)      替换所有匹配的数据
public int regionStart()       匹配区域的开始，默认为0
public int regionEnd()        匹配区域的结束，默认为字符串的length
public boolean matches()  是否完全匹配
public Matcher reset()       充值指针
public static String quoteReplacement(String s)      Add ‘\\’ after chars ‘\\’  and ‘$’.
Pattern
package java.util.regex;
public final class Pattern implements java.io.Serializable    正则

public static Pattern compile(String regex)                            				根据正则 返回Pattern实例（因为Pattern构造器是私有的）
public static boolean matches(String regex, CharSequence input)       是否完全匹配正则，matcher的find是部分匹配
// Pattern.matches("\\d+","2223");           2223  -->  true      2223aa -->  false  22bb23 --> false
public static String quote(String s)       Returns a literal pattern String for the specified String.

public Matcher matcher(CharSequence input)     匹配字符串

使用————————————————————————————————————————————————————————————————————————————————
Pattern pattern = Pattern.compile("\\w+");
Matcher matcher = pattern.matcher("hello abc bbc cbc ccc");
//find向前迭代
while(matcher.find()){
    System.out.println(matcher.group());
}
zip
Deflater
package java.util.zip;
public class Deflater      同时使用了LZ77算法与哈夫曼编码的一个无损数据压缩算法
Inflater
package java.util.zip;
public class Inflater    This class provides support for general purpose decompression using the popular ZLIB compression library.
                                     The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents.
                                     It is fully described in the specifications at the  java.util.zip package description
ZStreamRef
package java.util.zip;
class ZStreamRef      A reference to the native zlib's z_stream structure.

ZipInputStream
package java.util.zip;
public class ZipInputStream extends InflaterInputStream implements ZipConstants
public byte[] readAllBytes() throws IOException
function
函数
Function
package java.util.function;
public interface Function<T, R>           函数式接口，接收T，返回R结果
java.lang.Runnable
static <T> Function<T, T> identity()          返回一个原样返回的匿名函数
default <V> Function<T, V> andThen(Function<? super R, ? extends V> after)        调用当前函数，    将当前函数的返回值作为after函数的参数
default <V> Function<V, R> compose(Function<? super V, ? extends T> before)     调用before函数，将before的返回值作为当前函数的参数
R apply(T t);
IntFunction
package java.util.function;
public interface IntFunction<R>       函数式接口，接收int参数，返回R结果
R apply(int value);
LongFunction
package java.util.function;
public interface LongFunction<R>       函数式接口，接收long参数，返回R结果
R apply(long value);

ToDoubleFunction
package java.util.function;
public interface ToDoubleFunction<T>      函数式接口，接收T参数，返回Double结果
ToIntFunction
package java.util.function;
public interface ToIntFunction<T>        函数式接口，接收T参数，返回Int结果
ToLongFunction
package java.util.function;
public interface ToLongFunction<T>        函数式接口，接收T参数，返回Long结果
LongToIntFunction
package java.util.function;
public interface LongToIntFunction        函数式接口，接收long参数，返回int结果
LongToDoubleFunction
package java.util.function;
public interface LongToDoubleFunction        函数式接口，接收long参数，返回double结果
IntToLongFunction
package java.util.function;
public interface IntToLongFunction        函数式接口，接收int参数，返回long结果
IntToDoubleFunction
package java.util.function;
public interface IntToDoubleFunction        函数式接口，接收int参数，返回double结果


双参函数
BiFunction
package java.util.function;
public interface BiFunction<T, U, R>      函数式接口，接收T，U两个参数，返回R结果
R apply(T t, U u);
default <V> BiFunction<T, U, V> andThen(Function<? super R, ? extends V> after)
ToDoubleBiFunction
package java.util.function;
public interface ToDoubleBiFunction<T, U>   函数式接口，接收T，U两个参数，返回double结果
ToIntBiFunction
package java.util.function;
public interface ToIntBiFunction<T, U>       函数式接口，接收T，U两个参数，返回Int结果
ToLongBiFunction
package java.util.function;
public interface ToLongBiFunction<T, U>       函数式接口，接收T，U两个参数，返回long结果
消费者
Consumer
package java.util.function;
public interface Consumer<T>                      函数式接口，接受一个输入参数T，并且无返回值，相当于消费者
void accept(T t);                                             函数式接口的函数方法，传入一个任意类型，无返回值
default Consumer<T> andThen(Consumer<? super T> after)      可以传入一个 Consumer，返回组合了两个 Consumer 后的 Consumer ，传入的 Consumer 不能为 null
DoubleConsumer
package java.util.function;
public interface DoubleConsumer     函数式接口，接收Double参数，不返回结果
void accept(double value);
default DoubleConsumer andThen(DoubleConsumer after)
IntConsumer
package java.util.function;
public interface IntConsumer         函数式接口，接收Int参数，不返回结果
void accept(int value);
default IntConsumer andThen(IntConsumer after)
LongConsumer
package java.util.function;
public interface LongConsumer      函数式接口，接收long参数，不返回结果
void accept(long value);
default LongConsumer andThen(LongConsumer after)
ObjLongConsumer
package java.util.function;
public interface ObjLongConsumer<T>   接收T，long参数，不返回结果
ObjIntConsumer
package java.util.function;
public interface ObjIntConsumer<T>   接收T，int参数，不返回结果
ObjDoubleConsumer
package java.util.function;
public interface ObjDoubleConsumer<T>   接收T，double参数，不返回结果


双参消费者
BiConsumer
package java.util.function;
@FunctionalInterface
public interface BiConsumer<T, U>   函数式接口，接收T，U参数，不返回结果

提供者
Supplier
package java.util.function;
public interface Supplier<T>     函数式接口，无参数，返回T结果
T get();
LongSupplier
package java.util.function;
public interface LongSupplier   函数式接口，无参数，返回long结果


一元二元函数
BinaryOperator
package java.util.function;
public interface BinaryOperator<T> extends BiFunction<T,T,T>     函数式接口， 接受T，T两个同类型参数，返回同类型T结果
public static <T> BinaryOperator<T> minBy(Comparator<? super T> comparator)
public static <T> BinaryOperator<T> maxBy(Comparator<? super T> comparator)
LongBinaryOperator
package java.util.function;
public interface LongBinaryOperator    接收long，long两个同类型参数，返回long结果
UnaryOperator
package java.util.function;
public interface UnaryOperator<T> extends Function<T, T>      接收T参数，返回同类型T结果
static <T> UnaryOperator<T> identity()
LongUnaryOperator
package java.util.function;
public interface LongUnaryOperator    接收long参数，返回long结果
IntUnaryOperator
package java.util.function;
public interface IntUnaryOperator    接收int参数，返回int结果

条件函数
Predicate
package java.util.function;
public interface Predicate<T>         函数式接口，接收参数 T，返回boolean结果
boolean test(T t);                            断言 是否成立
default Predicate<T> and(Predicate<? super T> other)   组合其他断言
default Predicate<T> negate()                                           返回一个完全相反的断言
default Predicate<T> or(Predicate<? super T> other)      或关系，组合一个断言
static <T> Predicate<T> isEqual(Object targetRef)            使用equals判断参数是否相同
static <T> Predicate<T> not(Predicate<? super T> target)     返回一个完全相反的断言


LongPredicate
package java.util.function;
public interface LongPredicate       函数式接口，接收参数 long，返回boolean结果
prefs
package java.util.prefs;

/**
 * Static methods for translating Base64 encoded strings to byte arrays         用于将Base64编码字符串转换为字节数组的静态方法，反之亦然。
 * and vice-versa.
 *
 * @author  Josh Bloch
 * @see     Preferences
 * @since   1.4
 */
class Base64             base64编解码类
